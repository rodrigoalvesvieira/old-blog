<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>blaze::StaticVector&lt; Type, N, TF &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d4/d83/classblaze_1_1StaticVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::StaticVector&lt; Type, N, TF &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../d4/d95/group__static__vector.html">StaticVector</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Efficient implementation of a fixed-sized vector.The <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> class template is the representation of a fixed-size vector with statically allocated elements of arbitrary type. The type of the elements, the number of elements and the transpose flag of the vector can be specified via the three template parameters:  
 <a href="../../d9/d3c/classblaze_1_1StaticVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/d87/dense_2StaticVector_8h_source.html">StaticVector.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; StaticVector&lt; Type, N, TF &gt;, TF &gt;</a>, and <a class="el" href="../../d1/d85/classblaze_1_1AlignedStorage.html">blaze::AlignedStorage&lt; Type &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae65156f33c23ac6219340f37e926f319"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>vectorizable</b> = IsVectorizable&lt;Type&gt;::value
 }</td></tr>
<tr class="memdesc:ae65156f33c23ac6219340f37e926f319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for intrinsic optimization.  <a href="../../d9/d3c/classblaze_1_1StaticVector.html#ae65156f33c23ac6219340f37e926f319">More...</a><br/></td></tr>
<tr class="separator:ae65156f33c23ac6219340f37e926f319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea21dd5290583b74b95602d678cf2cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>canAlias</b> = 0
 }</td></tr>
<tr class="memdesc:a6ea21dd5290583b74b95602d678cf2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for the detection of aliasing effects.  <a href="../../d9/d3c/classblaze_1_1StaticVector.html#a6ea21dd5290583b74b95602d678cf2cc">More...</a><br/></td></tr>
<tr class="separator:a6ea21dd5290583b74b95602d678cf2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27407deb6e8fcde0cbeba5514de5bcc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27407deb6e8fcde0cbeba5514de5bcc0"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a27407deb6e8fcde0cbeba5514de5bcc0">This</a></td></tr>
<tr class="memdesc:a27407deb6e8fcde0cbeba5514de5bcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> instance. <br/></td></tr>
<tr class="separator:a27407deb6e8fcde0cbeba5514de5bcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebc74568870c096aff709ea6e9e2dcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ebc74568870c096aff709ea6e9e2dcd"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a27407deb6e8fcde0cbeba5514de5bcc0">This</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3ebc74568870c096aff709ea6e9e2dcd">ResultType</a></td></tr>
<tr class="memdesc:a3ebc74568870c096aff709ea6e9e2dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br/></td></tr>
<tr class="separator:a3ebc74568870c096aff709ea6e9e2dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b43ddfc00703c92bb9b59ddc17a5cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30b43ddfc00703c92bb9b59ddc17a5cf"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N,!TF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a30b43ddfc00703c92bb9b59ddc17a5cf">TransposeType</a></td></tr>
<tr class="memdesc:a30b43ddfc00703c92bb9b59ddc17a5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br/></td></tr>
<tr class="separator:a30b43ddfc00703c92bb9b59ddc17a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264c1ba5f4d9df14b0a94e6d550bfed5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a264c1ba5f4d9df14b0a94e6d550bfed5"></a>
typedef Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a264c1ba5f4d9df14b0a94e6d550bfed5">ElementType</a></td></tr>
<tr class="memdesc:a264c1ba5f4d9df14b0a94e6d550bfed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector elements. <br/></td></tr>
<tr class="separator:a264c1ba5f4d9df14b0a94e6d550bfed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde048ffa6c26c7b74138d96b7397748"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abde048ffa6c26c7b74138d96b7397748"></a>
typedef IT::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abde048ffa6c26c7b74138d96b7397748">IntrinsicType</a></td></tr>
<tr class="memdesc:abde048ffa6c26c7b74138d96b7397748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type of the vector elements. <br/></td></tr>
<tr class="separator:abde048ffa6c26c7b74138d96b7397748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329eb5756ccc6025022b731513c86a7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a329eb5756ccc6025022b731513c86a7b"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a329eb5756ccc6025022b731513c86a7b">ReturnType</a></td></tr>
<tr class="memdesc:a329eb5756ccc6025022b731513c86a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br/></td></tr>
<tr class="separator:a329eb5756ccc6025022b731513c86a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae70387b27dfc332220df1d6154a3d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ae70387b27dfc332220df1d6154a3d5"></a>
typedef const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a4ae70387b27dfc332220df1d6154a3d5">CompositeType</a></td></tr>
<tr class="memdesc:a4ae70387b27dfc332220df1d6154a3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br/></td></tr>
<tr class="separator:a4ae70387b27dfc332220df1d6154a3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118925eca196e15e0d45031ccf7a7fba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a118925eca196e15e0d45031ccf7a7fba"></a>
typedef Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a118925eca196e15e0d45031ccf7a7fba">Reference</a></td></tr>
<tr class="memdesc:a118925eca196e15e0d45031ccf7a7fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant vector value. <br/></td></tr>
<tr class="separator:a118925eca196e15e0d45031ccf7a7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e341e0a78c819492a673baa652eb0a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e341e0a78c819492a673baa652eb0a9"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a8e341e0a78c819492a673baa652eb0a9">ConstReference</a></td></tr>
<tr class="memdesc:a8e341e0a78c819492a673baa652eb0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant vector value. <br/></td></tr>
<tr class="separator:a8e341e0a78c819492a673baa652eb0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8f5769dae262430d61fdbaec98b9d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb8f5769dae262430d61fdbaec98b9d5"></a>
typedef Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abb8f5769dae262430d61fdbaec98b9d5">Iterator</a></td></tr>
<tr class="memdesc:abb8f5769dae262430d61fdbaec98b9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br/></td></tr>
<tr class="separator:abb8f5769dae262430d61fdbaec98b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5cdc99d6e4a3a812c0373820f46f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c5cdc99d6e4a3a812c0373820f46f63"></a>
typedef const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a></td></tr>
<tr class="memdesc:a3c5cdc99d6e4a3a812c0373820f46f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br/></td></tr>
<tr class="separator:a3c5cdc99d6e4a3a812c0373820f46f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c0a3c516997276df0d0b87ee7876d6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html">CMathTrait</a>&lt; Type &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a53c0a3c516997276df0d0b87ee7876d6">LengthType</a></td></tr>
<tr class="memdesc:a53c0a3c516997276df0d0b87ee7876d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> length return type.  <a href="#a53c0a3c516997276df0d0b87ee7876d6"></a><br/></td></tr>
<tr class="separator:a53c0a3c516997276df0d0b87ee7876d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7ddefcf2554b0bced1ad1b4b53e24"></a>
typedef VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a></td></tr>
<tr class="memdesc:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br/></td></tr>
<tr class="separator:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a42ef785032a297a6bb91a1c0cb096561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a42ef785032a297a6bb91a1c0cb096561">operator~</a> ()</td></tr>
<tr class="memdesc:a42ef785032a297a6bb91a1c0cb096561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a42ef785032a297a6bb91a1c0cb096561"></a><br/></td></tr>
<tr class="separator:a42ef785032a297a6bb91a1c0cb096561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc820e484e827b9c3c4aab65aa19e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#ac3dc820e484e827b9c3c4aab65aa19e2">operator~</a> () const </td></tr>
<tr class="memdesc:ac3dc820e484e827b9c3c4aab65aa19e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#ac3dc820e484e827b9c3c4aab65aa19e2"></a><br/></td></tr>
<tr class="separator:ac3dc820e484e827b9c3c4aab65aa19e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:aa65d9b7a3f55c62bb750e4f9bae36beb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#aa65d9b7a3f55c62bb750e4f9bae36beb">StaticVector</a> ()</td></tr>
<tr class="memdesc:aa65d9b7a3f55c62bb750e4f9bae36beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor for <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>.  <a href="#aa65d9b7a3f55c62bb750e4f9bae36beb"></a><br/></td></tr>
<tr class="separator:aa65d9b7a3f55c62bb750e4f9bae36beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a53b98c9ef96ea4bc6960a46a6bcea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ad7a53b98c9ef96ea4bc6960a46a6bcea">StaticVector</a> (const Type &amp;init)</td></tr>
<tr class="memdesc:ad7a53b98c9ef96ea4bc6960a46a6bcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a homogenous initialization of all elements.  <a href="#ad7a53b98c9ef96ea4bc6960a46a6bcea"></a><br/></td></tr>
<tr class="separator:ad7a53b98c9ef96ea4bc6960a46a6bcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3183c8bda18b9ac19988db1317fb66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a9c3183c8bda18b9ac19988db1317fb66">StaticVector</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;v)</td></tr>
<tr class="memdesc:a9c3183c8bda18b9ac19988db1317fb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor for <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>.  <a href="#a9c3183c8bda18b9ac19988db1317fb66"></a><br/></td></tr>
<tr class="separator:a9c3183c8bda18b9ac19988db1317fb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be3899ee376a41af7af994df820e346"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a6be3899ee376a41af7af994df820e346"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a6be3899ee376a41af7af994df820e346">StaticVector</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Other, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:a6be3899ee376a41af7af994df820e346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor from different <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> instances.  <a href="#a6be3899ee376a41af7af994df820e346"></a><br/></td></tr>
<tr class="separator:a6be3899ee376a41af7af994df820e346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7d826f67b6394e7bec3f40e36b923"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ad4d7d826f67b6394e7bec3f40e36b923"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ad4d7d826f67b6394e7bec3f40e36b923">StaticVector</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ad4d7d826f67b6394e7bec3f40e36b923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor from different vectors.  <a href="#ad4d7d826f67b6394e7bec3f40e36b923"></a><br/></td></tr>
<tr class="separator:ad4d7d826f67b6394e7bec3f40e36b923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1f5382c5aaf4104697a095b3d6c0fc"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:afd1f5382c5aaf4104697a095b3d6c0fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#afd1f5382c5aaf4104697a095b3d6c0fc">StaticVector</a> (const Other(&amp;rhs)[N])</td></tr>
<tr class="memdesc:afd1f5382c5aaf4104697a095b3d6c0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array initialization of all vector elements.  <a href="#afd1f5382c5aaf4104697a095b3d6c0fc"></a><br/></td></tr>
<tr class="separator:afd1f5382c5aaf4104697a095b3d6c0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36a7f7a1dfe8ef462c6ad615c29eebe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ae36a7f7a1dfe8ef462c6ad615c29eebe">StaticVector</a> (const Type &amp;v1, const Type &amp;v2)</td></tr>
<tr class="memdesc:ae36a7f7a1dfe8ef462c6ad615c29eebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for 2-dimensional vectors.  <a href="#ae36a7f7a1dfe8ef462c6ad615c29eebe"></a><br/></td></tr>
<tr class="separator:ae36a7f7a1dfe8ef462c6ad615c29eebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80cc949281f3d338d74740d4737e8e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ad80cc949281f3d338d74740d4737e8e7">StaticVector</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3)</td></tr>
<tr class="memdesc:ad80cc949281f3d338d74740d4737e8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for 3-dimensional vectors.  <a href="#ad80cc949281f3d338d74740d4737e8e7"></a><br/></td></tr>
<tr class="separator:ad80cc949281f3d338d74740d4737e8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d774dbd68182812ae43bd4a33da2bc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a9d774dbd68182812ae43bd4a33da2bc8">StaticVector</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4)</td></tr>
<tr class="memdesc:a9d774dbd68182812ae43bd4a33da2bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for 4-dimensional vectors.  <a href="#a9d774dbd68182812ae43bd4a33da2bc8"></a><br/></td></tr>
<tr class="separator:a9d774dbd68182812ae43bd4a33da2bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028a27b2cb5cee76905eef0ea92a5bfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a028a27b2cb5cee76905eef0ea92a5bfb">StaticVector</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4, const Type &amp;v5)</td></tr>
<tr class="memdesc:a028a27b2cb5cee76905eef0ea92a5bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for 5-dimensional vectors.  <a href="#a028a27b2cb5cee76905eef0ea92a5bfb"></a><br/></td></tr>
<tr class="separator:a028a27b2cb5cee76905eef0ea92a5bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778f9987349e508e06ddf71b8dc4be77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a778f9987349e508e06ddf71b8dc4be77">StaticVector</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4, const Type &amp;v5, const Type &amp;v6)</td></tr>
<tr class="memdesc:a778f9987349e508e06ddf71b8dc4be77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for 6-dimensional vectors.  <a href="#a778f9987349e508e06ddf71b8dc4be77"></a><br/></td></tr>
<tr class="separator:a778f9987349e508e06ddf71b8dc4be77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a1620adfcefea24fd328540514e1c5792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a118925eca196e15e0d45031ccf7a7fba">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a1620adfcefea24fd328540514e1c5792">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a1620adfcefea24fd328540514e1c5792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the vector elements.  <a href="#a1620adfcefea24fd328540514e1c5792"></a><br/></td></tr>
<tr class="separator:a1620adfcefea24fd328540514e1c5792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c337e6ec18332a3b04eb3e3de38d54f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a8e341e0a78c819492a673baa652eb0a9">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a8c337e6ec18332a3b04eb3e3de38d54f">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a8c337e6ec18332a3b04eb3e3de38d54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the vector elements.  <a href="#a8c337e6ec18332a3b04eb3e3de38d54f"></a><br/></td></tr>
<tr class="separator:a8c337e6ec18332a3b04eb3e3de38d54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c40f7c7e552edc9d578c880f3ee81a7"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a7c40f7c7e552edc9d578c880f3ee81a7">data</a> ()</td></tr>
<tr class="memdesc:a7c40f7c7e552edc9d578c880f3ee81a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the vector elements.  <a href="#a7c40f7c7e552edc9d578c880f3ee81a7"></a><br/></td></tr>
<tr class="separator:a7c40f7c7e552edc9d578c880f3ee81a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae390700b24a5fc6e5cd3262560d0f4d6"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ae390700b24a5fc6e5cd3262560d0f4d6">data</a> () const </td></tr>
<tr class="memdesc:ae390700b24a5fc6e5cd3262560d0f4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the vector elements.  <a href="#ae390700b24a5fc6e5cd3262560d0f4d6"></a><br/></td></tr>
<tr class="separator:ae390700b24a5fc6e5cd3262560d0f4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005badc14698992ed6323a79ab0bb982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abb8f5769dae262430d61fdbaec98b9d5">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a005badc14698992ed6323a79ab0bb982">begin</a> ()</td></tr>
<tr class="memdesc:a005badc14698992ed6323a79ab0bb982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the static vector.  <a href="#a005badc14698992ed6323a79ab0bb982"></a><br/></td></tr>
<tr class="separator:a005badc14698992ed6323a79ab0bb982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfc9f65b353d0240dacb8ec0dcaaf14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a1cfc9f65b353d0240dacb8ec0dcaaf14">begin</a> () const </td></tr>
<tr class="memdesc:a1cfc9f65b353d0240dacb8ec0dcaaf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the static vector.  <a href="#a1cfc9f65b353d0240dacb8ec0dcaaf14"></a><br/></td></tr>
<tr class="separator:a1cfc9f65b353d0240dacb8ec0dcaaf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e52924cc66976b0fb6d60687945fc09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a0e52924cc66976b0fb6d60687945fc09">cbegin</a> () const </td></tr>
<tr class="memdesc:a0e52924cc66976b0fb6d60687945fc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the static vector.  <a href="#a0e52924cc66976b0fb6d60687945fc09"></a><br/></td></tr>
<tr class="separator:a0e52924cc66976b0fb6d60687945fc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20eb0b62d5f20b002ab8d62d9ada75d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abb8f5769dae262430d61fdbaec98b9d5">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#af20eb0b62d5f20b002ab8d62d9ada75d">end</a> ()</td></tr>
<tr class="memdesc:af20eb0b62d5f20b002ab8d62d9ada75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the static vector.  <a href="#af20eb0b62d5f20b002ab8d62d9ada75d"></a><br/></td></tr>
<tr class="separator:af20eb0b62d5f20b002ab8d62d9ada75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9079e45e8d78841336ac5b809885c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ab9079e45e8d78841336ac5b809885c96">end</a> () const </td></tr>
<tr class="memdesc:ab9079e45e8d78841336ac5b809885c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the static vector.  <a href="#ab9079e45e8d78841336ac5b809885c96"></a><br/></td></tr>
<tr class="separator:ab9079e45e8d78841336ac5b809885c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e60fbc298178f0baec2ccd28b38898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a77e60fbc298178f0baec2ccd28b38898">cend</a> () const </td></tr>
<tr class="memdesc:a77e60fbc298178f0baec2ccd28b38898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the static vector.  <a href="#a77e60fbc298178f0baec2ccd28b38898"></a><br/></td></tr>
<tr class="separator:a77e60fbc298178f0baec2ccd28b38898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a81b401cf3e38868ed545209e81798028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a81b401cf3e38868ed545209e81798028">operator=</a> (Type rhs)</td></tr>
<tr class="memdesc:a81b401cf3e38868ed545209e81798028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all vector elements.  <a href="#a81b401cf3e38868ed545209e81798028"></a><br/></td></tr>
<tr class="separator:a81b401cf3e38868ed545209e81798028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd02a3d45dc34df5c81d26326f3122d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a1dd02a3d45dc34df5c81d26326f3122d">operator=</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1dd02a3d45dc34df5c81d26326f3122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>.  <a href="#a1dd02a3d45dc34df5c81d26326f3122d"></a><br/></td></tr>
<tr class="separator:a1dd02a3d45dc34df5c81d26326f3122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8c8ecf9028fe0a061f6f7121e49c69"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:afe8c8ecf9028fe0a061f6f7121e49c69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#afe8c8ecf9028fe0a061f6f7121e49c69">operator=</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Other, N, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afe8c8ecf9028fe0a061f6f7121e49c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> instances.  <a href="#afe8c8ecf9028fe0a061f6f7121e49c69"></a><br/></td></tr>
<tr class="separator:afe8c8ecf9028fe0a061f6f7121e49c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3a2406b0492aa53ca59b544ccf4639"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a7e3a2406b0492aa53ca59b544ccf4639"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a7e3a2406b0492aa53ca59b544ccf4639">operator=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7e3a2406b0492aa53ca59b544ccf4639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different vectors.  <a href="#a7e3a2406b0492aa53ca59b544ccf4639"></a><br/></td></tr>
<tr class="separator:a7e3a2406b0492aa53ca59b544ccf4639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31106419a8f1494a88aa2c1f69437cc5"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a31106419a8f1494a88aa2c1f69437cc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a31106419a8f1494a88aa2c1f69437cc5">operator=</a> (const Other(&amp;rhs)[N])</td></tr>
<tr class="memdesc:a31106419a8f1494a88aa2c1f69437cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array assignment to all vector elements.  <a href="#a31106419a8f1494a88aa2c1f69437cc5"></a><br/></td></tr>
<tr class="separator:a31106419a8f1494a88aa2c1f69437cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb7f446ca36e3e7d3bcfa1964607eb4"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aeeb7f446ca36e3e7d3bcfa1964607eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#aeeb7f446ca36e3e7d3bcfa1964607eb4">operator+=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aeeb7f446ca36e3e7d3bcfa1964607eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_37.png"/>).  <a href="#aeeb7f446ca36e3e7d3bcfa1964607eb4"></a><br/></td></tr>
<tr class="separator:aeeb7f446ca36e3e7d3bcfa1964607eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1002032cfe992e69a794503cbc9df7"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a9f1002032cfe992e69a794503cbc9df7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a9f1002032cfe992e69a794503cbc9df7">operator-=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9f1002032cfe992e69a794503cbc9df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_38.png"/>).  <a href="#a9f1002032cfe992e69a794503cbc9df7"></a><br/></td></tr>
<tr class="separator:a9f1002032cfe992e69a794503cbc9df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e06998a0fc95736d9cd736fa2864c8a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a2e06998a0fc95736d9cd736fa2864c8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a2e06998a0fc95736d9cd736fa2864c8a">operator*=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2e06998a0fc95736d9cd736fa2864c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_39.png"/>).  <a href="#a2e06998a0fc95736d9cd736fa2864c8a"></a><br/></td></tr>
<tr class="separator:a2e06998a0fc95736d9cd736fa2864c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027bd93a8b29f4d8f85331fb02529f66"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a027bd93a8b29f4d8f85331fb02529f66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;<br class="typebreak"/>
, <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a027bd93a8b29f4d8f85331fb02529f66">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a027bd93a8b29f4d8f85331fb02529f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_40.png"/>).  <a href="#a027bd93a8b29f4d8f85331fb02529f66"></a><br/></td></tr>
<tr class="separator:a027bd93a8b29f4d8f85331fb02529f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8e136fc33fc1b438da411d72cc802f"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a4c8e136fc33fc1b438da411d72cc802f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;<br class="typebreak"/>
, <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a4c8e136fc33fc1b438da411d72cc802f">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:a4c8e136fc33fc1b438da411d72cc802f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_41.png"/>).  <a href="#a4c8e136fc33fc1b438da411d72cc802f"></a><br/></td></tr>
<tr class="separator:a4c8e136fc33fc1b438da411d72cc802f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a0701344290d5743f0ed6e60fb1d05d3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a0701344290d5743f0ed6e60fb1d05d3c">size</a> () const </td></tr>
<tr class="memdesc:a0701344290d5743f0ed6e60fb1d05d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the vector.  <a href="#a0701344290d5743f0ed6e60fb1d05d3c"></a><br/></td></tr>
<tr class="separator:a0701344290d5743f0ed6e60fb1d05d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad703039dde52ec7593ee19cbd4b7c03f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ad703039dde52ec7593ee19cbd4b7c03f">nonZeros</a> () const </td></tr>
<tr class="memdesc:ad703039dde52ec7593ee19cbd4b7c03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the vector.  <a href="#ad703039dde52ec7593ee19cbd4b7c03f"></a><br/></td></tr>
<tr class="separator:ad703039dde52ec7593ee19cbd4b7c03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5840585ebc4bc0bcf5097201e6136cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a5840585ebc4bc0bcf5097201e6136cb4">reset</a> ()</td></tr>
<tr class="memdesc:a5840585ebc4bc0bcf5097201e6136cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#a5840585ebc4bc0bcf5097201e6136cb4"></a><br/></td></tr>
<tr class="separator:a5840585ebc4bc0bcf5097201e6136cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a31926edf92996ee4aa536fec21ac18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a53c0a3c516997276df0d0b87ee7876d6">LengthType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a4a31926edf92996ee4aa536fec21ac18">length</a> () const </td></tr>
<tr class="memdesc:a4a31926edf92996ee4aa536fec21ac18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_43.png"/>.  <a href="#a4a31926edf92996ee4aa536fec21ac18"></a><br/></td></tr>
<tr class="separator:a4a31926edf92996ee4aa536fec21ac18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff26668f5112b14a556a5200b0ee71e4"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#aff26668f5112b14a556a5200b0ee71e4">sqrLength</a> () const </td></tr>
<tr class="memdesc:aff26668f5112b14a556a5200b0ee71e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_44.png"/>.  <a href="#aff26668f5112b14a556a5200b0ee71e4"></a><br/></td></tr>
<tr class="separator:aff26668f5112b14a556a5200b0ee71e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7437e6738fe0fb37b40808467bec35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#adb7437e6738fe0fb37b40808467bec35">normalize</a> ()</td></tr>
<tr class="memdesc:adb7437e6738fe0fb37b40808467bec35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalization of the vector ( <img class="formulaInl" alt="$|\vec{a}|=1$" src="../../form_45.png"/>).  <a href="#adb7437e6738fe0fb37b40808467bec35"></a><br/></td></tr>
<tr class="separator:adb7437e6738fe0fb37b40808467bec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9942457e0bf6a71c2c2f55c52a4e3578"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a9942457e0bf6a71c2c2f55c52a4e3578">getNormalized</a> () const </td></tr>
<tr class="memdesc:a9942457e0bf6a71c2c2f55c52a4e3578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the normalized vector ( <img class="formulaInl" alt="$|\vec{a}|=1$" src="../../form_45.png"/>).  <a href="#a9942457e0bf6a71c2c2f55c52a4e3578"></a><br/></td></tr>
<tr class="separator:a9942457e0bf6a71c2c2f55c52a4e3578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801c7b1287ad2a2ca28df21265e9f279"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a801c7b1287ad2a2ca28df21265e9f279"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a801c7b1287ad2a2ca28df21265e9f279">scale</a> (Other scalar)</td></tr>
<tr class="memdesc:a801c7b1287ad2a2ca28df21265e9f279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the vector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_40.png"/>).  <a href="#a801c7b1287ad2a2ca28df21265e9f279"></a><br/></td></tr>
<tr class="separator:a801c7b1287ad2a2ca28df21265e9f279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab632ee6c25ab0d52cdb90b874cf05a10"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ab632ee6c25ab0d52cdb90b874cf05a10">min</a> () const </td></tr>
<tr class="memdesc:ab632ee6c25ab0d52cdb90b874cf05a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the vector.  <a href="#ab632ee6c25ab0d52cdb90b874cf05a10"></a><br/></td></tr>
<tr class="separator:ab632ee6c25ab0d52cdb90b874cf05a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa3da09368068164ba330ff14a985af"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a1aa3da09368068164ba330ff14a985af">max</a> () const </td></tr>
<tr class="memdesc:a1aa3da09368068164ba330ff14a985af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the vector.  <a href="#a1aa3da09368068164ba330ff14a985af"></a><br/></td></tr>
<tr class="separator:a1aa3da09368068164ba330ff14a985af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62459700df689249bc5ac21d312dacd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ac62459700df689249bc5ac21d312dacd">swap</a> (<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> &amp;v)</td></tr>
<tr class="memdesc:ac62459700df689249bc5ac21d312dacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two static vectors.  <a href="#ac62459700df689249bc5ac21d312dacd"></a><br/></td></tr>
<tr class="separator:ac62459700df689249bc5ac21d312dacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:aee4f88b8c117b8ca3e8a867d5e7a9cbd"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:aee4f88b8c117b8ca3e8a867d5e7a9cbd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#aee4f88b8c117b8ca3e8a867d5e7a9cbd">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:aee4f88b8c117b8ca3e8a867d5e7a9cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is aliased with the given address <em>alias</em>.  <a href="#aee4f88b8c117b8ca3e8a867d5e7a9cbd"></a><br/></td></tr>
<tr class="separator:aee4f88b8c117b8ca3e8a867d5e7a9cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669854494f0593c9bcabc93ee1e1b9b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abde048ffa6c26c7b74138d96b7397748">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a669854494f0593c9bcabc93ee1e1b9b3">get</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a669854494f0593c9bcabc93ee1e1b9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the intrinsic elements of the vector.  <a href="#a669854494f0593c9bcabc93ee1e1b9b3"></a><br/></td></tr>
<tr class="separator:a669854494f0593c9bcabc93ee1e1b9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e14a2fce2cec0d6d914bb482faa5d2"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a77e14a2fce2cec0d6d914bb482faa5d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAssign<br class="typebreak"/>
&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a77e14a2fce2cec0d6d914bb482faa5d2">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a77e14a2fce2cec0d6d914bb482faa5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense vector.  <a href="#a77e14a2fce2cec0d6d914bb482faa5d2"></a><br/></td></tr>
<tr class="separator:a77e14a2fce2cec0d6d914bb482faa5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac668ca560cf111729c843ad6d4deb29"><td class="memTemplParams" colspan="2"><a class="anchor" id="aac668ca560cf111729c843ad6d4deb29"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aac668ca560cf111729c843ad6d4deb29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAssign&lt; VT &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:aac668ca560cf111729c843ad6d4deb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62920af1e838b8194a3ee9309ff2330c"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a62920af1e838b8194a3ee9309ff2330c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a62920af1e838b8194a3ee9309ff2330c">assign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a62920af1e838b8194a3ee9309ff2330c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a sparse vector.  <a href="#a62920af1e838b8194a3ee9309ff2330c"></a><br/></td></tr>
<tr class="separator:a62920af1e838b8194a3ee9309ff2330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a96c280e6ec886a087e3e932f483f40"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a7a96c280e6ec886a087e3e932f483f40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAddAssign<br class="typebreak"/>
&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a7a96c280e6ec886a087e3e932f483f40">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7a96c280e6ec886a087e3e932f483f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a dense vector.  <a href="#a7a96c280e6ec886a087e3e932f483f40"></a><br/></td></tr>
<tr class="separator:a7a96c280e6ec886a087e3e932f483f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcc0c16f5baa90ed1e494564a11a3fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7bcc0c16f5baa90ed1e494564a11a3fc"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a7bcc0c16f5baa90ed1e494564a11a3fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAddAssign<br class="typebreak"/>
&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a7bcc0c16f5baa90ed1e494564a11a3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9f32c448d4f3b4e3ff203e85a2193a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:abb9f32c448d4f3b4e3ff203e85a2193a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abb9f32c448d4f3b4e3ff203e85a2193a">addAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abb9f32c448d4f3b4e3ff203e85a2193a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a sparse vector.  <a href="#abb9f32c448d4f3b4e3ff203e85a2193a"></a><br/></td></tr>
<tr class="separator:abb9f32c448d4f3b4e3ff203e85a2193a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2522e32b4514910554ebcb25fbdc45c"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:af2522e32b4514910554ebcb25fbdc45c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedSubAssign<br class="typebreak"/>
&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#af2522e32b4514910554ebcb25fbdc45c">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af2522e32b4514910554ebcb25fbdc45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense vector.  <a href="#af2522e32b4514910554ebcb25fbdc45c"></a><br/></td></tr>
<tr class="separator:af2522e32b4514910554ebcb25fbdc45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b37ab3758dcc1019e71397807881716"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b37ab3758dcc1019e71397807881716"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a9b37ab3758dcc1019e71397807881716"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedSubAssign<br class="typebreak"/>
&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a9b37ab3758dcc1019e71397807881716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fd792e4848cea8563554e429e17ce1"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ac7fd792e4848cea8563554e429e17ce1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#ac7fd792e4848cea8563554e429e17ce1">subAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac7fd792e4848cea8563554e429e17ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a sparse vector.  <a href="#ac7fd792e4848cea8563554e429e17ce1"></a><br/></td></tr>
<tr class="separator:ac7fd792e4848cea8563554e429e17ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c713fc7b62e4f4b2084bdad6ce89c3"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a57c713fc7b62e4f4b2084bdad6ce89c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; VectorizedMultAssign&lt; VT &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a57c713fc7b62e4f4b2084bdad6ce89c3">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a57c713fc7b62e4f4b2084bdad6ce89c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a dense vector.  <a href="#a57c713fc7b62e4f4b2084bdad6ce89c3"></a><br/></td></tr>
<tr class="separator:a57c713fc7b62e4f4b2084bdad6ce89c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae262d977a60829d5805bd5f01da26f16"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae262d977a60829d5805bd5f01da26f16"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ae262d977a60829d5805bd5f01da26f16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedMultAssign<br class="typebreak"/>
&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:ae262d977a60829d5805bd5f01da26f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cca6fc87bdaf60292609c7334ea1e86"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a0cca6fc87bdaf60292609c7334ea1e86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a0cca6fc87bdaf60292609c7334ea1e86">multAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0cca6fc87bdaf60292609c7334ea1e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a sparse vector.  <a href="#a0cca6fc87bdaf60292609c7334ea1e86"></a><br/></td></tr>
<tr class="separator:a0cca6fc87bdaf60292609c7334ea1e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a0d0182838986486b2a2c33eb6a9eed32"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NN</b> = N + ( IT::size - ( N % IT::size ) ) % IT::size
 }</td></tr>
<tr class="memdesc:a0d0182838986486b2a2c33eb6a9eed32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment adjustment. <br/></td></tr>
<tr class="separator:a0d0182838986486b2a2c33eb6a9eed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78446d18ce468dbf66afdbcb19e7285b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78446d18ce468dbf66afdbcb19e7285b"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a78446d18ce468dbf66afdbcb19e7285b">IT</a></td></tr>
<tr class="memdesc:a78446d18ce468dbf66afdbcb19e7285b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic trait for the vector element type. <br/></td></tr>
<tr class="separator:a78446d18ce468dbf66afdbcb19e7285b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a594609672c675b6998d279c35b39608b"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a594609672c675b6998d279c35b39608b">v_</a> [NN]</td></tr>
<tr class="memdesc:a594609672c675b6998d279c35b39608b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statically allocated vector elements.  <a href="#a594609672c675b6998d279c35b39608b"></a><br/></td></tr>
<tr class="separator:a594609672c675b6998d279c35b39608b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt;<br/>
class blaze::StaticVector&lt; Type, N, TF &gt;</h3>

<p>Efficient implementation of a fixed-sized vector.</p>
<p>The <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> class template is the representation of a fixed-size vector with statically allocated elements of arbitrary type. The type of the elements, the number of elements and the transpose flag of the vector can be specified via the three template parameters: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Type, <span class="keywordtype">size_t</span> N, <span class="keywordtype">bool</span> TF &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html#aa65d9b7a3f55c62bb750e4f9bae36beb" title="The default constructor for StaticVector.">StaticVector</a>;</div>
</div><!-- fragment --><ul>
<li>Type: specifies the type of the vector elements. <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> can be used with any non-cv-qualified, non-reference, non-pointer element type.</li>
<li>N : specifies the total number of vector elements. It is expected that <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> is only used for tiny and small vectors.</li>
<li>TF : specifies whether the vector is a row vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a></em>) or a column vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a></em>). The default value is <em><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a></em>.</li>
</ul>
<p>These contiguously stored elements can be direclty accessed with the subscript operator. The numbering of the vector elements is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{4}{c}} 0 &amp; 1 &amp; \cdots &amp; N-1 \\ \end{array}\right)\]" src="../../form_80.png"/>
</p>
<p>The use of <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> is very natural and intuitive. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combinations of dense and sparse vectors with fitting element types. The following example gives an impression of the use of a 2-dimensional <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix</a>;</div>
<div class="line"></div>
<div class="line">StaticVector&lt;double,2UL&gt; a,  <span class="comment">// Default initialized 2D vectors</span></div>
<div class="line">a[0] = 1.0;                  <span class="comment">// Initialization of the first element</span></div>
<div class="line">a[1] = 2.0;                  <span class="comment">// Initialization of the second element</span></div>
<div class="line"></div>
<div class="line">StaticVector&lt;double,2UL&gt; b( 3.0, 2.0 );  <span class="comment">// Directly initialized 2D vector</span></div>
<div class="line">CompressedVector&lt;float&gt;  c( 4.0F );      <span class="comment">// Empty single precision vector</span></div>
<div class="line">StaticVector&lt;double,2UL&gt; d;              <span class="comment">// Default constructed static vector</span></div>
<div class="line">StaticMatrix&lt;double,2UL,2UL&gt; A;          <span class="comment">// Default constructed static row-major matrix</span></div>
<div class="line"></div>
<div class="line">d = a + b;  <span class="comment">// Vector addition between vectors of equal element type</span></div>
<div class="line">d = a - c;  <span class="comment">// Vector subtraction between vector of different element type</span></div>
<div class="line">d = a * b;  <span class="comment">// Component-wise vector multiplication</span></div>
<div class="line"></div>
<div class="line">a *= 2.0;      <span class="comment">// In-place scaling of vector</span></div>
<div class="line">d  = a * 2.0;  <span class="comment">// Scaling of vector a</span></div>
<div class="line">d  = 2.0 * a;  <span class="comment">// Scaling of vector a</span></div>
<div class="line"></div>
<div class="line">d += a - b;  <span class="comment">// Addition assignment</span></div>
<div class="line">d -= a + c;  <span class="comment">// Subtraction assignment</span></div>
<div class="line">d *= a * b;  <span class="comment">// Multiplication assignment</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> scalar = <a class="code" href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72" title="Calculation of the transpose of the given dense matrix.">trans</a>( a ) * b;  <span class="comment">// Scalar/dot/inner product between two vectors</span></div>
<div class="line"></div>
<div class="line">A = a * <a class="code" href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72" title="Calculation of the transpose of the given dense matrix.">trans</a>( b );  <span class="comment">// Outer product between two vectors</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a53c0a3c516997276df0d0b87ee7876d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html">CMathTrait</a>&lt;Type&gt;::Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a53c0a3c516997276df0d0b87ee7876d6">LengthType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> length return type. </p>
<p>Return type of the <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a4a31926edf92996ee4aa536fec21ac18" title="Calculation of the vector length .">StaticVector&lt;Type,N,TF&gt;::length</a> function. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ae65156f33c23ac6219340f37e926f319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for intrinsic optimization. </p>
<p>The <em>vectorizable</em> compilation flag indicates whether expressions the vector is involved in can be optimized via intrinsics. In case the element type of the vector is a vectorizable data type, the <em>vectorizable</em> compilation flag is set to <em>true</em>, otherwise it is set to <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a6ea21dd5290583b74b95602d678cf2cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for the detection of aliasing effects. </p>
<p>This compilation switch indicates whether this type potentially causes compuation errors due to aliasing effects. In case the type can cause aliasing effects, the <em>canAlias</em> switch is set to <em>true</em>, otherwise it is set to <em>false</em>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa65d9b7a3f55c62bb750e4f9bae36beb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor for <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>. </p>
<p>All vector elements are initialized to the default value (i.e. 0 for integral data types). </p>

</div>
</div>
<a class="anchor" id="ad7a53b98c9ef96ea4bc6960a46a6bcea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a homogenous initialization of all elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initial value for all vector elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c3183c8bda18b9ac19988db1317fb66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor for <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<p>The copy constructor is explicitly defined in order to enable/facilitate NRV optimization. </p>

</div>
</div>
<a class="anchor" id="a6be3899ee376a41af7af994df820e346"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Other, N, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion constructor from different <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4d7d826f67b6394e7bec3f40e36b923"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion constructor from different vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of static vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes the static vector from the given vector. In case the size of the given vector does not match the size of the static vector (i.e. is not N), a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="afd1f5382c5aaf4104697a095b3d6c0fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const Other(&amp;)&#160;</td>
          <td class="paramname"><em>rhs</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array initialization of all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>N-dimensional array for the initialization.</td></tr>
  </table>
  </dd>
</dl>
<p>This assignment operator offers the option to directly initialize the elements of the vector:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> init[2] = { 1.0, 2.0 };</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;double,2&gt;</a> v( init );</div>
</div><!-- fragment --><p>The vector is initialized with the given values. Missing values are initialized with zero. </p>

</div>
</div>
<a class="anchor" id="ae36a7f7a1dfe8ef462c6ad615c29eebe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for 2-dimensional vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first vector element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second vector element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to create 2-dimensional vectors with specific elements:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;int,2&gt;</a> v( 1, 2 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad80cc949281f3d338d74740d4737e8e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for 3-dimensional vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first vector element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second vector element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third vector element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to create 3-dimensional vectors with specific elements:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;int,3&gt;</a> v( 1, 2, 3 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9d774dbd68182812ae43bd4a33da2bc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for 4-dimensional vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first vector element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second vector element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third vector element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth vector element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to create 4-dimensional vectors with specific elements:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;int,4&gt;</a> v( 1, 2, 3, 4 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a028a27b2cb5cee76905eef0ea92a5bfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for 5-dimensional vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first vector element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second vector element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third vector element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth vector element. </td></tr>
    <tr><td class="paramname">v5</td><td>The initializer for the fifth vector element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to create 5-dimensional vectors with specific elements:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;int,5&gt;</a> v( 1, 2, 3, 4, 5 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a778f9987349e508e06ddf71b8dc4be77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for 6-dimensional vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first vector element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second vector element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third vector element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth vector element. </td></tr>
    <tr><td class="paramname">v5</td><td>The initializer for the fifth vector element. </td></tr>
    <tr><td class="paramname">v6</td><td>The initializer for the sixth vector element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to create 6-dimensional vectors with specific elements:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;int,6&gt;</a> v( 1, 2, 3, 4, 5, 6 );</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7a96c280e6ec886a087e3e932f483f40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT &gt; &gt;::Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a dense vector. </p>
<p>Intrinsic optimized implementation of the addition assignment of a dense vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="abb9f32c448d4f3b4e3ff203e85a2193a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a77e14a2fce2cec0d6d914bb482faa5d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT &gt; &gt;::Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense vector. </p>
<p>Intrinsic optimized implementation of the assignment of a dense vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a62920af1e838b8194a3ee9309ff2330c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a005badc14698992ed6323a79ab0bb982"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abb8f5769dae262430d61fdbaec98b9d5">Iterator</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the static vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the static vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cfc9f65b353d0240dacb8ec0dcaaf14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the static vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the static vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e52924cc66976b0fb6d60687945fc09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the static vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the static vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a77e60fbc298178f0baec2ccd28b38898"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the static vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the static vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c40f7c7e552edc9d578c880f3ee81a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type * <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage. </dd></dl>

</div>
</div>
<a class="anchor" id="ae390700b24a5fc6e5cd3262560d0f4d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type * <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage. </dd></dl>

</div>
</div>
<a class="anchor" id="af20eb0b62d5f20b002ab8d62d9ada75d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abb8f5769dae262430d61fdbaec98b9d5">Iterator</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the static vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the static vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9079e45e8d78841336ac5b809885c96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a3c5cdc99d6e4a3a812c0373820f46f63">ConstIterator</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the static vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the static vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a669854494f0593c9bcabc93ee1e1b9b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#abde048ffa6c26c7b74138d96b7397748">IntrinsicType</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the intrinsic elements of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_24.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed values.</dd></dl>
<p>This function offers a direct access to the intrinsic elements of the vector. It must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a9942457e0bf6a71c2c2f55c52a4e3578"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::getNormalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the normalized vector ( <img class="formulaInl" alt="$|\vec{a}|=1$" src="../../form_45.png"/>). </p>
<dl class="section return"><dt>Returns</dt><dd>The normalized vector.</dd></dl>
<p>The function returns the normalized vector. This operation is only defined for floating point vectors. The attempt to use this function for an integral vector results in a compile time error. </p>

</div>
</div>
<a class="anchor" id="aee4f88b8c117b8ca3e8a867d5e7a9cbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this vector, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a31926edf92996ee4aa536fec21ac18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a53c0a3c516997276df0d0b87ee7876d6">LengthType</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_43.png"/>. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of the vector.</dd></dl>
<p>This function calculates the actual length of the vector. The return type of the <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a4a31926edf92996ee4aa536fec21ac18" title="Calculation of the vector length .">length()</a> function depends on the actual type of the vector instance:</p>
<table  border="0" cellspacing="0" cellpadding="1">
<tr>
<td width="250px"><b>Type</b>  </td><td width="100px"><b>LengthType</b>   </td></tr>
<tr>
<td>float </td><td>float  </td></tr>
<tr>
<td>integral data types and double </td><td>double  </td></tr>
<tr>
<td>long double </td><td>long double  </td></tr>
</table>
<p><b>Note:</b> This operation is only defined for built-in data types. In case <em>Type</em> is a user defined data type the attempt to use the <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a4a31926edf92996ee4aa536fec21ac18" title="Calculation of the vector length .">length()</a> function results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="a1aa3da09368068164ba330ff14a985af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The largest vector element. </dd></dl>

</div>
</div>
<a class="anchor" id="ab632ee6c25ab0d52cdb90b874cf05a10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The smallest vector element. </dd></dl>

</div>
</div>
<a class="anchor" id="a57c713fc7b62e4f4b2084bdad6ce89c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT &gt; &gt;::Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a dense vector. </p>
<p>Intrinsic optimized implementation of the multiplication assignment of a dense vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a0cca6fc87bdaf60292609c7334ea1e86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ad703039dde52ec7593ee19cbd4b7c03f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the vector.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current size of the vector. </p>

</div>
</div>
<a class="anchor" id="adb7437e6738fe0fb37b40808467bec35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalization of the vector ( <img class="formulaInl" alt="$|\vec{a}|=1$" src="../../form_45.png"/>). </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector.</dd></dl>
<p>Normalization of the vector to a length of 1. This operation is only defined for floating point vectors. The attempt to use this function for an integral vector results in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a2e06998a0fc95736d9cd736fa2864c8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_39.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be multiplied with the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a027bd93a8b29f4d8f85331fb02529f66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &gt;::Type &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_40.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aeeb7f446ca36e3e7d3bcfa1964607eb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_37.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be added to the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a9f1002032cfe992e69a794503cbc9df7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_38.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a4c8e136fc33fc1b438da411d72cc802f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &gt;::Type &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_41.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector.</dd></dl>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="a81b401cf3e38868ed545209e81798028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Scalar value to be assigned to all vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dd02a3d45dc34df5c81d26326f3122d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector.</dd></dl>
<p>Explicit definition of a copy assignment operator for performance reasons. </p>

</div>
</div>
<a class="anchor" id="afe8c8ecf9028fe0a061f6f7121e49c69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Other, N, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e3a2406b0492aa53ca59b544ccf4639"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to static vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes the vector as a copy of the given vector. In case the size of the given vector is not N, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a31106419a8f1494a88aa2c1f69437cc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Other(&amp;)&#160;</td>
          <td class="paramname"><em>rhs</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array assignment to all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>N-dimensional array for the assignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector.</dd></dl>
<p>This assignment operator offers the option to directly set all elements of the vector:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> init[2] = { 1.0, 2.0 };</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;double,2&gt;</a> v;</div>
<div class="line">v = init;</div>
</div><!-- fragment --><p>The vector is initialized with the given values. Missing values are initialized with zero. </p>

</div>
</div>
<a class="anchor" id="a1620adfcefea24fd328540514e1c5792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a118925eca196e15e0d45031ccf7a7fba">Reference</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_24.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value.</dd></dl>
<p>In case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated.  The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation.">BLAZE_USER_ASSERT()</a> is active, this operator performs an index check. </p>

</div>
</div>
<a class="anchor" id="a8c337e6ec18332a3b04eb3e3de38d54f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a8e341e0a78c819492a673baa652eb0a9">ConstReference</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_24.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference-to-const to the accessed value.</dd></dl>
<p>In case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated.  The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation.">BLAZE_USER_ASSERT()</a> is active, this operator performs an index check. </p>

</div>
</div>
<a class="anchor" id="a42ef785032a297a6bb91a1c0cb096561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3dc820e484e827b9c3c4aab65aa19e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a5840585ebc4bc0bcf5097201e6136cb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a801c7b1287ad2a2ca28df21265e9f279"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the vector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_40.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the vector scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a0701344290d5743f0ed6e60fb1d05d3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aff26668f5112b14a556a5200b0ee71e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::sqrLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_44.png"/>. </p>
<dl class="section return"><dt>Returns</dt><dd>The square length of the vector.</dd></dl>
<p>This function calculates the actual square length of the vector.</p>
<p><b>Note:</b> This operation is only defined for built-in data types. In case <em>Type</em> is a user defined data type the attempt to use the <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html#a4a31926edf92996ee4aa536fec21ac18" title="Calculation of the vector length .">length()</a> function results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="af2522e32b4514910554ebcb25fbdc45c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT &gt; &gt;::Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense vector. </p>
<p>Intrinsic optimized implementation of the subtraction assignment of a dense vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ac7fd792e4848cea8563554e429e17ce1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ac62459700df689249bc5ac21d312dacd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two static vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a594609672c675b6998d279c35b39608b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector</a>&lt; Type, N, TF &gt;::v_[NN]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The statically allocated vector elements. </p>
<p>Access to the vector values is gained via the subscript operator. The order of the elements is </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{4}{c}} 0 &amp; 1 &amp; \cdots &amp; N-1 \\ \end{array}\right)\]" src="../../form_80.png"/>
</p>
 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/dense/<a class="el" href="../../db/d87/dense_2StaticVector_8h_source.html">StaticVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:41 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
