<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>blaze::StaticMatrix&lt; Type, M, N, SO &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../dd/d99/classblaze_1_1StaticMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::StaticMatrix&lt; Type, M, N, SO &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../d5/def/group__static__matrix.html">StaticMatrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Efficient implementation of a fixed-sized matrix.The <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> class template is the representation of a fixed-size matrix with statically allocated elements of arbitrary type. The type of the elements, the number of rows and columns and the storage order of the matrix can be specified via the four template parameters:  
 <a href="../../d3/dd3/classblaze_1_1StaticMatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d6/dbe/dense_2StaticMatrix_8h_source.html">StaticMatrix.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">blaze::DenseMatrix&lt; StaticMatrix&lt; Type, M, N, SO &gt;, SO &gt;</a>, and <a class="el" href="../../d1/d85/classblaze_1_1AlignedStorage.html">blaze::AlignedStorage&lt; Type &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5b340118207a4957a25f653e0197084e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>vectorizable</b> = IsVectorizable&lt;Type&gt;::value
 }</td></tr>
<tr class="memdesc:a5b340118207a4957a25f653e0197084e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for intrinsic optimization.  <a href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a5b340118207a4957a25f653e0197084e">More...</a><br/></td></tr>
<tr class="separator:a5b340118207a4957a25f653e0197084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce1a5a7cae4e25caf63a31f3f96b48"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>canAlias</b> = 0
 }</td></tr>
<tr class="memdesc:a07ce1a5a7cae4e25caf63a31f3f96b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for the detection of aliasing effects.  <a href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a07ce1a5a7cae4e25caf63a31f3f96b48">More...</a><br/></td></tr>
<tr class="separator:a07ce1a5a7cae4e25caf63a31f3f96b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddf3c308a0f52e5ea94e2751dee8229"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeddf3c308a0f52e5ea94e2751dee8229"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, <br class="typebreak"/>
N, SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aeddf3c308a0f52e5ea94e2751dee8229">This</a></td></tr>
<tr class="memdesc:aeddf3c308a0f52e5ea94e2751dee8229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> instance. <br/></td></tr>
<tr class="separator:aeddf3c308a0f52e5ea94e2751dee8229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add05c9228d9129efdf6f05026bbe65a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add05c9228d9129efdf6f05026bbe65a5"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aeddf3c308a0f52e5ea94e2751dee8229">This</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#add05c9228d9129efdf6f05026bbe65a5">ResultType</a></td></tr>
<tr class="memdesc:add05c9228d9129efdf6f05026bbe65a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br/></td></tr>
<tr class="separator:add05c9228d9129efdf6f05026bbe65a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1c472c46a524d69032cb809bfa98f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e1c472c46a524d69032cb809bfa98f4"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, <br class="typebreak"/>
N,!SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a9e1c472c46a524d69032cb809bfa98f4">OppositeType</a></td></tr>
<tr class="memdesc:a9e1c472c46a524d69032cb809bfa98f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type with opposite storage order for expression template evaluations. <br/></td></tr>
<tr class="separator:a9e1c472c46a524d69032cb809bfa98f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557878d7c913755e7730238cb75bd11c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a557878d7c913755e7730238cb75bd11c"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, N, <br class="typebreak"/>
M,!SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a557878d7c913755e7730238cb75bd11c">TransposeType</a></td></tr>
<tr class="memdesc:a557878d7c913755e7730238cb75bd11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br/></td></tr>
<tr class="separator:a557878d7c913755e7730238cb75bd11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee6f027c59d0d9003b8fb0b723deca3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ee6f027c59d0d9003b8fb0b723deca3"></a>
typedef Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a6ee6f027c59d0d9003b8fb0b723deca3">ElementType</a></td></tr>
<tr class="memdesc:a6ee6f027c59d0d9003b8fb0b723deca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix elements. <br/></td></tr>
<tr class="separator:a6ee6f027c59d0d9003b8fb0b723deca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9f947227ece17d1b296e5f911c31ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b9f947227ece17d1b296e5f911c31ab"></a>
typedef IT::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a4b9f947227ece17d1b296e5f911c31ab">IntrinsicType</a></td></tr>
<tr class="memdesc:a4b9f947227ece17d1b296e5f911c31ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type of the matrix elements. <br/></td></tr>
<tr class="separator:a4b9f947227ece17d1b296e5f911c31ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a7f8c0a86f9f3c8da558b220f10632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a7f8c0a86f9f3c8da558b220f10632"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a97a7f8c0a86f9f3c8da558b220f10632">ReturnType</a></td></tr>
<tr class="memdesc:a97a7f8c0a86f9f3c8da558b220f10632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br/></td></tr>
<tr class="separator:a97a7f8c0a86f9f3c8da558b220f10632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9c39e99d0e48dc30ad5afef0b9eb93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad9c39e99d0e48dc30ad5afef0b9eb93"></a>
typedef const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aeddf3c308a0f52e5ea94e2751dee8229">This</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aad9c39e99d0e48dc30ad5afef0b9eb93">CompositeType</a></td></tr>
<tr class="memdesc:aad9c39e99d0e48dc30ad5afef0b9eb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br/></td></tr>
<tr class="separator:aad9c39e99d0e48dc30ad5afef0b9eb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72435ecfb9531951ca0e74769ce471c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad72435ecfb9531951ca0e74769ce471c"></a>
typedef Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad72435ecfb9531951ca0e74769ce471c">Reference</a></td></tr>
<tr class="memdesc:ad72435ecfb9531951ca0e74769ce471c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant matrix value. <br/></td></tr>
<tr class="separator:ad72435ecfb9531951ca0e74769ce471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f56a0ca64211865e0ff3e4d493c2ccc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f56a0ca64211865e0ff3e4d493c2ccc"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a8f56a0ca64211865e0ff3e4d493c2ccc">ConstReference</a></td></tr>
<tr class="memdesc:a8f56a0ca64211865e0ff3e4d493c2ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant matrix value. <br/></td></tr>
<tr class="separator:a8f56a0ca64211865e0ff3e4d493c2ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ff977bc2159fdb5008a5f2a7df7890"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91ff977bc2159fdb5008a5f2a7df7890"></a>
typedef Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a91ff977bc2159fdb5008a5f2a7df7890">Iterator</a></td></tr>
<tr class="memdesc:a91ff977bc2159fdb5008a5f2a7df7890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br/></td></tr>
<tr class="separator:a91ff977bc2159fdb5008a5f2a7df7890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39d35f43f1e6ef891f161ea557ce641"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa39d35f43f1e6ef891f161ea557ce641"></a>
typedef const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a></td></tr>
<tr class="memdesc:aa39d35f43f1e6ef891f161ea557ce641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br/></td></tr>
<tr class="separator:aa39d35f43f1e6ef891f161ea557ce641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8433a860ba90d8f77df196183ee2891d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8433a860ba90d8f77df196183ee2891d"></a>
typedef MT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a></td></tr>
<tr class="memdesc:a8433a860ba90d8f77df196183ee2891d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix. <br/></td></tr>
<tr class="separator:a8433a860ba90d8f77df196183ee2891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a14de40c9805087c5ce46284d46606b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a14de40c9805087c5ce46284d46606b44">operator~</a> ()</td></tr>
<tr class="memdesc:a14de40c9805087c5ce46284d46606b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant matrices.  <a href="#a14de40c9805087c5ce46284d46606b44"></a><br/></td></tr>
<tr class="separator:a14de40c9805087c5ce46284d46606b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004801ebc1f1dcac5aa4a8e8fd09be0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a004801ebc1f1dcac5aa4a8e8fd09be0e">operator~</a> () const </td></tr>
<tr class="memdesc:a004801ebc1f1dcac5aa4a8e8fd09be0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant matrices.  <a href="#a004801ebc1f1dcac5aa4a8e8fd09be0e"></a><br/></td></tr>
<tr class="separator:a004801ebc1f1dcac5aa4a8e8fd09be0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a24e19393a208690a3cf33d45e8dacb2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a24e19393a208690a3cf33d45e8dacb2a">StaticMatrix</a> ()</td></tr>
<tr class="memdesc:a24e19393a208690a3cf33d45e8dacb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor for <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>.  <a href="#a24e19393a208690a3cf33d45e8dacb2a"></a><br/></td></tr>
<tr class="separator:a24e19393a208690a3cf33d45e8dacb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73229707ccd5b4479ae4715a141f6bf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a73229707ccd5b4479ae4715a141f6bf5">StaticMatrix</a> (const Type &amp;init)</td></tr>
<tr class="memdesc:a73229707ccd5b4479ae4715a141f6bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a homogenous initialization of all elements.  <a href="#a73229707ccd5b4479ae4715a141f6bf5"></a><br/></td></tr>
<tr class="separator:a73229707ccd5b4479ae4715a141f6bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f10ad2e79170b153c603f130f74154"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a19f10ad2e79170b153c603f130f74154">StaticMatrix</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:a19f10ad2e79170b153c603f130f74154"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor for <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>.  <a href="#a19f10ad2e79170b153c603f130f74154"></a><br/></td></tr>
<tr class="separator:a19f10ad2e79170b153c603f130f74154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4fc8fab0b3858e7ca9412c7eaf049f"><td class="memTemplParams" colspan="2">template&lt;typename Other , bool SO2&gt; </td></tr>
<tr class="memitem:afc4fc8fab0b3858e7ca9412c7eaf049f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#afc4fc8fab0b3858e7ca9412c7eaf049f">StaticMatrix</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Other, M, N, SO2 &gt; &amp;m)</td></tr>
<tr class="memdesc:afc4fc8fab0b3858e7ca9412c7eaf049f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor from different <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> instances.  <a href="#afc4fc8fab0b3858e7ca9412c7eaf049f"></a><br/></td></tr>
<tr class="separator:afc4fc8fab0b3858e7ca9412c7eaf049f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac8ef060fc933483823c9720402e07c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a0ac8ef060fc933483823c9720402e07c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a0ac8ef060fc933483823c9720402e07c">StaticMatrix</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a0ac8ef060fc933483823c9720402e07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor from different matrices.  <a href="#a0ac8ef060fc933483823c9720402e07c"></a><br/></td></tr>
<tr class="separator:a0ac8ef060fc933483823c9720402e07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f40fdf67fd872602f81b36df22b8a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a28f40fdf67fd872602f81b36df22b8a8">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2)</td></tr>
<tr class="memdesc:a28f40fdf67fd872602f81b36df22b8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 2 $" src="../../form_48.png"/> and <img class="formulaInl" alt="$ 2 \times 1 $" src="../../form_49.png"/> matrices.  <a href="#a28f40fdf67fd872602f81b36df22b8a8"></a><br/></td></tr>
<tr class="separator:a28f40fdf67fd872602f81b36df22b8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233612a260e8d85853bf04ccc01afbfc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a233612a260e8d85853bf04ccc01afbfc">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3)</td></tr>
<tr class="memdesc:a233612a260e8d85853bf04ccc01afbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 3 $" src="../../form_51.png"/> and <img class="formulaInl" alt="$ 3 \times 1 $" src="../../form_52.png"/> matrices.  <a href="#a233612a260e8d85853bf04ccc01afbfc"></a><br/></td></tr>
<tr class="separator:a233612a260e8d85853bf04ccc01afbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad847ba046155e27b8b57d344b6a45c86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad847ba046155e27b8b57d344b6a45c86">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4)</td></tr>
<tr class="memdesc:ad847ba046155e27b8b57d344b6a45c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 4 $" src="../../form_54.png"/>, <img class="formulaInl" alt="$ 2 \times 2 $" src="../../form_55.png"/>, and <img class="formulaInl" alt="$ 4 \times 1 $" src="../../form_56.png"/> matrices.  <a href="#ad847ba046155e27b8b57d344b6a45c86"></a><br/></td></tr>
<tr class="separator:ad847ba046155e27b8b57d344b6a45c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ab82850dcc39bb010c6e1d32c5e908"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a83ab82850dcc39bb010c6e1d32c5e908">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4, const Type &amp;v5)</td></tr>
<tr class="memdesc:a83ab82850dcc39bb010c6e1d32c5e908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 5 $" src="../../form_58.png"/> and <img class="formulaInl" alt="$ 5 \times 1 $" src="../../form_59.png"/> matrices.  <a href="#a83ab82850dcc39bb010c6e1d32c5e908"></a><br/></td></tr>
<tr class="separator:a83ab82850dcc39bb010c6e1d32c5e908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f51863d356b5e8f52fa74b0b2cfb636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a7f51863d356b5e8f52fa74b0b2cfb636">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4, const Type &amp;v5, const Type &amp;v6)</td></tr>
<tr class="memdesc:a7f51863d356b5e8f52fa74b0b2cfb636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 6 $" src="../../form_61.png"/>, <img class="formulaInl" alt="$ 2 \times 3 $" src="../../form_62.png"/>, <img class="formulaInl" alt="$ 3 \times 2 $" src="../../form_63.png"/>, and <img class="formulaInl" alt="$ 6 \times 1 $" src="../../form_64.png"/> matrices.  <a href="#a7f51863d356b5e8f52fa74b0b2cfb636"></a><br/></td></tr>
<tr class="separator:a7f51863d356b5e8f52fa74b0b2cfb636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f80630dfa36a68f9c3db8ec3cb7836"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ab0f80630dfa36a68f9c3db8ec3cb7836">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4, const Type &amp;v5, const Type &amp;v6, const Type &amp;v7)</td></tr>
<tr class="memdesc:ab0f80630dfa36a68f9c3db8ec3cb7836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 7 $" src="../../form_65.png"/> and <img class="formulaInl" alt="$ 7 \times 1 $" src="../../form_66.png"/> matrices.  <a href="#ab0f80630dfa36a68f9c3db8ec3cb7836"></a><br/></td></tr>
<tr class="separator:ab0f80630dfa36a68f9c3db8ec3cb7836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad674523cac448623cdba6725d2764760"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad674523cac448623cdba6725d2764760">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4, const Type &amp;v5, const Type &amp;v6, const Type &amp;v7, const Type &amp;v8)</td></tr>
<tr class="memdesc:ad674523cac448623cdba6725d2764760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 8 $" src="../../form_68.png"/> and <img class="formulaInl" alt="$ 8 \times 1 $" src="../../form_69.png"/> matrices.  <a href="#ad674523cac448623cdba6725d2764760"></a><br/></td></tr>
<tr class="separator:ad674523cac448623cdba6725d2764760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf85be58df8d2ad5b19ebf554dc47449"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aaf85be58df8d2ad5b19ebf554dc47449">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4, const Type &amp;v5, const Type &amp;v6, const Type &amp;v7, const Type &amp;v8, const Type &amp;v9)</td></tr>
<tr class="memdesc:aaf85be58df8d2ad5b19ebf554dc47449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 9 $" src="../../form_71.png"/>, <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_72.png"/>, and <img class="formulaInl" alt="$ 9 \times 1 $" src="../../form_73.png"/> matrices.  <a href="#aaf85be58df8d2ad5b19ebf554dc47449"></a><br/></td></tr>
<tr class="separator:aaf85be58df8d2ad5b19ebf554dc47449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8bff89cce156b5cefc27bb5f2125e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aaa8bff89cce156b5cefc27bb5f2125e4">StaticMatrix</a> (const Type &amp;v1, const Type &amp;v2, const Type &amp;v3, const Type &amp;v4, const Type &amp;v5, const Type &amp;v6, const Type &amp;v7, const Type &amp;v8, const Type &amp;v9, const Type &amp;v10)</td></tr>
<tr class="memdesc:aaa8bff89cce156b5cefc27bb5f2125e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <img class="formulaInl" alt="$ 1 \times 10 $" src="../../form_75.png"/>, <img class="formulaInl" alt="$ 2 \times 5 $" src="../../form_76.png"/>, <img class="formulaInl" alt="$ 5 \times 2 $" src="../../form_77.png"/>, and <img class="formulaInl" alt="$ 10 \times 1 $" src="../../form_78.png"/> matrices.  <a href="#aaa8bff89cce156b5cefc27bb5f2125e4"></a><br/></td></tr>
<tr class="separator:aaa8bff89cce156b5cefc27bb5f2125e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a458f3c9aaf675c34942524e8702662fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad72435ecfb9531951ca0e74769ce471c">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a458f3c9aaf675c34942524e8702662fa">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:a458f3c9aaf675c34942524e8702662fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the matrix elements.  <a href="#a458f3c9aaf675c34942524e8702662fa"></a><br/></td></tr>
<tr class="separator:a458f3c9aaf675c34942524e8702662fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4256b304a702e15106c23a3796e10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a8f56a0ca64211865e0ff3e4d493c2ccc">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aaf4256b304a702e15106c23a3796e10b">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:aaf4256b304a702e15106c23a3796e10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the matrix elements.  <a href="#aaf4256b304a702e15106c23a3796e10b"></a><br/></td></tr>
<tr class="separator:aaf4256b304a702e15106c23a3796e10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b68f37656118a1cb445eec520d2e3c"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#af2b68f37656118a1cb445eec520d2e3c">data</a> ()</td></tr>
<tr class="memdesc:af2b68f37656118a1cb445eec520d2e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements.  <a href="#af2b68f37656118a1cb445eec520d2e3c"></a><br/></td></tr>
<tr class="separator:af2b68f37656118a1cb445eec520d2e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e8bfdd9b9c2c7bb687466e1f7d46b9"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a03e8bfdd9b9c2c7bb687466e1f7d46b9">data</a> () const </td></tr>
<tr class="memdesc:a03e8bfdd9b9c2c7bb687466e1f7d46b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements.  <a href="#a03e8bfdd9b9c2c7bb687466e1f7d46b9"></a><br/></td></tr>
<tr class="separator:a03e8bfdd9b9c2c7bb687466e1f7d46b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7cd7b6c2a2497fc38639be7a32054d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a91ff977bc2159fdb5008a5f2a7df7890">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#acb7cd7b6c2a2497fc38639be7a32054d">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:acb7cd7b6c2a2497fc38639be7a32054d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#acb7cd7b6c2a2497fc38639be7a32054d"></a><br/></td></tr>
<tr class="separator:acb7cd7b6c2a2497fc38639be7a32054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bab2395c54721c01b3f69d6ff17525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad4bab2395c54721c01b3f69d6ff17525">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:ad4bab2395c54721c01b3f69d6ff17525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#ad4bab2395c54721c01b3f69d6ff17525"></a><br/></td></tr>
<tr class="separator:ad4bab2395c54721c01b3f69d6ff17525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843d7e6da208875a5353e49d9876f8d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a843d7e6da208875a5353e49d9876f8d5">cbegin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a843d7e6da208875a5353e49d9876f8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#a843d7e6da208875a5353e49d9876f8d5"></a><br/></td></tr>
<tr class="separator:a843d7e6da208875a5353e49d9876f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136fdfdf063e126c4e4fe856b7c81ad5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a91ff977bc2159fdb5008a5f2a7df7890">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a136fdfdf063e126c4e4fe856b7c81ad5">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a136fdfdf063e126c4e4fe856b7c81ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#a136fdfdf063e126c4e4fe856b7c81ad5"></a><br/></td></tr>
<tr class="separator:a136fdfdf063e126c4e4fe856b7c81ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaca34333f2176902ea4266d0de99352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#adaca34333f2176902ea4266d0de99352">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:adaca34333f2176902ea4266d0de99352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#adaca34333f2176902ea4266d0de99352"></a><br/></td></tr>
<tr class="separator:adaca34333f2176902ea4266d0de99352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70364e98137b51c14f5687c7ee6ee936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a70364e98137b51c14f5687c7ee6ee936">cend</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a70364e98137b51c14f5687c7ee6ee936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#a70364e98137b51c14f5687c7ee6ee936"></a><br/></td></tr>
<tr class="separator:a70364e98137b51c14f5687c7ee6ee936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a17f14e35d57d137d742e711651a713f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a17f14e35d57d137d742e711651a713f9">operator=</a> (const Type &amp;<a class="el" href="../../df/daa/group__intrinsics.html#ga7337e23a01474d5da47bf3fa2b98cdfe">set</a>)</td></tr>
<tr class="memdesc:a17f14e35d57d137d742e711651a713f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all matrix elements.  <a href="#a17f14e35d57d137d742e711651a713f9"></a><br/></td></tr>
<tr class="separator:a17f14e35d57d137d742e711651a713f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27b3fff0c6d9b8abfb1b312b3c1efdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad27b3fff0c6d9b8abfb1b312b3c1efdd">operator=</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad27b3fff0c6d9b8abfb1b312b3c1efdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>.  <a href="#ad27b3fff0c6d9b8abfb1b312b3c1efdd"></a><br/></td></tr>
<tr class="separator:ad27b3fff0c6d9b8abfb1b312b3c1efdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831a2dfa3f859747b0eb440e39d4264d"><td class="memTemplParams" colspan="2">template&lt;typename Other , bool SO2&gt; </td></tr>
<tr class="memitem:a831a2dfa3f859747b0eb440e39d4264d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a831a2dfa3f859747b0eb440e39d4264d">operator=</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Other, M, N, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a831a2dfa3f859747b0eb440e39d4264d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> instances.  <a href="#a831a2dfa3f859747b0eb440e39d4264d"></a><br/></td></tr>
<tr class="separator:a831a2dfa3f859747b0eb440e39d4264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4812810ea1504dbf3c1806ad004d12"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a9f4812810ea1504dbf3c1806ad004d12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a9f4812810ea1504dbf3c1806ad004d12">operator=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9f4812810ea1504dbf3c1806ad004d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different matrices.  <a href="#a9f4812810ea1504dbf3c1806ad004d12"></a><br/></td></tr>
<tr class="separator:a9f4812810ea1504dbf3c1806ad004d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab3fe06292f73d2191e719ea80ca770"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:aeab3fe06292f73d2191e719ea80ca770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aeab3fe06292f73d2191e719ea80ca770">operator+=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aeab3fe06292f73d2191e719ea80ca770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_25.png"/>).  <a href="#aeab3fe06292f73d2191e719ea80ca770"></a><br/></td></tr>
<tr class="separator:aeab3fe06292f73d2191e719ea80ca770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524e590a44679183c6b33619a073e6f0"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a524e590a44679183c6b33619a073e6f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a524e590a44679183c6b33619a073e6f0">operator-=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a524e590a44679183c6b33619a073e6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_26.png"/>).  <a href="#a524e590a44679183c6b33619a073e6f0"></a><br/></td></tr>
<tr class="separator:a524e590a44679183c6b33619a073e6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f25d56e8d05d0259739ead9b07f90c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a56f25d56e8d05d0259739ead9b07f90c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a56f25d56e8d05d0259739ead9b07f90c">operator*=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a56f25d56e8d05d0259739ead9b07f90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_27.png"/>).  <a href="#a56f25d56e8d05d0259739ead9b07f90c"></a><br/></td></tr>
<tr class="separator:a56f25d56e8d05d0259739ead9b07f90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d277cd1fef673a4605866c684c0ec58"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a0d277cd1fef673a4605866c684c0ec58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;<br class="typebreak"/>
, <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a0d277cd1fef673a4605866c684c0ec58">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a0d277cd1fef673a4605866c684c0ec58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a matrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_28.png"/>).  <a href="#a0d277cd1fef673a4605866c684c0ec58"></a><br/></td></tr>
<tr class="separator:a0d277cd1fef673a4605866c684c0ec58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779dce0b6cff63f2a8470931b7c90e66"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a779dce0b6cff63f2a8470931b7c90e66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;<br class="typebreak"/>
, <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a779dce0b6cff63f2a8470931b7c90e66">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:a779dce0b6cff63f2a8470931b7c90e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a matrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_29.png"/>).  <a href="#a779dce0b6cff63f2a8470931b7c90e66"></a><br/></td></tr>
<tr class="separator:a779dce0b6cff63f2a8470931b7c90e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:ab6e9061c7f4ad64969b41b9e17e4dfe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ab6e9061c7f4ad64969b41b9e17e4dfe3">rows</a> () const </td></tr>
<tr class="memdesc:ab6e9061c7f4ad64969b41b9e17e4dfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the matrix.  <a href="#ab6e9061c7f4ad64969b41b9e17e4dfe3"></a><br/></td></tr>
<tr class="separator:ab6e9061c7f4ad64969b41b9e17e4dfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc8c0bbe75b3a88603834ef0ae2c15f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a6fc8c0bbe75b3a88603834ef0ae2c15f">columns</a> () const </td></tr>
<tr class="memdesc:a6fc8c0bbe75b3a88603834ef0ae2c15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the matrix.  <a href="#a6fc8c0bbe75b3a88603834ef0ae2c15f"></a><br/></td></tr>
<tr class="separator:a6fc8c0bbe75b3a88603834ef0ae2c15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857e82e708006f9be45c0e922ed4f3f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a857e82e708006f9be45c0e922ed4f3f6">spacing</a> () const </td></tr>
<tr class="memdesc:a857e82e708006f9be45c0e922ed4f3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the spacing between the beginning of two rows.  <a href="#a857e82e708006f9be45c0e922ed4f3f6"></a><br/></td></tr>
<tr class="separator:a857e82e708006f9be45c0e922ed4f3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d8b84d10679a6e1550596e710123ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#af9d8b84d10679a6e1550596e710123ab">nonZeros</a> () const </td></tr>
<tr class="memdesc:af9d8b84d10679a6e1550596e710123ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of non-zero elements in the matrix.  <a href="#af9d8b84d10679a6e1550596e710123ab"></a><br/></td></tr>
<tr class="separator:af9d8b84d10679a6e1550596e710123ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4248d5d483bd8ad6ec922f4bb358e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad4248d5d483bd8ad6ec922f4bb358e52">nonZeros</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:ad4248d5d483bd8ad6ec922f4bb358e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row.  <a href="#ad4248d5d483bd8ad6ec922f4bb358e52"></a><br/></td></tr>
<tr class="separator:ad4248d5d483bd8ad6ec922f4bb358e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbd3c637f08a408a6c90736983d9c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a9dbd3c637f08a408a6c90736983d9c53">reset</a> ()</td></tr>
<tr class="memdesc:a9dbd3c637f08a408a6c90736983d9c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#a9dbd3c637f08a408a6c90736983d9c53"></a><br/></td></tr>
<tr class="separator:a9dbd3c637f08a408a6c90736983d9c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fc5aa26c9071db7d47e7ad8f977ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a87fc5aa26c9071db7d47e7ad8f977ed8">transpose</a> ()</td></tr>
<tr class="memdesc:a87fc5aa26c9071db7d47e7ad8f977ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposing the matrix.  <a href="#a87fc5aa26c9071db7d47e7ad8f977ed8"></a><br/></td></tr>
<tr class="separator:a87fc5aa26c9071db7d47e7ad8f977ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cf0f6a5ec8230e85127e654d653db7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad3cf0f6a5ec8230e85127e654d653db7">isDiagonal</a> () const </td></tr>
<tr class="memdesc:ad3cf0f6a5ec8230e85127e654d653db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the matrix is diagonal.  <a href="#ad3cf0f6a5ec8230e85127e654d653db7"></a><br/></td></tr>
<tr class="separator:ad3cf0f6a5ec8230e85127e654d653db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec291fbd135dfc025f53143c5ac814be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aec291fbd135dfc025f53143c5ac814be">isSymmetric</a> () const </td></tr>
<tr class="memdesc:aec291fbd135dfc025f53143c5ac814be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the matrix is symmetric.  <a href="#aec291fbd135dfc025f53143c5ac814be"></a><br/></td></tr>
<tr class="separator:aec291fbd135dfc025f53143c5ac814be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eb07d5ef8cd480836a8126beaf2e85"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a42eb07d5ef8cd480836a8126beaf2e85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a42eb07d5ef8cd480836a8126beaf2e85">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:a42eb07d5ef8cd480836a8126beaf2e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the matrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A*=s $" src="../../form_28.png"/>).  <a href="#a42eb07d5ef8cd480836a8126beaf2e85"></a><br/></td></tr>
<tr class="separator:a42eb07d5ef8cd480836a8126beaf2e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9983dc7b1f89b1612041c9a0491b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a8d9983dc7b1f89b1612041c9a0491b2b">swap</a> (<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:a8d9983dc7b1f89b1612041c9a0491b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two static matrices.  <a href="#a8d9983dc7b1f89b1612041c9a0491b2b"></a><br/></td></tr>
<tr class="separator:a8d9983dc7b1f89b1612041c9a0491b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:aed1b4280705ad984decffe9cde0adb92"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:aed1b4280705ad984decffe9cde0adb92"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aed1b4280705ad984decffe9cde0adb92">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:aed1b4280705ad984decffe9cde0adb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is aliased with the given address <em>alias</em>.  <a href="#aed1b4280705ad984decffe9cde0adb92"></a><br/></td></tr>
<tr class="separator:aed1b4280705ad984decffe9cde0adb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a51cd5d76631367affb35c2ff77cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a4b9f947227ece17d1b296e5f911c31ab">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a99a51cd5d76631367affb35c2ff77cd0">get</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:a99a51cd5d76631367affb35c2ff77cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the intrinsic elements of the matrix.  <a href="#a99a51cd5d76631367affb35c2ff77cd0"></a><br/></td></tr>
<tr class="separator:a99a51cd5d76631367affb35c2ff77cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b7a66f35cede5466fb841ac29ddded"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:ab8b7a66f35cede5466fb841ac29ddded"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAssign<br class="typebreak"/>
&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ab8b7a66f35cede5466fb841ac29ddded">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab8b7a66f35cede5466fb841ac29ddded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense matrix.  <a href="#ab8b7a66f35cede5466fb841ac29ddded"></a><br/></td></tr>
<tr class="separator:ab8b7a66f35cede5466fb841ac29ddded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72278d6e63046228e551e46bc3e03791"><td class="memTemplParams" colspan="2"><a class="anchor" id="a72278d6e63046228e551e46bc3e03791"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a72278d6e63046228e551e46bc3e03791"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAssign&lt; MT &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a72278d6e63046228e551e46bc3e03791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221b8a6b803780a2e3c7d04903f6eeff"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a221b8a6b803780a2e3c7d04903f6eeff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a221b8a6b803780a2e3c7d04903f6eeff">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a221b8a6b803780a2e3c7d04903f6eeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a row-major sparse matrix.  <a href="#a221b8a6b803780a2e3c7d04903f6eeff"></a><br/></td></tr>
<tr class="separator:a221b8a6b803780a2e3c7d04903f6eeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab943b85cec25b16e98ac5a571fa3fe13"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ab943b85cec25b16e98ac5a571fa3fe13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ab943b85cec25b16e98ac5a571fa3fe13">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab943b85cec25b16e98ac5a571fa3fe13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a column-major sparse matrix.  <a href="#ab943b85cec25b16e98ac5a571fa3fe13"></a><br/></td></tr>
<tr class="separator:ab943b85cec25b16e98ac5a571fa3fe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6e5be9b61c2c83e9db02bee1755498"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:aee6e5be9b61c2c83e9db02bee1755498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAddAssign<br class="typebreak"/>
&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aee6e5be9b61c2c83e9db02bee1755498">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aee6e5be9b61c2c83e9db02bee1755498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a row-major dense matrix.  <a href="#aee6e5be9b61c2c83e9db02bee1755498"></a><br/></td></tr>
<tr class="separator:aee6e5be9b61c2c83e9db02bee1755498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238c4ec8a16930c31ddec75486ce8057"><td class="memTemplParams" colspan="2"><a class="anchor" id="a238c4ec8a16930c31ddec75486ce8057"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a238c4ec8a16930c31ddec75486ce8057"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAddAssign<br class="typebreak"/>
&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a238c4ec8a16930c31ddec75486ce8057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bebf4197269bd10e3b9ee06d6875da1"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a1bebf4197269bd10e3b9ee06d6875da1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a1bebf4197269bd10e3b9ee06d6875da1">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1bebf4197269bd10e3b9ee06d6875da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a row-major sparse matrix.  <a href="#a1bebf4197269bd10e3b9ee06d6875da1"></a><br/></td></tr>
<tr class="separator:a1bebf4197269bd10e3b9ee06d6875da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c24547ec18bd5002d804f1ca03da128"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a1c24547ec18bd5002d804f1ca03da128"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a1c24547ec18bd5002d804f1ca03da128">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1c24547ec18bd5002d804f1ca03da128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a column-major sparse matrix.  <a href="#a1c24547ec18bd5002d804f1ca03da128"></a><br/></td></tr>
<tr class="separator:a1c24547ec18bd5002d804f1ca03da128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd40e55b739b021dd2cc5e4f6a06cf36"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:acd40e55b739b021dd2cc5e4f6a06cf36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedSubAssign<br class="typebreak"/>
&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#acd40e55b739b021dd2cc5e4f6a06cf36">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acd40e55b739b021dd2cc5e4f6a06cf36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense matrix.  <a href="#acd40e55b739b021dd2cc5e4f6a06cf36"></a><br/></td></tr>
<tr class="separator:acd40e55b739b021dd2cc5e4f6a06cf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de3b61562c44ee35cdafff4152fae37"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7de3b61562c44ee35cdafff4152fae37"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a7de3b61562c44ee35cdafff4152fae37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedSubAssign<br class="typebreak"/>
&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a7de3b61562c44ee35cdafff4152fae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7809a2136ca6e2f1ffbd5976dae1be8"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:aa7809a2136ca6e2f1ffbd5976dae1be8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa7809a2136ca6e2f1ffbd5976dae1be8">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa7809a2136ca6e2f1ffbd5976dae1be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a row-major sparse matrix.  <a href="#aa7809a2136ca6e2f1ffbd5976dae1be8"></a><br/></td></tr>
<tr class="separator:aa7809a2136ca6e2f1ffbd5976dae1be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0a3cd94d425afc7264fca9e3f12945"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a8d0a3cd94d425afc7264fca9e3f12945"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a8d0a3cd94d425afc7264fca9e3f12945">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8d0a3cd94d425afc7264fca9e3f12945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a column-major sparse matrix.  <a href="#a8d0a3cd94d425afc7264fca9e3f12945"></a><br/></td></tr>
<tr class="separator:a8d0a3cd94d425afc7264fca9e3f12945"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ace18c4f5a195c8775904f8987406ce63"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NN</b> = N + ( IT::size - ( N % IT::size ) ) % IT::size
 }</td></tr>
<tr class="memdesc:ace18c4f5a195c8775904f8987406ce63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment adjustment. <br/></td></tr>
<tr class="separator:ace18c4f5a195c8775904f8987406ce63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35d1089a9d6cb1cf554813ea76d5159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab35d1089a9d6cb1cf554813ea76d5159"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ab35d1089a9d6cb1cf554813ea76d5159">IT</a></td></tr>
<tr class="memdesc:ab35d1089a9d6cb1cf554813ea76d5159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic trait for the vector element type. <br/></td></tr>
<tr class="separator:ab35d1089a9d6cb1cf554813ea76d5159"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a12d3243309915dc6d95a170a0145efae"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a12d3243309915dc6d95a170a0145efae">v_</a> [M *NN]</td></tr>
<tr class="memdesc:a12d3243309915dc6d95a170a0145efae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statically allocated matrix elements.  <a href="#a12d3243309915dc6d95a170a0145efae"></a><br/></td></tr>
<tr class="separator:a12d3243309915dc6d95a170a0145efae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, size_t M, size_t N, bool SO = defaultStorageOrder&gt;<br/>
class blaze::StaticMatrix&lt; Type, M, N, SO &gt;</h3>

<p>Efficient implementation of a fixed-sized matrix.</p>
<p>The <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> class template is the representation of a fixed-size matrix with statically allocated elements of arbitrary type. The type of the elements, the number of rows and columns and the storage order of the matrix can be specified via the four template parameters: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Type, <span class="keywordtype">size_t</span> M, <span class="keywordtype">size_t</span> N, <span class="keywordtype">bool</span> SO &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a24e19393a208690a3cf33d45e8dacb2a" title="The default constructor for StaticMatrix.">StaticMatrix</a>;</div>
</div><!-- fragment --><ul>
<li>Type: specifies the type of the matrix elements. <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> can be used with any non-cv-qualified, non-reference, non-pointer element type.</li>
<li>M : specifies the total number of rows of the matrix.</li>
<li>N : specifies the total number of columns of the matrix. Note that it is expected that <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> is only used for tiny and small matrices.</li>
<li>SO : specifies the storage order (<a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>, <a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices.">blaze::columnMajor</a>) of the matrix. The default value is <a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>.</li>
</ul>
<p>Depending on the storage order, the matrix elements are either stored in a row-wise fashion or in a column-wise fashion. Given the 2x3 matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right)\]" src="../../form_19.png"/>
</p>
<p><br/>
</p>
<p>in case of row-major order the elements are stored in the order</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{6}{c}} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6. \\ \end{array}\right)\]" src="../../form_20.png"/>
</p>
<p>In case of column-major order the elements are stored in the order</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{6}{c}} 1 &amp; 4 &amp; 2 &amp; 5 &amp; 3 &amp; 6. \\ \end{array}\right)\]" src="../../form_21.png"/>
</p>
<p>The use of <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> is very natural and intuitive. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combination of row-major and column-major dense and sparse matrices with fitting element types. The following example gives an impression of the use of <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">blaze::CompressedMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices.">blaze::columnMajor</a>;</div>
<div class="line"></div>
<div class="line">StaticMatrix&lt;double,2UL,3UL,rowMajor&gt; A;   <span class="comment">// Default constructed, non-initialized, row-major 2x3 matrix</span></div>
<div class="line">A(0,0) = 1.0; A(0,1) = 2.0; A(0,2) = 3.0;  <span class="comment">// Initialization of the first row</span></div>
<div class="line">A(1,0) = 4.0; A(1,1) = 5.0; A(1,2) = 6.0;  <span class="comment">// Initialization of the second row</span></div>
<div class="line"></div>
<div class="line">DynamicMatrix&lt;float,2UL,3UL,columnMajor&gt; B;  <span class="comment">// Default constructed column-major single precision 2x3 matrix</span></div>
<div class="line">B(0,0) = 1.0; B(0,1) = 3.0; B(0,2) = 5.0;    <span class="comment">// Initialization of the first row</span></div>
<div class="line">B(1,0) = 2.0; B(1,1) = 4.0; B(1,2) = 6.0;    <span class="comment">// Initialization of the second row</span></div>
<div class="line"></div>
<div class="line">CompressedMatrix&lt;float&gt;     C( 2, 3 );  <span class="comment">// Empty row-major sparse single precision matrix</span></div>
<div class="line">StaticMatrix&lt;float,3UL,2UL&gt; D( 4.0F );  <span class="comment">// Directly, homogeneously initialized single precision 3x2 matrix</span></div>
<div class="line"></div>
<div class="line">StaticMatrix&lt;double,2UL,3UL,rowMajor&gt;    E( A );  <span class="comment">// Creation of a new row-major matrix as a copy of A</span></div>
<div class="line">StaticMatrix&lt;double,2UL,2UL,columnMajor&gt; F;       <span class="comment">// Creation of a default column-major matrix</span></div>
<div class="line"></div>
<div class="line">E = A + B;     <span class="comment">// Matrix addition and assignment to a row-major matrix</span></div>
<div class="line">E = A - C;     <span class="comment">// Matrix subtraction and assignment to a column-major matrix</span></div>
<div class="line">F = A * D;     <span class="comment">// Matrix multiplication between two matrices of different element types</span></div>
<div class="line"></div>
<div class="line">A *= 2.0;      <span class="comment">// In-place scaling of matrix A</span></div>
<div class="line">E  = 2.0 * B;  <span class="comment">// Scaling of matrix B</span></div>
<div class="line">E  = B * 2.0;  <span class="comment">// Scaling of matrix B</span></div>
<div class="line"></div>
<div class="line">E += A - B;    <span class="comment">// Addition assignment</span></div>
<div class="line">E -= A + C;    <span class="comment">// Subtraction assignment</span></div>
<div class="line">F *= A * D;    <span class="comment">// Multiplication assignment</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a5b340118207a4957a25f653e0197084e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t M, size_t N, bool SO = defaultStorageOrder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for intrinsic optimization. </p>
<p>The <em>vectorizable</em> compilation flag indicates whether expressions the vector is involved in can be optimized via intrinsics. In case the element type of the vector is a vectorizable data type, the <em>vectorizable</em> compilation flag is set to <em>true</em>, otherwise it is set to <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a07ce1a5a7cae4e25caf63a31f3f96b48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t M, size_t N, bool SO = defaultStorageOrder&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compilation flag for the detection of aliasing effects. </p>
<p>This compilation switch indicates whether this type potentially causes compuation errors due to aliasing effects. In case the type can cause aliasing effects, the <em>canAlias</em> switch is set to <em>true</em>, otherwise it is set to <em>false</em>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a24e19393a208690a3cf33d45e8dacb2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor for <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>. </p>
<p>All matrix elements are initialized to the default value (i.e. 0 for integral data types). </p>

</div>
</div>
<a class="anchor" id="a73229707ccd5b4479ae4715a141f6bf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a homogenous initialization of all elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initial value for all matrix elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19f10ad2e79170b153c603f130f74154"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor for <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<p>The copy constructor is explicitly defined in order to enable/facilitate NRV optimization. </p>

</div>
</div>
<a class="anchor" id="afc4fc8fab0b3858e7ca9412c7eaf049f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Other, M, N, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion constructor from different <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ac8ef060fc933483823c9720402e07c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion constructor from different matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of static matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes the static matrix from the given matrix. In case the size of the given matrix does not match the size of the static matrix (i.e. the number of rows is not M or the number of columns is not N), a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a28f40fdf67fd872602f81b36df22b8a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 2 $" src="../../form_48.png"/> and <img class="formulaInl" alt="$ 2 \times 1 $" src="../../form_49.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 2 $" src="../../form_48.png"/> and <img class="formulaInl" alt="$ 2 \times 1 $" src="../../form_49.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{2}{c}} 1 &amp; 2 \\ \end{array}\right)\]" src="../../form_50.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,1,2,false&gt;</a> A( 1, 2 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a233612a260e8d85853bf04ccc01afbfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 3 $" src="../../form_51.png"/> and <img class="formulaInl" alt="$ 3 \times 1 $" src="../../form_52.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 3 $" src="../../form_51.png"/> and <img class="formulaInl" alt="$ 3 \times 1 $" src="../../form_52.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ \end{array}\right)\]" src="../../form_53.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,1,3,false&gt;</a> A( 1, 2, 3 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad847ba046155e27b8b57d344b6a45c86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 4 $" src="../../form_54.png"/>, <img class="formulaInl" alt="$ 2 \times 2 $" src="../../form_55.png"/>, and <img class="formulaInl" alt="$ 4 \times 1 $" src="../../form_56.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third matrix element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 4 $" src="../../form_54.png"/>, <img class="formulaInl" alt="$ 2 \times 2 $" src="../../form_55.png"/> and <img class="formulaInl" alt="$ 3 \times 1 $" src="../../form_52.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{2}{c}} 1 &amp; 2 \\ 3 &amp; 4 \\ \end{array}\right)\]" src="../../form_57.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,2,2,false&gt;</a> A( 1, 2, 3, 4 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a83ab82850dcc39bb010c6e1d32c5e908"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 5 $" src="../../form_58.png"/> and <img class="formulaInl" alt="$ 5 \times 1 $" src="../../form_59.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third matrix element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth matrix element. </td></tr>
    <tr><td class="paramname">v5</td><td>The initializer for the fifth matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 5 $" src="../../form_58.png"/>, and <img class="formulaInl" alt="$ 5 \times 1 $" src="../../form_59.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\ \end{array}\right)\]" src="../../form_60.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,1,5,false&gt;</a> A( 1, 2, 3, 4, 5 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7f51863d356b5e8f52fa74b0b2cfb636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 6 $" src="../../form_61.png"/>, <img class="formulaInl" alt="$ 2 \times 3 $" src="../../form_62.png"/>, <img class="formulaInl" alt="$ 3 \times 2 $" src="../../form_63.png"/>, and <img class="formulaInl" alt="$ 6 \times 1 $" src="../../form_64.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third matrix element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth matrix element. </td></tr>
    <tr><td class="paramname">v5</td><td>The initializer for the fifth matrix element. </td></tr>
    <tr><td class="paramname">v6</td><td>The initializer for the sixth matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 6 $" src="../../form_61.png"/>, <img class="formulaInl" alt="$ 2 \times 3 $" src="../../form_62.png"/>, <img class="formulaInl" alt="$ 3 \times 2 $" src="../../form_63.png"/>, and <img class="formulaInl" alt="$ 6 \times 1 $" src="../../form_64.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right)\]" src="../../form_19.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,2,3,false&gt;</a> A( 1, 2, 3, 4, 5, 6 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab0f80630dfa36a68f9c3db8ec3cb7836"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 7 $" src="../../form_65.png"/> and <img class="formulaInl" alt="$ 7 \times 1 $" src="../../form_66.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third matrix element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth matrix element. </td></tr>
    <tr><td class="paramname">v5</td><td>The initializer for the fifth matrix element. </td></tr>
    <tr><td class="paramname">v6</td><td>The initializer for the sixth matrix element. </td></tr>
    <tr><td class="paramname">v7</td><td>The initializer for the seventh matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 7 $" src="../../form_65.png"/>, and <img class="formulaInl" alt="$ 7 \times 1 $" src="../../form_66.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{7}{c}} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 \\ \end{array}\right)\]" src="../../form_67.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,1,7,false&gt;</a> A( 1, 2, 3, 4, 5, 6, 7 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad674523cac448623cdba6725d2764760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 8 $" src="../../form_68.png"/> and <img class="formulaInl" alt="$ 8 \times 1 $" src="../../form_69.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third matrix element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth matrix element. </td></tr>
    <tr><td class="paramname">v5</td><td>The initializer for the fifth matrix element. </td></tr>
    <tr><td class="paramname">v6</td><td>The initializer for the sixth matrix element. </td></tr>
    <tr><td class="paramname">v7</td><td>The initializer for the seventh matrix element. </td></tr>
    <tr><td class="paramname">v8</td><td>The initializer for the eigth matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 8 $" src="../../form_68.png"/>, <img class="formulaInl" alt="$ 2 \times 4 $" src="../../form_30.png"/>, <img class="formulaInl" alt="$ 4 \times 2 $" src="../../form_31.png"/>, and <img class="formulaInl" alt="$ 8 \times 1 $" src="../../form_69.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{4}{c}} 1 &amp; 2 &amp; 3 &amp; 4 \\ 5 &amp; 6 &amp; 7 &amp; 8 \\ \end{array}\right)\]" src="../../form_70.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,2,4,false&gt;</a> A( 1, 2, 3, 4, 5, 6, 7, 8 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aaf85be58df8d2ad5b19ebf554dc47449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v9</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 9 $" src="../../form_71.png"/>, <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_72.png"/>, and <img class="formulaInl" alt="$ 9 \times 1 $" src="../../form_73.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third matrix element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth matrix element. </td></tr>
    <tr><td class="paramname">v5</td><td>The initializer for the fifth matrix element. </td></tr>
    <tr><td class="paramname">v6</td><td>The initializer for the sixth matrix element. </td></tr>
    <tr><td class="paramname">v7</td><td>The initializer for the seventh matrix element. </td></tr>
    <tr><td class="paramname">v8</td><td>The initializer for the eigth matrix element. </td></tr>
    <tr><td class="paramname">v9</td><td>The initializer for the ninth matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 9 $" src="../../form_71.png"/>, <img class="formulaInl" alt="$ 3 \times 3 $" src="../../form_72.png"/>, and <img class="formulaInl" alt="$ 9 \times 1 $" src="../../form_73.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\ \end{array}\right)\]" src="../../form_74.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,3,3,false&gt;</a> A( 1, 2, 3, 4, 5, 6, 7, 8, 9 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aaa8bff89cce156b5cefc27bb5f2125e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>v10</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for <img class="formulaInl" alt="$ 1 \times 10 $" src="../../form_75.png"/>, <img class="formulaInl" alt="$ 2 \times 5 $" src="../../form_76.png"/>, <img class="formulaInl" alt="$ 5 \times 2 $" src="../../form_77.png"/>, and <img class="formulaInl" alt="$ 10 \times 1 $" src="../../form_78.png"/> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The initializer for the first matrix element. </td></tr>
    <tr><td class="paramname">v2</td><td>The initializer for the second matrix element. </td></tr>
    <tr><td class="paramname">v3</td><td>The initializer for the third matrix element. </td></tr>
    <tr><td class="paramname">v4</td><td>The initializer for the fourth matrix element. </td></tr>
    <tr><td class="paramname">v5</td><td>The initializer for the fifth matrix element. </td></tr>
    <tr><td class="paramname">v6</td><td>The initializer for the sixth matrix element. </td></tr>
    <tr><td class="paramname">v7</td><td>The initializer for the seventh matrix element. </td></tr>
    <tr><td class="paramname">v8</td><td>The initializer for the eigth matrix element. </td></tr>
    <tr><td class="paramname">v9</td><td>The initializer for the ninth matrix element. </td></tr>
    <tr><td class="paramname">v10</td><td>The initializer for the tenth matrix element.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize a newly created <img class="formulaInl" alt="$ 1 \times 10 $" src="../../form_75.png"/>, <img class="formulaInl" alt="$ 2 \times 5 $" src="../../form_76.png"/>, <img class="formulaInl" alt="$ 5 \times 2 $" src="../../form_77.png"/>, and <img class="formulaInl" alt="$ 10 \times 1 $" src="../../form_78.png"/> matrix. The following example demonstrates this by creating the matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\ 6 &amp; 7 &amp; 8 &amp; 8 &amp; 10 \\ \end{array}\right)\]" src="../../form_79.png"/>
</p>
<p>:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,2,5,false&gt;</a> A( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 );</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aee6e5be9b61c2c83e9db02bee1755498"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; MT &gt; &gt;::Type <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a row-major dense matrix. </p>
<p>Intrinsic optimized implementation of the addition assignment of a dense matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a1bebf4197269bd10e3b9ee06d6875da1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a1c24547ec18bd5002d804f1ca03da128"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ab8b7a66f35cede5466fb841ac29ddded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; MT &gt; &gt;::Type <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense matrix. </p>
<p>Intrinsic optimized implementation of the assignment of a dense matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a221b8a6b803780a2e3c7d04903f6eeff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ab943b85cec25b16e98ac5a571fa3fe13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="acb7cd7b6c2a2497fc38639be7a32054d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a91ff977bc2159fdb5008a5f2a7df7890">Iterator</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ad4bab2395c54721c01b3f69d6ff17525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a843d7e6da208875a5353e49d9876f8d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a70364e98137b51c14f5687c7ee6ee936"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a6fc8c0bbe75b3a88603834ef0ae2c15f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of columns of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="af2b68f37656118a1cb445eec520d2e3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type * <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage. </dd></dl>

</div>
</div>
<a class="anchor" id="a03e8bfdd9b9c2c7bb687466e1f7d46b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type * <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage. </dd></dl>

</div>
</div>
<a class="anchor" id="a136fdfdf063e126c4e4fe856b7c81ad5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a91ff977bc2159fdb5008a5f2a7df7890">Iterator</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="adaca34333f2176902ea4266d0de99352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#aa39d35f43f1e6ef891f161ea557ce641">ConstIterator</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a99a51cd5d76631367affb35c2ff77cd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a4b9f947227ece17d1b296e5f911c31ab">IntrinsicType</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the intrinsic elements of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed values.</dd></dl>
<p>This function offers a direct access to the intrinsic elements of the matrix. It must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="aed1b4280705ad984decffe9cde0adb92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this matrix, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3cf0f6a5ec8230e85127e654d653db7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::isDiagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the matrix is diagonal. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is diagonal, <em>false</em> if not.</dd></dl>
<p>This function tests whether the matrix is diagonal, i.e. if the non-diagonal elements are default elements. In case of integral or floating point data types, a diagonal matrix has the form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} aa &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; bb &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; cc &amp; \cdots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; mn \\ \end{array}\right)\]" src="../../form_33.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="aec291fbd135dfc025f53143c5ac814be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::isSymmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the matrix is symmetric. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the matrix is symmetric, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="af9d8b84d10679a6e1550596e710123ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of non-zero elements in the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4248d5d483bd8ad6ec922f4bb358e52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row <em>i</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a458f3c9aaf675c34942524e8702662fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#ad72435ecfb9531951ca0e74769ce471c">Reference</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf4256b304a702e15106c23a3796e10b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html#a8f56a0ca64211865e0ff3e4d493c2ccc">ConstReference</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference-to-const to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a56f25d56e8d05d0259739ead9b07f90c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_27.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="a0d277cd1fef673a4605866c684c0ec58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &gt;::Type &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a matrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_28.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="aeab3fe06292f73d2191e719ea80ca770"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_25.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be added to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a524e590a44679183c6b33619a073e6f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_26.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be subtracted from the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a779dce0b6cff63f2a8470931b7c90e66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &gt;::Type &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a matrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_29.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix.</dd></dl>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="a17f14e35d57d137d742e711651a713f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>Scalar value to be assigned to all matrix elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="ad27b3fff0c6d9b8abfb1b312b3c1efdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix.</dd></dl>
<p>Explicit definition of a copy assignment operator for performance reasons. </p>

</div>
</div>
<a class="anchor" id="a831a2dfa3f859747b0eb440e39d4264d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Other, M, N, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f4812810ea1504dbf3c1806ad004d12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to static matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes the matrix as a copy of the given matrix. In case the number of rows of the given matrix is not M or the number of columns is not N, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a14de40c9805087c5ce46284d46606b44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; MT, SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a004801ebc1f1dcac5aa4a8e8fd09be0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; MT, SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dbd3c637f08a408a6c90736983d9c53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ab6e9061c7f4ad64969b41b9e17e4dfe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of rows of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a42eb07d5ef8cd480836a8126beaf2e85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the matrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A*=s $" src="../../form_28.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the matrix scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a857e82e708006f9be45c0e922ed4f3f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::spacing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the spacing between the beginning of two rows. </p>
<dl class="section return"><dt>Returns</dt><dd>The spacing between the beginning of two rows.</dd></dl>
<p>This function returns the spacing between the beginning of two rows, i.e. the total number of elements of a row. </p>

</div>
</div>
<a class="anchor" id="acd40e55b739b021dd2cc5e4f6a06cf36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; MT &gt; &gt;::Type <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense matrix. </p>
<p>Intrinsic optimized implementation of the subtraction assignment of a dense matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aa7809a2136ca6e2f1ffbd5976dae1be8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a8d0a3cd94d425afc7264fca9e3f12945"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a8d9983dc7b1f89b1612041c9a0491b2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two static matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87fc5aa26c9071db7d47e7ad8f977ed8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t M, size_t N, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp; <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposing the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transposed matrix. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a12d3243309915dc6d95a170a0145efae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t M, size_t N, bool SO = defaultStorageOrder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>&lt; Type, M, N, SO &gt;::v_[M *NN]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The statically allocated matrix elements. </p>
<p>Access to the matrix elements is gained via the function call operator. In case of row-major order the memory layout of the elements is </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 1 &amp; 2 &amp; \cdots &amp; N-1 \\ N &amp; N+1 &amp; N+2 &amp; \cdots &amp; 2 \cdot N-1 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ M \cdot N-N &amp; M \cdot N-N+1 &amp; M \cdot N-N+2 &amp; \cdots &amp; M \cdot N-1 \\ \end{array}\right)\]" src="../../form_35.png"/>
</p>
<p>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/dense/<a class="el" href="../../d6/dbe/dense_2StaticMatrix_8h_source.html">StaticMatrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:41 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
