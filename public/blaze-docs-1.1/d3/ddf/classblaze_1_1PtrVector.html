<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>blaze::PtrVector&lt; T, D, G &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="../../d2/d10/classblaze_1_1PtrVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::PtrVector&lt; T, D, G &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../d4/d3a/group__util.html">Utility module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of a vector for (polymorphic) pointers.  
 <a href="../../d3/ddf/classblaze_1_1PtrVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/d24/PtrVector_8h_source.html">PtrVector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast iterator for polymorphic pointer vectors.The <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> class is part of the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> class and represent a forward iterator over all elements of type <em>C</em> contained in a range of elements of type <em>T</em>, where <em>C</em> is a type derived from <em>T</em>.  <a href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast iterator for polymorphic pointer vectors.The <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> class is part of the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> class and represent a forward iterator over all elements of type <em>C</em> contained in a range of elements of type <em>T</em>, where <em>C</em> is a type derived from <em>T</em>. The <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> is the counterpart of <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> for constant vectors.  <a href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad6c4a34c972941d12d298a09f93bc4e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6c4a34c972941d12d298a09f93bc4e0"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ad6c4a34c972941d12d298a09f93bc4e0">ValueType</a></td></tr>
<tr class="memdesc:ad6c4a34c972941d12d298a09f93bc4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the underlying values. <br/></td></tr>
<tr class="separator:ad6c4a34c972941d12d298a09f93bc4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4bb81e62931d3ac84c9c2224acb33c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe4bb81e62931d3ac84c9c2224acb33c"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a></td></tr>
<tr class="memdesc:abe4bb81e62931d3ac84c9c2224acb33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-const object. <br/></td></tr>
<tr class="separator:abe4bb81e62931d3ac84c9c2224acb33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff3d9555e081978992a974828fb1727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeff3d9555e081978992a974828fb1727"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aeff3d9555e081978992a974828fb1727">ConstPointerType</a></td></tr>
<tr class="memdesc:aeff3d9555e081978992a974828fb1727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a const object. <br/></td></tr>
<tr class="separator:aeff3d9555e081978992a974828fb1727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2184f6a24202d046a86c192d6340eec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2184f6a24202d046a86c192d6340eec"></a>
typedef T *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2184f6a24202d046a86c192d6340eec">ReferenceType</a></td></tr>
<tr class="memdesc:ab2184f6a24202d046a86c192d6340eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-const object. <br/></td></tr>
<tr class="separator:ab2184f6a24202d046a86c192d6340eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ad0d9a96cc6fbfb6ad5163627ce75f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2ad0d9a96cc6fbfb6ad5163627ce75f"></a>
typedef T *const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2ad0d9a96cc6fbfb6ad5163627ce75f">ConstReferenceType</a></td></tr>
<tr class="memdesc:ab2ad0d9a96cc6fbfb6ad5163627ce75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a const object. <br/></td></tr>
<tr class="separator:ab2ad0d9a96cc6fbfb6ad5163627ce75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8247ecad461e7263bdfc2e64225c00ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8247ecad461e7263bdfc2e64225c00ee"></a>
typedef <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a></td></tr>
<tr class="memdesc:a8247ecad461e7263bdfc2e64225c00ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type of the pointer vector. <br/></td></tr>
<tr class="separator:a8247ecad461e7263bdfc2e64225c00ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e551e3c4ab00997d75a934f7384b35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e551e3c4ab00997d75a934f7384b35"></a>
typedef <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a></td></tr>
<tr class="memdesc:a94e551e3c4ab00997d75a934f7384b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-const objects. <br/></td></tr>
<tr class="separator:a94e551e3c4ab00997d75a934f7384b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15aaf7293942f6c6ef50ced924f8f78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae15aaf7293942f6c6ef50ced924f8f78"></a>
typedef <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; const T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ae15aaf7293942f6c6ef50ced924f8f78">ConstIterator</a></td></tr>
<tr class="memdesc:ae15aaf7293942f6c6ef50ced924f8f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over const objects. <br/></td></tr>
<tr class="separator:ae15aaf7293942f6c6ef50ced924f8f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dee09dafe472da52e5aa351d0c4196"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2dee09dafe472da52e5aa351d0c4196"></a>
typedef D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ad2dee09dafe472da52e5aa351d0c4196">DeletionPolicy</a></td></tr>
<tr class="memdesc:ad2dee09dafe472da52e5aa351d0c4196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the deletion policy. <br/></td></tr>
<tr class="separator:ad2dee09dafe472da52e5aa351d0c4196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc46af467c109729edb25c3f510bc4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafc46af467c109729edb25c3f510bc4e"></a>
typedef G&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aafc46af467c109729edb25c3f510bc4e">GrowthPolicy</a></td></tr>
<tr class="memdesc:aafc46af467c109729edb25c3f510bc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the growth policy. <br/></td></tr>
<tr class="separator:aafc46af467c109729edb25c3f510bc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12647f402c553fe624b9bebfedc2ced"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac12647f402c553fe624b9bebfedc2ced"></a>
typedef <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ad6c4a34c972941d12d298a09f93bc4e0">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ac12647f402c553fe624b9bebfedc2ced">value_type</a></td></tr>
<tr class="memdesc:ac12647f402c553fe624b9bebfedc2ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the underlying values. <br/></td></tr>
<tr class="separator:ac12647f402c553fe624b9bebfedc2ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a647bbe3ca62e2b81bb5a19139efc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53a647bbe3ca62e2b81bb5a19139efc2"></a>
typedef <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a53a647bbe3ca62e2b81bb5a19139efc2">pointer</a></td></tr>
<tr class="memdesc:a53a647bbe3ca62e2b81bb5a19139efc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-const object. <br/></td></tr>
<tr class="separator:a53a647bbe3ca62e2b81bb5a19139efc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7e88681dd7ae17a279164faa44d773"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe7e88681dd7ae17a279164faa44d773"></a>
typedef <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aeff3d9555e081978992a974828fb1727">ConstPointerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#afe7e88681dd7ae17a279164faa44d773">const_pointer</a></td></tr>
<tr class="memdesc:afe7e88681dd7ae17a279164faa44d773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a const object. <br/></td></tr>
<tr class="separator:afe7e88681dd7ae17a279164faa44d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70d6fae1ee6f5eaae5e5ee52113746"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c70d6fae1ee6f5eaae5e5ee52113746"></a>
typedef <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2184f6a24202d046a86c192d6340eec">ReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a3c70d6fae1ee6f5eaae5e5ee52113746">reference</a></td></tr>
<tr class="memdesc:a3c70d6fae1ee6f5eaae5e5ee52113746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-const object. <br/></td></tr>
<tr class="separator:a3c70d6fae1ee6f5eaae5e5ee52113746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3fdc90d046b96447a789136fd44264"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad3fdc90d046b96447a789136fd44264"></a>
typedef <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2ad0d9a96cc6fbfb6ad5163627ce75f">ConstReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aad3fdc90d046b96447a789136fd44264">const_reference</a></td></tr>
<tr class="memdesc:aad3fdc90d046b96447a789136fd44264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a const object. <br/></td></tr>
<tr class="separator:aad3fdc90d046b96447a789136fd44264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6c74222fe5a504b67a035dcd95a139"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed6c74222fe5a504b67a035dcd95a139"></a>
typedef <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aed6c74222fe5a504b67a035dcd95a139">size_type</a></td></tr>
<tr class="memdesc:aed6c74222fe5a504b67a035dcd95a139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type of the pointer vector. <br/></td></tr>
<tr class="separator:aed6c74222fe5a504b67a035dcd95a139"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:ad6b309a0aeb6c2f461091e5bdfaff879"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ad6b309a0aeb6c2f461091e5bdfaff879">PtrVector</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a> initCapacity=0)</td></tr>
<tr class="memdesc:ad6b309a0aeb6c2f461091e5bdfaff879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard constructor for <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a>.  <a href="#ad6b309a0aeb6c2f461091e5bdfaff879"></a><br/></td></tr>
<tr class="separator:ad6b309a0aeb6c2f461091e5bdfaff879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dccd50824dfd458707a1212230fb09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a86dccd50824dfd458707a1212230fb09">PtrVector</a> (const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> &amp;pv)</td></tr>
<tr class="memdesc:a86dccd50824dfd458707a1212230fb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a>.  <a href="#a86dccd50824dfd458707a1212230fb09"></a><br/></td></tr>
<tr class="separator:a86dccd50824dfd458707a1212230fb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278641e787e1719a4cd23b31fc6116ab"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename D2 , typename G2 &gt; </td></tr>
<tr class="memitem:a278641e787e1719a4cd23b31fc6116ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a278641e787e1719a4cd23b31fc6116ab">PtrVector</a> (const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T2, D2, G2 &gt; &amp;pv)</td></tr>
<tr class="memdesc:a278641e787e1719a4cd23b31fc6116ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor from different <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> instances.  <a href="#a278641e787e1719a4cd23b31fc6116ab"></a><br/></td></tr>
<tr class="separator:a278641e787e1719a4cd23b31fc6116ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a3f16e3b28dbfa62bf9ea4012a254fb3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a3f16e3b28dbfa62bf9ea4012a254fb3e">~PtrVector</a> ()</td></tr>
<tr class="memdesc:a3f16e3b28dbfa62bf9ea4012a254fb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a>.  <a href="#a3f16e3b28dbfa62bf9ea4012a254fb3e"></a><br/></td></tr>
<tr class="separator:a3f16e3b28dbfa62bf9ea4012a254fb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a53f8a744e2bb5792a7fb0d7c6611ba91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a53f8a744e2bb5792a7fb0d7c6611ba91">operator=</a> (const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> &amp;pv)</td></tr>
<tr class="memdesc:a53f8a744e2bb5792a7fb0d7c6611ba91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a>.  <a href="#a53f8a744e2bb5792a7fb0d7c6611ba91"></a><br/></td></tr>
<tr class="separator:a53f8a744e2bb5792a7fb0d7c6611ba91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c92c5bfa94b7e029e2d22253d340594"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename D2 , typename G2 &gt; </td></tr>
<tr class="memitem:a8c92c5bfa94b7e029e2d22253d340594"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8c92c5bfa94b7e029e2d22253d340594">operator=</a> (const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T2, D2, G2 &gt; &amp;pv)</td></tr>
<tr class="memdesc:a8c92c5bfa94b7e029e2d22253d340594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> instances.  <a href="#a8c92c5bfa94b7e029e2d22253d340594"></a><br/></td></tr>
<tr class="separator:a8c92c5bfa94b7e029e2d22253d340594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get functions</div></td></tr>
<tr class="memitem:accdeffe5d0765784f7f3de63e011209e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#accdeffe5d0765784f7f3de63e011209e">maxSize</a> () const </td></tr>
<tr class="memdesc:accdeffe5d0765784f7f3de63e011209e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible size of a pointer vector.  <a href="#accdeffe5d0765784f7f3de63e011209e"></a><br/></td></tr>
<tr class="separator:accdeffe5d0765784f7f3de63e011209e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0684110f80cbb87b4ebb48f6a19dd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#acf0684110f80cbb87b4ebb48f6a19dd4">size</a> () const </td></tr>
<tr class="memdesc:acf0684110f80cbb87b4ebb48f6a19dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size of the pointer vector.  <a href="#acf0684110f80cbb87b4ebb48f6a19dd4"></a><br/></td></tr>
<tr class="separator:acf0684110f80cbb87b4ebb48f6a19dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2833c7469e9df8ea970ab41525a912f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2833c7469e9df8ea970ab41525a912f"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:aa2833c7469e9df8ea970ab41525a912f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>size</b> () const </td></tr>
<tr class="separator:aa2833c7469e9df8ea970ab41525a912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f6fa7d52a419038ac21bd1381e2957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a45f6fa7d52a419038ac21bd1381e2957">capacity</a> () const </td></tr>
<tr class="memdesc:a45f6fa7d52a419038ac21bd1381e2957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the pointer vector.  <a href="#a45f6fa7d52a419038ac21bd1381e2957"></a><br/></td></tr>
<tr class="separator:a45f6fa7d52a419038ac21bd1381e2957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ff5cf807e67ac664fddfa470993320"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a23ff5cf807e67ac664fddfa470993320">isEmpty</a> () const </td></tr>
<tr class="memdesc:a23ff5cf807e67ac664fddfa470993320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>true</em> if the pointer vector has no elements.  <a href="#a23ff5cf807e67ac664fddfa470993320"></a><br/></td></tr>
<tr class="separator:a23ff5cf807e67ac664fddfa470993320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access functions</div></td></tr>
<tr class="memitem:a183c1b0cd7d6a164f5020b7d291c3ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2184f6a24202d046a86c192d6340eec">ReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a183c1b0cd7d6a164f5020b7d291c3ff3">operator[]</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a> index)</td></tr>
<tr class="memdesc:a183c1b0cd7d6a164f5020b7d291c3ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the pointer vector elements.  <a href="#a183c1b0cd7d6a164f5020b7d291c3ff3"></a><br/></td></tr>
<tr class="separator:a183c1b0cd7d6a164f5020b7d291c3ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908f7e8cffd31e3722b124ca3d23595d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2ad0d9a96cc6fbfb6ad5163627ce75f">ConstReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a908f7e8cffd31e3722b124ca3d23595d">operator[]</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a> index) const </td></tr>
<tr class="memdesc:a908f7e8cffd31e3722b124ca3d23595d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the pointer vector elements.  <a href="#a908f7e8cffd31e3722b124ca3d23595d"></a><br/></td></tr>
<tr class="separator:a908f7e8cffd31e3722b124ca3d23595d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1b26252ae154e945fe20619f8363ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2184f6a24202d046a86c192d6340eec">ReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a7e1b26252ae154e945fe20619f8363ea">front</a> ()</td></tr>
<tr class="memdesc:a7e1b26252ae154e945fe20619f8363ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element of the pointer vector.  <a href="#a7e1b26252ae154e945fe20619f8363ea"></a><br/></td></tr>
<tr class="separator:a7e1b26252ae154e945fe20619f8363ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4605d238729a11bfaa20c8f87db0606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2ad0d9a96cc6fbfb6ad5163627ce75f">ConstReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#af4605d238729a11bfaa20c8f87db0606">front</a> () const </td></tr>
<tr class="memdesc:af4605d238729a11bfaa20c8f87db0606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element of the pointer vector.  <a href="#af4605d238729a11bfaa20c8f87db0606"></a><br/></td></tr>
<tr class="separator:af4605d238729a11bfaa20c8f87db0606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64efbbceda1879140518b55975f6887b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2184f6a24202d046a86c192d6340eec">ReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a64efbbceda1879140518b55975f6887b">back</a> ()</td></tr>
<tr class="memdesc:a64efbbceda1879140518b55975f6887b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element of the pointer vector.  <a href="#a64efbbceda1879140518b55975f6887b"></a><br/></td></tr>
<tr class="separator:a64efbbceda1879140518b55975f6887b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba932c23d68ca352bb4df60fb35e9af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2ad0d9a96cc6fbfb6ad5163627ce75f">ConstReferenceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aba932c23d68ca352bb4df60fb35e9af9">back</a> () const </td></tr>
<tr class="memdesc:aba932c23d68ca352bb4df60fb35e9af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element of the pointer vector.  <a href="#aba932c23d68ca352bb4df60fb35e9af9"></a><br/></td></tr>
<tr class="separator:aba932c23d68ca352bb4df60fb35e9af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator functions</div></td></tr>
<tr class="memitem:a294790094e7d23648dc6aa911af5719b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b">begin</a> ()</td></tr>
<tr class="memdesc:a294790094e7d23648dc6aa911af5719b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the pointer vector.  <a href="#a294790094e7d23648dc6aa911af5719b"></a><br/></td></tr>
<tr class="separator:a294790094e7d23648dc6aa911af5719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e151c58850cd6dad67229015d304428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ae15aaf7293942f6c6ef50ced924f8f78">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a0e151c58850cd6dad67229015d304428">begin</a> () const </td></tr>
<tr class="memdesc:a0e151c58850cd6dad67229015d304428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the pointer vector.  <a href="#a0e151c58850cd6dad67229015d304428"></a><br/></td></tr>
<tr class="separator:a0e151c58850cd6dad67229015d304428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1317380b7a099ffb11ac5bd746012590"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1317380b7a099ffb11ac5bd746012590"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a1317380b7a099ffb11ac5bd746012590"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a1317380b7a099ffb11ac5bd746012590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f1c15f2a79d460b76140f3cc8b2d46"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab6f1c15f2a79d460b76140f3cc8b2d46"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:ab6f1c15f2a79d460b76140f3cc8b2d46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>begin</b> () const </td></tr>
<tr class="separator:ab6f1c15f2a79d460b76140f3cc8b2d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529a8f3db716a9e4e470220b167d403a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a">end</a> ()</td></tr>
<tr class="memdesc:a529a8f3db716a9e4e470220b167d403a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the pointer vector.  <a href="#a529a8f3db716a9e4e470220b167d403a"></a><br/></td></tr>
<tr class="separator:a529a8f3db716a9e4e470220b167d403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af85eb75f965d83788f9a92ad2d6918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ae15aaf7293942f6c6ef50ced924f8f78">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a4af85eb75f965d83788f9a92ad2d6918">end</a> () const </td></tr>
<tr class="memdesc:a4af85eb75f965d83788f9a92ad2d6918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the pointer vector.  <a href="#a4af85eb75f965d83788f9a92ad2d6918"></a><br/></td></tr>
<tr class="separator:a4af85eb75f965d83788f9a92ad2d6918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc069eff2854746b397982ba2bad1e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2bc069eff2854746b397982ba2bad1e"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:af2bc069eff2854746b397982ba2bad1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:af2bc069eff2854746b397982ba2bad1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc93de5d90943593f9af91694c801113"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc93de5d90943593f9af91694c801113"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:afc93de5d90943593f9af91694c801113"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:afc93de5d90943593f9af91694c801113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element functions</div></td></tr>
<tr class="memitem:aa68516609ff69a9daabfe0b8d7f366b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aa68516609ff69a9daabfe0b8d7f366b0">pushBack</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a> p)</td></tr>
<tr class="memdesc:aa68516609ff69a9daabfe0b8d7f366b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding an element to the end of the pointer vector.  <a href="#aa68516609ff69a9daabfe0b8d7f366b0"></a><br/></td></tr>
<tr class="separator:aa68516609ff69a9daabfe0b8d7f366b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28842d5a0d553c4e5fc955393c79fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ae28842d5a0d553c4e5fc955393c79fb1">popBack</a> ()</td></tr>
<tr class="memdesc:ae28842d5a0d553c4e5fc955393c79fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing an element from the end of the pointer vector.  <a href="#ae28842d5a0d553c4e5fc955393c79fb1"></a><br/></td></tr>
<tr class="separator:ae28842d5a0d553c4e5fc955393c79fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb0d71621a8f5ee0435ae37badb4ba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a1fb0d71621a8f5ee0435ae37badb4ba1">releaseBack</a> ()</td></tr>
<tr class="memdesc:a1fb0d71621a8f5ee0435ae37badb4ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releasing the element at the end of the pointer vector.  <a href="#a1fb0d71621a8f5ee0435ae37badb4ba1"></a><br/></td></tr>
<tr class="separator:a1fb0d71621a8f5ee0435ae37badb4ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373e3df596ff22e48f541728d695faaa"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a373e3df596ff22e48f541728d695faaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a373e3df596ff22e48f541728d695faaa">assign</a> (IteratorType first, IteratorType last)</td></tr>
<tr class="memdesc:a373e3df596ff22e48f541728d695faaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigning a range of elements to the pointer vector.  <a href="#a373e3df596ff22e48f541728d695faaa"></a><br/></td></tr>
<tr class="separator:a373e3df596ff22e48f541728d695faaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb35e534e969df135a3903fc208f4f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#adb35e534e969df135a3903fc208f4f85">insert</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a> pos, <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a> p)</td></tr>
<tr class="memdesc:adb35e534e969df135a3903fc208f4f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting an element into the pointer vector.  <a href="#adb35e534e969df135a3903fc208f4f85"></a><br/></td></tr>
<tr class="separator:adb35e534e969df135a3903fc208f4f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aec39b05a11a5c59625e7c89edc273"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a83aec39b05a11a5c59625e7c89edc273"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a83aec39b05a11a5c59625e7c89edc273">insert</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a> pos, IteratorType first, IteratorType last)</td></tr>
<tr class="memdesc:a83aec39b05a11a5c59625e7c89edc273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting a range of elements into the pointer vector.  <a href="#a83aec39b05a11a5c59625e7c89edc273"></a><br/></td></tr>
<tr class="separator:a83aec39b05a11a5c59625e7c89edc273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd377147fffa637f4c9427bcc108816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aebd377147fffa637f4c9427bcc108816">erase</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a> pos)</td></tr>
<tr class="memdesc:aebd377147fffa637f4c9427bcc108816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing an element from the pointer vector.  <a href="#aebd377147fffa637f4c9427bcc108816"></a><br/></td></tr>
<tr class="separator:aebd377147fffa637f4c9427bcc108816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f88445c7b2e9d4d1938cac9cc2815c0"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a2f88445c7b2e9d4d1938cac9cc2815c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a2f88445c7b2e9d4d1938cac9cc2815c0">erase</a> (<a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt; pos)</td></tr>
<tr class="memdesc:a2f88445c7b2e9d4d1938cac9cc2815c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing an element from the pointer vector.  <a href="#a2f88445c7b2e9d4d1938cac9cc2815c0"></a><br/></td></tr>
<tr class="separator:a2f88445c7b2e9d4d1938cac9cc2815c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f7c34a1742abe352d837812a75be30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a91f7c34a1742abe352d837812a75be30">release</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a> pos)</td></tr>
<tr class="memdesc:a91f7c34a1742abe352d837812a75be30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releasing an element from the pointer vector.  <a href="#a91f7c34a1742abe352d837812a75be30"></a><br/></td></tr>
<tr class="separator:a91f7c34a1742abe352d837812a75be30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6301a5a0afc59825acba25492f9f7c4"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ad6301a5a0afc59825acba25492f9f7c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ad6301a5a0afc59825acba25492f9f7c4">release</a> (<a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt; pos)</td></tr>
<tr class="memdesc:ad6301a5a0afc59825acba25492f9f7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releasing an element from the pointer vector.  <a href="#ad6301a5a0afc59825acba25492f9f7c4"></a><br/></td></tr>
<tr class="separator:ad6301a5a0afc59825acba25492f9f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ac6183a89157ee9641f3384ab02454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a09ac6183a89157ee9641f3384ab02454">clear</a> ()</td></tr>
<tr class="memdesc:a09ac6183a89157ee9641f3384ab02454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing all elements from the pointer vector.  <a href="#a09ac6183a89157ee9641f3384ab02454"></a><br/></td></tr>
<tr class="separator:a09ac6183a89157ee9641f3384ab02454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a4024cc0ac03e9b528caddc089bdbf13a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a4024cc0ac03e9b528caddc089bdbf13a">reserve</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a> newCapacity)</td></tr>
<tr class="memdesc:a4024cc0ac03e9b528caddc089bdbf13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of the pointer vector.  <a href="#a4024cc0ac03e9b528caddc089bdbf13a"></a><br/></td></tr>
<tr class="separator:a4024cc0ac03e9b528caddc089bdbf13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04691f829218dd311c3c43e42758af78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a04691f829218dd311c3c43e42758af78">swap</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> &amp;pv)</td></tr>
<tr class="memdesc:a04691f829218dd311c3c43e42758af78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two pointer vectors.  <a href="#a04691f829218dd311c3c43e42758af78"></a><br/></td></tr>
<tr class="separator:a04691f829218dd311c3c43e42758af78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Helper functions</div></td></tr>
<tr class="memitem:ae908e30bd1379bd2ca03f70afa8e853c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ae908e30bd1379bd2ca03f70afa8e853c">calcCapacity</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> minCapacity) const </td></tr>
<tr class="memdesc:ae908e30bd1379bd2ca03f70afa8e853c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculating the new capacity of the vector based on its growth policy.  <a href="#ae908e30bd1379bd2ca03f70afa8e853c"></a><br/></td></tr>
<tr class="separator:ae908e30bd1379bd2ca03f70afa8e853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5cf1d7228619ce9f7652e52608b93d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#aae5cf1d7228619ce9f7652e52608b93d">deleteElement</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a> ptr) const </td></tr>
<tr class="memdesc:aae5cf1d7228619ce9f7652e52608b93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleting an element of the pointer vector according to the deletion policy.  <a href="#aae5cf1d7228619ce9f7652e52608b93d"></a><br/></td></tr>
<tr class="separator:aae5cf1d7228619ce9f7652e52608b93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insertion helper functions</div></td></tr>
<tr class="memitem:a8e278e2b837aec2bc917e056a5a3b2a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8e278e2b837aec2bc917e056a5a3b2a9">insert</a> (T **const pos, <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a> p)</td></tr>
<tr class="memdesc:a8e278e2b837aec2bc917e056a5a3b2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting an element into the pointer vector.  <a href="#a8e278e2b837aec2bc917e056a5a3b2a9"></a><br/></td></tr>
<tr class="separator:a8e278e2b837aec2bc917e056a5a3b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a10867be87f2c0fe034d236568593"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a9a8a10867be87f2c0fe034d236568593"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a9a8a10867be87f2c0fe034d236568593">insert</a> (T **pos, IteratorType first, IteratorType last, <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a> n)</td></tr>
<tr class="memdesc:a9a8a10867be87f2c0fe034d236568593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting a range of elements into the pointer vector.  <a href="#a9a8a10867be87f2c0fe034d236568593"></a><br/></td></tr>
<tr class="separator:a9a8a10867be87f2c0fe034d236568593"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a741b941944751c640ba31d010134444a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a741b941944751c640ba31d010134444a"></a>
<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a741b941944751c640ba31d010134444a">size_</a></td></tr>
<tr class="memdesc:a741b941944751c640ba31d010134444a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current size of the pointer vector. <br/></td></tr>
<tr class="separator:a741b941944751c640ba31d010134444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55221f1f4acc5106857ec2d50b4f9983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55221f1f4acc5106857ec2d50b4f9983"></a>
<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a55221f1f4acc5106857ec2d50b4f9983">capacity_</a></td></tr>
<tr class="memdesc:a55221f1f4acc5106857ec2d50b4f9983"><td class="mdescLeft">&#160;</td><td class="mdescRight">The capacity of the pointer vector. <br/></td></tr>
<tr class="separator:a55221f1f4acc5106857ec2d50b4f9983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc2a9b5d07c5220504007d02e72c0e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dc2a9b5d07c5220504007d02e72c0e2"></a>
<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a2dc2a9b5d07c5220504007d02e72c0e2">begin_</a></td></tr>
<tr class="memdesc:a2dc2a9b5d07c5220504007d02e72c0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of the pointer vector. <br/></td></tr>
<tr class="separator:a2dc2a9b5d07c5220504007d02e72c0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38618d6dd09c489bf47c6028b4fb0fd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38618d6dd09c489bf47c6028b4fb0fd8"></a>
<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a38618d6dd09c489bf47c6028b4fb0fd8">end_</a></td></tr>
<tr class="memdesc:a38618d6dd09c489bf47c6028b4fb0fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the last element of the pointer vector. <br/></td></tr>
<tr class="separator:a38618d6dd09c489bf47c6028b4fb0fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">CastIterator/ConstCastIterator comparison operators</div></td></tr>
<tr class="memitem:a092d96024f6acb12012dbf0bed95d58d"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a092d96024f6acb12012dbf0bed95d58d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a092d96024f6acb12012dbf0bed95d58d">operator==</a> (const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; L &gt; &amp;lhs, const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; R &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a092d96024f6acb12012dbf0bed95d58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> objects.  <a href="#a092d96024f6acb12012dbf0bed95d58d"></a><br/></td></tr>
<tr class="separator:a092d96024f6acb12012dbf0bed95d58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3cd1257e1e37edf8396822c6ef88eb"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:acf3cd1257e1e37edf8396822c6ef88eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#acf3cd1257e1e37edf8396822c6ef88eb">operator==</a> (const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; L &gt; &amp;lhs, const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; R &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acf3cd1257e1e37edf8396822c6ef88eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> and a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a>.  <a href="#acf3cd1257e1e37edf8396822c6ef88eb"></a><br/></td></tr>
<tr class="separator:acf3cd1257e1e37edf8396822c6ef88eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c6b088804103bfca7725f8ca9c0f0c"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a37c6b088804103bfca7725f8ca9c0f0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a37c6b088804103bfca7725f8ca9c0f0c">operator==</a> (const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; L &gt; &amp;lhs, const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; R &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a37c6b088804103bfca7725f8ca9c0f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> and a <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a>.  <a href="#a37c6b088804103bfca7725f8ca9c0f0c"></a><br/></td></tr>
<tr class="separator:a37c6b088804103bfca7725f8ca9c0f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e5791d9031005918781bbef21b0159"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a89e5791d9031005918781bbef21b0159"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a89e5791d9031005918781bbef21b0159">operator==</a> (const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; L &gt; &amp;lhs, const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; R &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a89e5791d9031005918781bbef21b0159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> objects.  <a href="#a89e5791d9031005918781bbef21b0159"></a><br/></td></tr>
<tr class="separator:a89e5791d9031005918781bbef21b0159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85cfcdefb7de579fdef85af6070a67"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a1a85cfcdefb7de579fdef85af6070a67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a1a85cfcdefb7de579fdef85af6070a67">operator!=</a> (const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; L &gt; &amp;lhs, const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; R &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1a85cfcdefb7de579fdef85af6070a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> objects.  <a href="#a1a85cfcdefb7de579fdef85af6070a67"></a><br/></td></tr>
<tr class="separator:a1a85cfcdefb7de579fdef85af6070a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a32d809f6e96e4dd7af8179aa71ab2a"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a5a32d809f6e96e4dd7af8179aa71ab2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a5a32d809f6e96e4dd7af8179aa71ab2a">operator!=</a> (const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; L &gt; &amp;lhs, const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; R &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5a32d809f6e96e4dd7af8179aa71ab2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> and a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a>.  <a href="#a5a32d809f6e96e4dd7af8179aa71ab2a"></a><br/></td></tr>
<tr class="separator:a5a32d809f6e96e4dd7af8179aa71ab2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8003cfaeca70eabcaaff3d8fd67c388"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ac8003cfaeca70eabcaaff3d8fd67c388"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ac8003cfaeca70eabcaaff3d8fd67c388">operator!=</a> (const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; L &gt; &amp;lhs, const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; R &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac8003cfaeca70eabcaaff3d8fd67c388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> and a <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a>.  <a href="#ac8003cfaeca70eabcaaff3d8fd67c388"></a><br/></td></tr>
<tr class="separator:ac8003cfaeca70eabcaaff3d8fd67c388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2156409b7b38838b1d340fce347894ea"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a2156409b7b38838b1d340fce347894ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a2156409b7b38838b1d340fce347894ea">operator!=</a> (const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; L &gt; &amp;lhs, const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; R &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2156409b7b38838b1d340fce347894ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> objects.  <a href="#a2156409b7b38838b1d340fce347894ea"></a><br/></td></tr>
<tr class="separator:a2156409b7b38838b1d340fce347894ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt;<br/>
class blaze::PtrVector&lt; T, D, G &gt;</h3>

<p>Implementation of a vector for (polymorphic) pointers. </p>
<h1><a class="anchor" id="basics"></a>
Basic usage</h1>
<p>The <em>std::vector</em> is one of the standard libraries most useful tools. It is the standard solution for a dynamically allocated, automatically growing, and memory managed array. It provides fast random access to its elements, since a vector guarantees that the elements lie adjacent in memory and manages the dynamically allocated memory according to the RAII idiom.<br/>
 Yet there are some situations, where users of <em>std::vector</em> experience several drawbacks, especially when <em>std::vector</em> is used in combination with pointers. For instance, a <em>const_iterator</em> over a range of pointers will not allow the stored pointers to change, but the objects behind the pointers remain changeable. The following example illustrates that it is possible to change the values of <em>double</em> values through an iterator-to-const:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::vector&lt;double*&gt;  Doubles;</div>
<div class="line"></div>
<div class="line">Doubles doubles;  <span class="comment">// Creating a vector for pointers to double values</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Filling the vector with pointers to double values. All values are initialized with 1.</span></div>
<div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0; i&lt;10; ++i )</div>
<div class="line">   doubles.push_back( <span class="keyword">new</span> <span class="keywordtype">double</span>( 1.0 ) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Accessing the first rigid body</span></div>
<div class="line">Doubles::const_iterator first = doubles.begin();</div>
<div class="line">**first = 2.0;  <span class="comment">// Changes the double value through an iterator-to-const</span></div>
</div><!-- fragment --><p>The basic reason for this behavior is that <em>std::vector</em> is unaware of the fact that it stores pointers instead of objects and therefore the pointer are considered constant, not the objects behind the pointer.<br/>
 Another drawback of <em>std::vector</em> is the fact that during destruction of a vector object the dynamically allocated bodies are not deleted. Again, <em>std::vector</em> is unaware of the special property of pointers and therefore does not apply any kind of deletion policy. It basically calls the default destructor for pointers, which in turn does nothing and especially does not destroy the attached objects.<br/>
 A different approach is taken by the Boost <em>ptr_vector</em>. A <em>ptr_vector</em> is perfectly aware of the fact that is stores pointers to dynamically objects (and in consequence may only be used with pointers to dynamically allocated objects) and takes full responsibilty for these resources. However, in order to accomplish this task, <em>ptr_vector</em> completely abstracts from the fact that it stores pointers and provides a view as if it would contain objects instead of pointers. Unfortunately, this strict memory management might cause problems, for instance in case the vector to pointers is used both internally (including proper resource management) and outside by the user (without any resource management).<br/>
 In case both <em>std::vector</em> and <em>boost::ptr_vector</em> are not suitable data structures, the Blaze library provides a special vector container for pointers, which is a cross of the functionalities of the <em>std::vector</em> and <em>ptr_vector</em>. The Blaze <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> is not a RAII class in the classic sense (as for instance the Boost <em>ptr_vector</em>) since it does not strictly encapsule the resource management. As in the case of <em>std::vector</em>, it still is the responsibility of a user of <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> to manage the resources accordingly. However, <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> can be used internally to store pointers to dynamically allocated objects and resources within RAII classes, and outside by a user as storage for handles to resources that are managed elsewhere. In contrast to the <em>boost::ptr_vector</em>, the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> provides full access to the contained pointers, but its iterators work similar to the <em>ptr_vector</em> iterator and only provide access to the objects behind the pointers, creating the illusion that objects are stored instead of pointers:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;double&gt;</a>  Doubles;</div>
<div class="line">Doubles doubles;  <span class="comment">// Creating an empty PtrVector for pointers to double values</span></div>
<div class="line"></div>
<div class="line">doubles.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#aa68516609ff69a9daabfe0b8d7f366b0" title="Adding an element to the end of the pointer vector.">pushBack</a>( <span class="keyword">new</span> <span class="keywordtype">double</span>(1.0) ); <span class="comment">// A new pointer-to-double is added to the vector</span></div>
<div class="line"></div>
<div class="line">double_vector::iterator first = doubles.begin();</div>
<div class="line">*first = 2.0;  <span class="comment">// No indirection needed</span></div>
<div class="line"></div>
<div class="line">Doubles::ConstIterator second( first+1 );</div>
<div class="line">*second = 3.0;  <span class="comment">// Compile time error! It is not possible to change double</span></div>
<div class="line">                <span class="comment">// values via an iterator-to-const</span></div>
</div><!-- fragment --><p>Notice the differences in the usage of the iterator in contrast to the <em>std::vector</em> and <em>boost::ptr_vector</em>. In contrast to them the functions of <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> follow the naming convention of the Blaze library (i.e. pushBack instead of push_back). In addition, the underlying iterator adds an additional dereference to all access operators, which eases the access to the underlying objects:</p>
<div class="fragment"><div class="line"><span class="comment">// STL style:</span></div>
<div class="line">**first = 2.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// pe style:</span></div>
<div class="line">*first = 2.0;</div>
</div><!-- fragment --><p>A noteworthy difference between the STL vector and the pointer vector is the used template argument: instead of the pointer type, the Blaze pointer vector is only provided with the type of the underlying objects:</p>
<div class="fragment"><div class="line"><span class="comment">// STL style:</span></div>
<div class="line">std::vector&lt;double*&gt; vector;</div>
<div class="line"></div>
<div class="line"><span class="comment">// pe style:</span></div>
<div class="line"><a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;double&gt;</a> vector;</div>
</div><!-- fragment --><p>Additionally, the Blaze pointer vector offers some limited possibilities to configure the memory management and the growth of the internal storage, and implements special features for polymorphic pointers, as for instance a convenient way to iterate over a subset of polymorphic objects contained in the pointer vector.<br/>
<br/>
</p>
<h1><a class="anchor" id="polymorphic"></a>
Polymorphic pointers</h1>
<p>For polymorphic pointers, the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> class additionally offers two special iterators to iterate over all objects of a specific type: the <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> and <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of class A and the derived type B</span></div>
<div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A { ... };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for non-const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">      ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <span class="keyword">const</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the example, the cast iterators are used to iterate over all objects of type <em>B</em> within the pointer vector, where <em>B</em> must be a type derived from <em>A</em>. The attempt to use these iterators for types that are not derived from <em>A</em> results in a compile time error. Note that the usage of the cast iterators is computaionally more expensive than the use of the standard iterators. Therefore these iterators should not be used unless a down-cast is really necessary, e.g. in order to access a type specific function.<br/>
<br/>
</p>
<h1><a class="anchor" id="container"></a>
Using a pointer vector within other container classes</h1>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> a pointer vector is used within an other container and is used to store polymorphic pointers, you might face the problem of not being able to create type definitions for the cast iterators. Whereas it is possible to create typedefs for the standard iterators, it is unfortunately not possible (yet) to create type definitions for template classes. In order to create a new return type within the container, the following approach could be taken:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> A &gt;</div>
<div class="line"><span class="keyword">class </span>Container</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> C &gt;</div>
<div class="line">   <span class="keyword">struct </span><a class="code" href="../../d8/d64/classCastIterator.html">CastIterator</a> : <span class="keyword">public</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector</a>&lt;A&gt;<a class="code" href="../../d8/d64/classCastIterator.html">::CastIterator</a>&lt;C&gt;</div>
<div class="line">   {</div>
<div class="line">      <a class="code" href="../../d8/d64/classCastIterator.html">CastIterator</a>( <span class="keyword">const</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;::CastIterator&lt;C&gt;</a>&amp; it )</div>
<div class="line">         : blaze::<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#ad6b309a0aeb6c2f461091e5bdfaff879" title="Standard constructor for PtrVector.">PtrVector</a>&lt;A&gt;::<a class="code" href="../../d8/d64/classCastIterator.html">CastIterator</a>&lt;C&gt;( it )  <span class="comment">// Initializing the base class</span></div>
<div class="line">      {}</div>
<div class="line">   };</div>
<div class="line"></div>
<div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> C &gt;</div>
<div class="line">   <a class="code" href="../../d8/d64/classCastIterator.html">CastIterator&lt;C&gt;</a> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>();</div>
<div class="line"></div>
<div class="line">   <span class="keyword">template</span>&lt; <span class="keyword">typename</span> C &gt;</div>
<div class="line">   <a class="code" href="../../d8/d64/classCastIterator.html">CastIterator&lt;C&gt;</a> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>();</div>
<div class="line"></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">   <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a> vector_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Instead of a typedef within the Container class, a new class <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> is derived from the <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">PtrVector::CastIterator</a> class. This approach acts similar as the typedef as a user can now use the Container as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A { ... };</div>
<div class="line"></div>
<div class="line">Container&lt;A&gt;::CastIterator&lt;B&gt; <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>;</div>
</div><!-- fragment --><p>This provides the same abstraction from the internal implementation as the desired typedef. The same approach could be taken for a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> definition.<br/>
<br/>
</p>
<h1><a class="anchor" id="adaptions"></a>
Adapting a pointer vector</h1>
<p>The growth and deletion behavior of the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> class can be adapted to any specific task. The second template argument of the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> specifies the growth rate. The following growth rates can be selected:</p>
<ul>
<li><a class="el" href="../../d3/d70/structblaze_1_1ConstantGrowth.html" title="Constant growth policy class.The ConstantGrowth policy class implements a constant growth strategy...">ConstantGrowth</a></li>
<li><a class="el" href="../../df/d4f/structblaze_1_1LinearGrowth.html" title="Linear growth policy class.The LinearGrowth policy class implements a linear growth strategy...">LinearGrowth</a></li>
<li><a class="el" href="../../d2/d3f/structblaze_1_1OptimalGrowth.html" title="Optimal growth policy class.The OptimalGrowth policy class implements the optimal growth strategy sug...">OptimalGrowth</a> (the default behavior)</li>
</ul>
<p>The third template argument of the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> specifies the deletion behavior for the case that the pointer vector is destroyed. Note that the deletion behavior has only limited effect on the memory management of the contained resources. For instance, copying a <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> always results in a shallow copy, i.e., the contained resources are not copied/cloned. Therefore the deletion policy should be considered a convenience functionality in the context of a resource managing class. The following policies can be selected:</p>
<ul>
<li><a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html" title="No-delete policy class.">NoDelete</a> : No deletion of the contained pointers (the default behavior).</li>
<li><a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> : Applies <em>delete</em> to all contained pointers.</li>
<li><a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> : Applies <em>delete</em>[] to all contained pointers.<br/>
<br/>
 </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad6b309a0aeb6c2f461091e5bdfaff879"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td>
          <td class="paramname"><em>initCapacity</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard constructor for <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initCapacity</td><td>The initial capacity of the pointer vector.</td></tr>
  </table>
  </dd>
</dl>
<p>The default initial capacity of the pointer vector is specified by the selected growth policy. </p>

</div>
</div>
<a class="anchor" id="a86dccd50824dfd458707a1212230fb09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>The pointer vector to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a278641e787e1719a4cd23b31fc6116ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename D2 , typename G2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T2, D2, G2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion constructor from different <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>The pointer vector to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f16e3b28dbfa62bf9ea4012a254fb3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::~<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor for <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a>. </p>
<p>In the destructor, the selected deletion policy is applied to all elements of the pointer vector. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a373e3df596ff22e48f541728d695faaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigning a range of elements to the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the element range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the element one past the last element of the element range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>Maximum pointer vector length exceeded.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions assigns the elements in the range <img class="formulaInl" alt="$ [first,last) $" src="../../form_164.png"/> to the pointer vector. All elements previously contained in the pointer vector are removed. The assign function runs in linear time. </p>

</div>
</div>
<a class="anchor" id="a64efbbceda1879140518b55975f6887b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2184f6a24202d046a86c192d6340eec">ReferenceType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the last element.</dd></dl>
<p><b>Note:</b> No runtime check is performed if the last element exists! </p>

</div>
</div>
<a class="anchor" id="aba932c23d68ca352bb4df60fb35e9af9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2ad0d9a96cc6fbfb6ad5163627ce75f">ConstReferenceType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the last element.</dd></dl>
<p><b>Note:</b> No runtime check is performed if the last element exists! </p>

</div>
</div>
<a class="anchor" id="a294790094e7d23648dc6aa911af5719b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::BLAZE_TEMPLATE <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt; <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the pointer vector. </p>
<p>Returns an iterator to the first element of type <em>C</em> within the pointer vector.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the beginning of the pointer vector.</dd>
<dd>
Iterator to the first element of type <em>C</em>.</dd></dl>
<p>This function returns an iterator to the first element of type <em>C</em> within in the pointer vector, where <em>C</em> is a type derived from the type <em>T</em> of objects contained in the pointer vector. In case there is no element of type <em>C</em> contained in the vector, an iterator just past the last element of the pointer vector is returned. In combination with the according end function (see example), this iterator allows to iterate over all objects of type <em>C</em> in the range of the pointer vector. The attempt to use this function for types that are not derived from <em>T</em> results in a compile time error.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of class A and the derived type B</span></div>
<div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A { ... };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for non-const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">      ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <span class="keyword">const</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Note:</b> Using the templated versions of <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin()</a> and <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end()</a> to traverse all elements of type <em>C</em> in the element range of the pointer vector is more expensive than using the non-template versions to traverse the entire range of elements. Use this function only if you require a type-specific member of type <em>C</em>. </p>

</div>
</div>
<a class="anchor" id="a0e151c58850cd6dad67229015d304428"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::BLAZE_TEMPLATE <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; C &gt; <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the pointer vector. </p>
<p>Returns an iterator to the first element of type <em>C</em> within the pointer vector.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the beginning of the pointer vector.</dd>
<dd>
Iterator to the first element of type <em>C</em>.</dd></dl>
<p>This function returns an iterator to the first element of type <em>C</em> within in the pointer vector, where <em>C</em> is a type derived from the type <em>T</em> of objects contained in the pointer vector. In case there is no element of type <em>C</em> contained in the vector, an iterator just past the last element of the pointer vector is returned. In combination with the according end function (see example), this iterator allows to iterate over all objects of type <em>C</em> in the range of the pointer vector. The attempt to use this function for types that are not derived from <em>T</em> results in a compile time error.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of class A and the derived type B</span></div>
<div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A { ... };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for non-const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">      ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <span class="keyword">const</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Note:</b> Using the templated versions of <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin()</a> and <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end()</a> to traverse all elements of type <em>C</em> in the element range of the pointer vector is more expensive than using the non-template version to traverse the entire range of elements. Use this function only if you require a type-specific member of type <em>C</em>. </p>

</div>
</div>
<a class="anchor" id="ae908e30bd1379bd2ca03f70afa8e853c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::calcCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>minCapacity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculating the new capacity of the vector based on its growth policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minCapacity</td><td>The minimum necessary capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="a45f6fa7d52a419038ac21bd1381e2957"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the capacity of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="a09ac6183a89157ee9641f3384ab02454"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removing all elements from the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aae5cf1d7228619ce9f7652e52608b93d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::deleteElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a>&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleting an element of the pointer vector according to the deletion policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The element to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a529a8f3db716a9e4e470220b167d403a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::BLAZE_TEMPLATE <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt; <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the pointer vector.</dd>
<dd>
Iterator just past the last element of the pointer vector.</dd></dl>
<p>This function returns an iterator just past the last element of the pointer vector. In combination with the according begin function (see example), this iterator allows to iterate over all objects of type <em>C</em> in the range of the pointer vector. The attempt to use this function for types that are not derived from <em>T</em> results in a compile time error.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of class A and the derived type B</span></div>
<div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A { ... };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for non-const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">      ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <span class="keyword">const</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Note:</b> Using the templated versions of <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin()</a> and <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end()</a> to traverse all elements of type <em>C</em> in the element range of the pointer vector is more expensive than using the non-template versions to traverse the entire range of elements. Use this function only if you require a type-specific member of type <em>C</em>. </p>

</div>
</div>
<a class="anchor" id="a4af85eb75f965d83788f9a92ad2d6918"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::BLAZE_TEMPLATE <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; C &gt; <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the pointer vector.</dd>
<dd>
Iterator just past the last element of the pointer vector.</dd></dl>
<p>This function returns an iterator just past the last element of the pointer vector. In combination with the according begin function (see example), this iterator allows to iterate over all objects of type <em>C</em> in the range of the pointer vector. The attempt to use this function for types that are not derived from <em>T</em> results in a compile time error.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of class A and the derived type B</span></div>
<div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A { ... };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for non-const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">blaze::PtrVector&lt;A&gt;::CastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">      ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of function f for const pointer vectors</span></div>
<div class="line"><span class="keywordtype">void</span> f( <span class="keyword">const</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a>&amp; vector )</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; begin = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a>&lt;B&gt;();</div>
<div class="line">   <a class="code" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">blaze::PtrVector&lt;A&gt;::ConstCastIterator</a>&lt;B&gt; end   = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>&lt;B&gt;();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Loop over all objects of type B contained in the vector</span></div>
<div class="line">   <span class="keywordflow">for</span>( ; begin!=<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end</a>; ++<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin</a> )</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Note:</b> Using the templated versions of <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a294790094e7d23648dc6aa911af5719b" title="Returns an iterator to the beginning of the pointer vector.">begin()</a> and <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a529a8f3db716a9e4e470220b167d403a" title="Returns an iterator just past the last element of the pointer vector.">end()</a> to traverse all elements of type <em>C</em> in the element range of the pointer vector is more expensive than using the non-template version to traverse the entire range of elements. Use this function only if you require a type-specific member of type <em>C</em>. </p>

</div>
</div>
<a class="anchor" id="aebd377147fffa637f4c9427bcc108816"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removing an element from the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element.</dd></dl>
<p>This function erases an element from the pointer vector, i.e. the element is deleted according to the deletion policy of the pointer vector and removed from the vector. Note that in case the deletion policy is <a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html" title="No-delete policy class.">NoDelete</a>, this function is identical to the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a91f7c34a1742abe352d837812a75be30" title="Releasing an element from the pointer vector.">release()</a> function. </p>

</div>
</div>
<a class="anchor" id="a2f88445c7b2e9d4d1938cac9cc2815c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::BLAZE_TEMPLATE <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt; <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removing an element from the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element.</dd></dl>
<p>This function erases an element from the pointer vector, i.e. the element is deleted according to the deletion policy of the pointer vector and removed from the vector. Note that in case the deletion policy is <a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html" title="No-delete policy class.">NoDelete</a>, this function is identical to the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a91f7c34a1742abe352d837812a75be30" title="Releasing an element from the pointer vector.">release()</a> function. </p>

</div>
</div>
<a class="anchor" id="a7e1b26252ae154e945fe20619f8363ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2184f6a24202d046a86c192d6340eec">ReferenceType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the first element.</dd></dl>
<p><b>Note:</b> No runtime check is performed if the first element exists! </p>

</div>
</div>
<a class="anchor" id="af4605d238729a11bfaa20c8f87db0606"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2ad0d9a96cc6fbfb6ad5163627ce75f">ConstReferenceType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the first element.</dd></dl>
<p><b>Note:</b> No runtime check is performed if the first element exists! </p>

</div>
</div>
<a class="anchor" id="adb35e534e969df135a3903fc208f4f85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting an element into the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position before which the element is inserted. </td></tr>
    <tr><td class="paramname">p</td><td>The pointer to be inserted into the pointer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>Maximum pointer vector length exceeded.</td></tr>
  </table>
  </dd>
</dl>
<p>The insert function runs in linear time. Note however that inserting elements into a pointer vector can be a relatively time-intensive operation. </p>

</div>
</div>
<a class="anchor" id="a83aec39b05a11a5c59625e7c89edc273"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting a range of elements into the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position before which the elements are inserted. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first element of the element range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the element one past the last element of the element range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>Maximum pointer vector length exceeded.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions inserts the elements in the range <img class="formulaInl" alt="$ [first,last) $" src="../../form_164.png"/> into the pointer vector. The insert function runs in linear time. Note however that inserting elements into a pointer vector can be a relatively time-intensive operation. </p>

</div>
</div>
<a class="anchor" id="a8e278e2b837aec2bc917e056a5a3b2a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T **const&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting an element into the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position before which the element is inserted. </td></tr>
    <tr><td class="paramname">p</td><td>The pointer to be inserted into the pointer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>Maximum pointer vector length exceeded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a8a10867be87f2c0fe034d236568593"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D , typename G &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting a range of elements into the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position before which the elements are inserted. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to the first element of the element range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the element one past the last element of the element range. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>Maximum pointer vector length exceeded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23ff5cf807e67ac664fddfa470993320"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <em>true</em> if the pointer vector has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the pointer vector is empty, <em>false</em> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="accdeffe5d0765784f7f3de63e011209e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::maxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum possible size of a pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum possible size. </dd></dl>

</div>
</div>
<a class="anchor" id="a53f8a744e2bb5792a7fb0d7c6611ba91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp; <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>The pointer vector to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned pointer vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c92c5bfa94b7e029e2d22253d340594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename D2 , typename G2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp; <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T2, D2, G2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for different <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>The pointer vector to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned pointer vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a183c1b0cd7d6a164f5020b7d291c3ff3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2184f6a24202d046a86c192d6340eec">ReferenceType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the pointer vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..size-1]$" src="../../form_165.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the accessed element.</dd></dl>
<p><b>Note:</b> No runtime check is performed to insure the validity of the access index. </p>

</div>
</div>
<a class="anchor" id="a908f7e8cffd31e3722b124ca3d23595d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ab2ad0d9a96cc6fbfb6ad5163627ce75f">ConstReferenceType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the pointer vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..size-1]$" src="../../form_165.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the accessed element.</dd></dl>
<p><b>Note:</b> No runtime check is performed to insure the validity of the access index. </p>

</div>
</div>
<a class="anchor" id="ae28842d5a0d553c4e5fc955393c79fb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::popBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removing an element from the end of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function removes the element at the end of the pointer vector, i.e. the element is deleted according to the deletion policy and removed from the vector. Note that in case the deletion policy is <a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html" title="No-delete policy class.">NoDelete</a>, this function is identical to the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a1fb0d71621a8f5ee0435ae37badb4ba1" title="Releasing the element at the end of the pointer vector.">releaseBack()</a> function. </p>

</div>
</div>
<a class="anchor" id="aa68516609ff69a9daabfe0b8d7f366b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::pushBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#abe4bb81e62931d3ac84c9c2224acb33c">PointerType</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adding an element to the end of the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pointer to be added to the end of the pointer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>Maximum pointer vector length exceeded.</td></tr>
  </table>
  </dd>
</dl>
<p>The pushBack function runs in constant time. </p>

</div>
</div>
<a class="anchor" id="a91f7c34a1742abe352d837812a75be30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a94e551e3c4ab00997d75a934f7384b35">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releasing an element from the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the released element.</dd></dl>
<p>This function releases an element from the pointer vector, i.e. the element is removed without applying the deletion policy. Therefore the responsibility to delete the element is passed to the function caller. </p>

</div>
</div>
<a class="anchor" id="ad6301a5a0afc59825acba25492f9f7c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::BLAZE_TEMPLATE <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt; <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; C &gt;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releasing an element from the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the released element.</dd></dl>
<p>This function releases an element from the pointer vector, i.e. the element is removed without applying the deletion policy. Therefore the responsibility to delete the element is passed to the function caller. </p>

</div>
</div>
<a class="anchor" id="a1fb0d71621a8f5ee0435ae37badb4ba1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::releaseBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releasing the element at the end of the pointer vector. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function releases the element at the end of the pointer vector, i.e. the element is removed without applying the deletion policy. Therefore the responsibility to delete the element is passed to the function caller. Note that in case the deletion policy is <a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html" title="No-delete policy class.">NoDelete</a>, this function is identical to the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#ae28842d5a0d553c4e5fc955393c79fb1" title="Removing an element from the end of the pointer vector.">popBack()</a> function. </p>

</div>
</div>
<a class="anchor" id="a4024cc0ac03e9b528caddc089bdbf13a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a>&#160;</td>
          <td class="paramname"><em>newCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting the minimum capacity of the pointer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>The new minimum capacity of the pointer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="acf0684110f80cbb87b4ebb48f6a19dd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt;::<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#a8247ecad461e7263bdfc2e64225c00ee">SizeType</a> <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size of the pointer vector. </p>
<p>Returns the total number of objects of type <em>C</em> contained in the pointer vector.</p>
<dl class="section return"><dt>Returns</dt><dd>The current size.</dd>
<dd>
The total number of objects of type <em>C</em>.</dd></dl>
<p>This function calculates the total number of objects of type <em>C</em> within the pointer vector, where <em>C</em> is a type derived from the type <em>T</em> of objects contained in the pointer vector. The attempt to use this function for types that are not derived from <em>T</em> results in a compile time error.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of class A and the derived type B</span></div>
<div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A { ... };</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of a pointer vector for class A</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">blaze::PtrVector&lt;A&gt;</a> AVector;</div>
<div class="line">AVector vector;</div>
<div class="line"></div>
<div class="line">AVector::SizeType total = vector.<a class="code" href="../../d3/ddf/classblaze_1_1PtrVector.html#acf0684110f80cbb87b4ebb48f6a19dd4" title="Returns the current size of the pointer vector.">size</a>();     <span class="comment">// Calculating the total number of pointers</span></div>
<div class="line">AVector::SizeType numB  = vector.size&lt;B&gt;();  <span class="comment">// Calculating the total number of B objects</span></div>
</div><!-- fragment --><p><b>Note:</b> The total number of objects of type <em>C</em> is not cached inside the pointer vector but is calculated each time the function is called. Using the templated version of <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#acf0684110f80cbb87b4ebb48f6a19dd4" title="Returns the current size of the pointer vector.">size()</a> to calculate the total number objects of type <em>C</em> is therefore more expensive than using the non-template version of <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html#acf0684110f80cbb87b4ebb48f6a19dd4" title="Returns the current size of the pointer vector.">size()</a> to get the total number of pointers in the vector! </p>

</div>
</div>
<a class="anchor" id="a04691f829218dd311c3c43e42758af78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector</a>&lt; T, D, G &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two pointer vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>The pointer vector to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a1a85cfcdefb7de579fdef85af6070a67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side cast iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side cast iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators don't point to the same element, <em>false</em> if they do. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a32d809f6e96e4dd7af8179aa71ab2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> and a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side cast iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side constant cast iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators don't point to the same element, <em>false</em> if they do. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8003cfaeca70eabcaaff3d8fd67c388"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> and a <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side constant cast iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side cast iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators don't point to the same element, <em>false</em> if they do. </dd></dl>

</div>
</div>
<a class="anchor" id="a2156409b7b38838b1d340fce347894ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side constant cast iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side constant cast iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators don't point to the same element, <em>false</em> if they do. </dd></dl>

</div>
</div>
<a class="anchor" id="a092d96024f6acb12012dbf0bed95d58d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side cast iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side cast iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators point to the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="acf3cd1257e1e37edf8396822c6ef88eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> and a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side cast iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side constant cast iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators point to the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a37c6b088804103bfca7725f8ca9c0f0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">CastIterator</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> and a <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side constant cast iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side cast iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators point to the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a89e5791d9031005918781bbef21b0159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename D = PtrDelete, typename G = OptimalGrowth&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; L &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">ConstCastIterator</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side constant cast iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side constant cast iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators point to the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/util/<a class="el" href="../../d5/d24/PtrVector_8h_source.html">PtrVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:43 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
