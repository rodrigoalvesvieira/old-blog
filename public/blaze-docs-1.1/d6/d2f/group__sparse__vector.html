<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Sparse Vectors</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sparse Vectors<div class="ingroups"><a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d9/dd2/group__sparse__vector__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd2/group__sparse__vector__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/da9/group__compressed__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html">CompressedVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">blaze::SparseVector&lt; VT, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse vectors.The <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html" title="Base class for sparse vectors.The SparseVector class is a base class for all arbitrarily sized (N-dim...">SparseVector</a> class is a base class for all arbitrarily sized (N-dimensional) sparse vectors. It provides an abstraction from the actual type of the sparse vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d6/d31/structblaze_1_1SparseVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecMultExpr&lt; T1, T2, <br class="typebreak"/>
TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab3fbcd035fcb7ffda672fbc102afb585">blaze::operator*</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab3fbcd035fcb7ffda672fbc102afb585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>).  <a href="#gab3fbcd035fcb7ffda672fbc102afb585"></a><br/></td></tr>
<tr class="separator:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc13ee206a0186ed04d82757fcddbb2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9dc13ee206a0186ed04d82757fcddbb2"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../dc/dce/classSMatSVecMultExpr.html">SMatSVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9dc13ee206a0186ed04d82757fcddbb2">blaze::operator*</a> (const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga9dc13ee206a0186ed04d82757fcddbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_105.png"/>).  <a href="#ga9dc13ee206a0186ed04d82757fcddbb2"></a><br/></td></tr>
<tr class="separator:ga9dc13ee206a0186ed04d82757fcddbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9172e9da5cda16c231c1c62dabeb0b06"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga9172e9da5cda16c231c1c62dabeb0b06"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, MultExprTrait&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9172e9da5cda16c231c1c62dabeb0b06">blaze::operator*</a> (const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga9172e9da5cda16c231c1c62dabeb0b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>).  <a href="#ga9172e9da5cda16c231c1c62dabeb0b06"></a><br/></td></tr>
<tr class="separator:ga9172e9da5cda16c231c1c62dabeb0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/d80/classSVecAbsExpr.html">SVecAbsExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4030f434bb2acdea2622f2ca07df99e6">blaze::abs</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4030f434bb2acdea2622f2ca07df99e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the absolute values of each single element of <em>sv</em>.  <a href="#ga4030f434bb2acdea2622f2ca07df99e6"></a><br/></td></tr>
<tr class="separator:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dbb/classSVecDVecMultExpr.html">SVecDVecMultExpr</a>&lt; T1, T2, <br class="typebreak"/>
TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga931bca871bc8961db7f2a7b5d9892b3c">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>).  <a href="#ga931bca871bc8961db7f2a7b5d9892b3c"></a><br/></td></tr>
<tr class="separator:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/db1/classSVecEvalExpr.html">SVecEvalExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac9a411c9688799b2ef0f334c98f216cf">blaze::eval</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gac9a411c9688799b2ef0f334c98f216cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse vector expression <em>dv</em>.  <a href="#gac9a411c9688799b2ef0f334c98f216cf"></a><br/></td></tr>
<tr class="separator:gac9a411c9688799b2ef0f334c98f216cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga828cdd739516d9e1c08e42a328483d8d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga828cdd739516d9e1c08e42a328483d8d"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T2 &gt;<br class="typebreak"/>
, typename <br class="typebreak"/>
SVecScalarDivExprHelper&lt; T1, <br class="typebreak"/>
T2, TF &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga828cdd739516d9e1c08e42a328483d8d">blaze::operator/</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga828cdd739516d9e1c08e42a328483d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_101.png"/>).  <a href="#ga828cdd739516d9e1c08e42a328483d8d"></a><br/></td></tr>
<tr class="separator:ga828cdd739516d9e1c08e42a328483d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/ddc/classSVecScalarMultExpr.html">SVecScalarMultExpr</a>&lt; VT, <br class="typebreak"/>
typename BaseElementType&lt; VT &gt;<br class="typebreak"/>
::Type, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab6ef1ca2e0a236659aaf0df816b52c52">blaze::operator-</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_102.png"/>).  <a href="#gab6ef1ca2e0a236659aaf0df816b52c52"></a><br/></td></tr>
<tr class="separator:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a13a11aab1762aba19e74a9cea87266"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga2a13a11aab1762aba19e74a9cea87266"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T2 &gt;<br class="typebreak"/>
, typename MultExprTrait&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2a13a11aab1762aba19e74a9cea87266">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga2a13a11aab1762aba19e74a9cea87266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_46.png"/>).  <a href="#ga2a13a11aab1762aba19e74a9cea87266"></a><br/></td></tr>
<tr class="separator:ga2a13a11aab1762aba19e74a9cea87266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T1 &gt;<br class="typebreak"/>
, typename MultExprTrait&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga19736a03fdce17b21867a7d4ce5e4587">blaze::operator*</a> (T1 scalar, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga19736a03fdce17b21867a7d4ce5e4587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_103.png"/>).  <a href="#ga19736a03fdce17b21867a7d4ce5e4587"></a><br/></td></tr>
<tr class="separator:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/df2/classSVecSVecAddExpr.html">SVecSVecAddExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3012773ba555712c006466a901f2b7b6">blaze::operator+</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3012773ba555712c006466a901f2b7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>).  <a href="#ga3012773ba555712c006466a901f2b7b6"></a><br/></td></tr>
<tr class="separator:ga3012773ba555712c006466a901f2b7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/dd7/classSVecSVecMultExpr.html">SVecSVecMultExpr</a>&lt; T1, T2, <br class="typebreak"/>
TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaaccf01f6322bcd426a734b284aa123b8">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaccf01f6322bcd426a734b284aa123b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>).  <a href="#gaaccf01f6322bcd426a734b284aa123b8"></a><br/></td></tr>
<tr class="separator:gaaccf01f6322bcd426a734b284aa123b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/dbf/classSVecSVecSubExpr.html">SVecSVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1a9bad0a58b194a184fa8b9e14618a4f">blaze::operator-</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>).  <a href="#ga1a9bad0a58b194a184fa8b9e14618a4f"></a><br/></td></tr>
<tr class="separator:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad025086deb216a3db59994cd9f141089"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad025086deb216a3db59994cd9f141089"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d2f/classSVecTransExpr.html">SVecTransExpr</a>&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad025086deb216a3db59994cd9f141089">blaze::trans</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gad025086deb216a3db59994cd9f141089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse vector.  <a href="#gad025086deb216a3db59994cd9f141089"></a><br/></td></tr>
<tr class="separator:gad025086deb216a3db59994cd9f141089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38eeea18da3978abfc138b094e984f6d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga38eeea18da3978abfc138b094e984f6d"><td class="memTemplItemLeft" align="right" valign="top">const MultTrait&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga38eeea18da3978abfc138b094e984f6d">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga38eeea18da3978abfc138b094e984f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).  <a href="#ga38eeea18da3978abfc138b094e984f6d"></a><br/></td></tr>
<tr class="separator:ga38eeea18da3978abfc138b094e984f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d1/d8a/classTSMatSVecMultExpr.html">TSMatSVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae59ab01e702dfd082c425a359b7c2bf2">blaze::operator*</a> (const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae59ab01e702dfd082c425a359b7c2bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="#gae59ab01e702dfd082c425a359b7c2bf2"></a><br/></td></tr>
<tr class="separator:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memTemplItemLeft" align="right" valign="top">const MultTrait&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa669e7fdfba70b0a9b33729e7bf329d6">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;lhs, const DenseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).  <a href="#gaa669e7fdfba70b0a9b33729e7bf329d6"></a><br/></td></tr>
<tr class="separator:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfec08873101a5b3600d7c34be7d5c54"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gacfec08873101a5b3600d7c34be7d5c54"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d3/dfb/classTSVecSMatMultExpr.html">TSVecSMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gacfec08873101a5b3600d7c34be7d5c54">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:gacfec08873101a5b3600d7c34be7d5c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="#gacfec08873101a5b3600d7c34be7d5c54"></a><br/></td></tr>
<tr class="separator:gacfec08873101a5b3600d7c34be7d5c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83623e4c5981d7e844e29039ea19cdb3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga83623e4c5981d7e844e29039ea19cdb3"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T2 &gt;<br class="typebreak"/>
, MultExprTrait&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga83623e4c5981d7e844e29039ea19cdb3">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga83623e4c5981d7e844e29039ea19cdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>).  <a href="#ga83623e4c5981d7e844e29039ea19cdb3"></a><br/></td></tr>
<tr class="separator:ga83623e4c5981d7e844e29039ea19cdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memTemplItemLeft" align="right" valign="top">const MultTrait&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga75acb12c5e42f8164aeb6c1272a77580">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga75acb12c5e42f8164aeb6c1272a77580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).  <a href="#ga75acb12c5e42f8164aeb6c1272a77580"></a><br/></td></tr>
<tr class="separator:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae781cf418b2fb59650e1480a9a672114"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae781cf418b2fb59650e1480a9a672114"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d0/de8/classTSVecTSMatMultExpr.html">TSVecTSMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae781cf418b2fb59650e1480a9a672114">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:gae781cf418b2fb59650e1480a9a672114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="#gae781cf418b2fb59650e1480a9a672114"></a><br/></td></tr>
<tr class="separator:gae781cf418b2fb59650e1480a9a672114"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVector operators</h2></td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">blaze::operator==</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse vectors.  <a href="#ga3abacbc4a4ecdb439384f1ce2ae38246"></a><br/></td></tr>
<tr class="separator:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">blaze::operator!=</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse vectors.  <a href="#ga47bd825d8a1516cf16134c4dc9ac918a"></a><br/></td></tr>
<tr class="separator:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4030f434bb2acdea2622f2ca07df99e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../de/d80/classSVecAbsExpr.html">SVecAbsExpr</a>&lt;VT,TF&gt; blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the absolute values of each single element of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The integral sparse input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of each single element of <em>sv</em>.</dd></dl>
<p>The <em>abs</em> function calculates the absolute value of each element of the sparse input vector <em>sv</em>. The operator returns an expression representing this operation.<br/>
 The following example demonstrates the use of the <em>abs</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gac9a411c9688799b2ef0f334c98f216cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/db1/classSVecEvalExpr.html">SVecEvalExpr</a>&lt;VT,TF&gt; blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given sparse vector expression <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse vector.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given sparse vector expression <em>sv</em>. The operator returns an expression representing this operation.<br/>
 The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6" title="Forces the evaluation of the given dense matrix expression dm.">eval</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga47bd825d8a1516cf16134c4dc9ac918a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75acb12c5e42f8164aeb6c1272a77580"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MultTrait&lt;typename T1::ElementType,typename T2::ElementType&gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two sparse vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,columnVector&gt;</a> a, b;</div>
<div class="line"><a class="code" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5" title="Floating point data type of the Blaze library.This type definition offers the possibility to switch t...">blaze::real</a> res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72" title="Calculation of the transpose of the given dense matrix.">trans</a>(a) * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaa669e7fdfba70b0a9b33729e7bf329d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MultTrait&lt;typename T1::ElementType,typename T2::ElementType&gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,rowVector&gt;</a> a;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> b;</div>
<div class="line"><a class="code" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5" title="Floating point data type of the Blaze library.This type definition offers the possibility to switch t...">blaze::real</a> res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = a * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga38eeea18da3978abfc138b094e984f6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MultTrait&lt;typename T1::ElementType,typename T2::ElementType&gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,rowVector&gt;</a> a;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,columnVector&gt;</a> b;</div>
<div class="line"><a class="code" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5" title="Floating point data type of the Blaze library.This type definition offers the possibility to switch t...">blaze::real</a> res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = a * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaaccf01f6322bcd426a734b284aa123b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d6/dd7/classSVecSVecMultExpr.html">SVecSVecMultExpr</a>&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gacfec08873101a5b3600d7c34be7d5c54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T2&gt;, <a class="el" href="../../d3/dfb/classTSVecSMatMultExpr.html">TSVecSMatMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = x * A;</div>
</div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse vector type <em>T1</em> and the sparse matrix type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gae59ab01e702dfd082c425a359b7c2bf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, <a class="el" href="../../d1/d8a/classTSMatSVecMultExpr.html">TSMatSVecMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices.">blaze::columnMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga83623e4c5981d7e844e29039ea19cdb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T2&gt;, MultExprTrait&lt;T1,T2&gt; &gt;::Type::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side sparse matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a sparse vector and a sparse matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_109.png"/>. </p>

</div>
</div>
<a class="anchor" id="ga931bca871bc8961db7f2a7b5d9892b3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/dbb/classSVecDVecMultExpr.html">SVecDVecMultExpr</a>&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, c;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gab3fbcd035fcb7ffda672fbc102afb585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecMultExpr&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga2a13a11aab1762aba19e74a9cea87266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T2&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_46.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a sparse vector and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = a * 1.25;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a class="anchor" id="ga19736a03fdce17b21867a7d4ce5e4587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T1&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_103.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = 1.25 * a;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1</em> and <em>T2::ElementType</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a class="anchor" id="gae781cf418b2fb59650e1480a9a672114"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T2&gt;, <a class="el" href="../../d0/de8/classTSVecTSMatMultExpr.html">TSVecTSMatMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices.">blaze::columnMajor</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = x * A;</div>
</div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse vector type <em>T1</em> and the sparse matrix type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga9dc13ee206a0186ed04d82757fcddbb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, <a class="el" href="../../dc/dce/classSMatSVecMultExpr.html">SMatSVecMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_105.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major sparse matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga9172e9da5cda16c231c1c62dabeb0b06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T1&gt;, MultExprTrait&lt;T1,T2&gt; &gt;::Type::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix-matrix multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a sparse matrix-matrix multiplication expression and a sparse vector. It restructures the expression <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}=A*(B*\vec{x}) $" src="../../form_92.png"/>. </p>

</div>
</div>
<a class="anchor" id="ga3012773ba555712c006466a901f2b7b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d6/df2/classSVecSVecAddExpr.html">SVecSVecAddExpr</a>&lt;T1,T2,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a + b;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class.">AddTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga1a9bad0a58b194a184fa8b9e14618a4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../db/dbf/classSVecSVecSubExpr.html">SVecSVecSubExpr</a>&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class.">SubTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gab6ef1ca2e0a236659aaf0df816b52c52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/ddc/classSVecScalarMultExpr.html">SVecScalarMultExpr</a>&lt;VT,typename BaseElementType&lt;VT&gt;::Type,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_102.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the vector.</dd></dl>
<p>This operator represents the negation of a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = -a;</div>
</div><!-- fragment --><p>The operator returns an expression representing the negation of the given sparse vector. </p>

</div>
</div>
<a class="anchor" id="ga828cdd739516d9e1c08e42a328483d8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T2&gt;, typename SVecScalarDivExprHelper&lt;T1,T2,TF&gt;::Type &gt;::Type blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_101.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the division of a sparse vector by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = a / 0.24;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type.</p>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="ga3abacbc4a4ecdb439384f1ce2ae38246"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gad025086deb216a3db59994cd9f141089"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/d2f/classSVecTransExpr.html">SVecTransExpr</a>&lt;VT,!TF&gt; blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the sparse vector.</dd></dl>
<p>This function returns an expression representing the transpose of the given sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,columnVector&gt;</a> a;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,rowVector&gt;</a> b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72" title="Calculation of the transpose of the given dense matrix.">trans</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:40 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
