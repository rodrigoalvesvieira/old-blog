<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>blaze Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="../../namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">blaze Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace of the Blaze C++ math library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d7/d22/namespaceblaze_1_1logging"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d22/namespaceblaze_1_1logging.html">logging</a></td></tr>
<tr class="memdesc:d7/d22/namespaceblaze_1_1logging"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the logging module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d09/namespaceblaze_1_1solvers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d09/namespaceblaze_1_1solvers.html">solvers</a></td></tr>
<tr class="memdesc:dc/d09/namespaceblaze_1_1solvers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the solvers module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/d1b/namespaceblaze_1_1threadpool"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d1b/namespaceblaze_1_1threadpool.html">threadpool</a></td></tr>
<tr class="memdesc:d5/d1b/namespaceblaze_1_1threadpool"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the threadpool module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/dc7/namespaceblaze_1_1timing"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc7/namespaceblaze_1_1timing.html">timing</a></td></tr>
<tr class="memdesc:d7/dc7/namespaceblaze_1_1timing"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the time measurement module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative computation accuracy for floating point data types.The <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative computation accuracy of the Blaze library for any floating point data type. In order to assign a negative accuracy value, the <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../da/d32/classblaze_1_1NegativeAccuracy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> accuracy for floating point data types.The <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the computation accuracy of the Blaze library for any floating point data type. In order to assign an accuracy value, the <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br/>
 In order to handle accuracy values conveniently, the global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance <a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> is provided, which can be used wherever a floating point data value is required.  <a href="../../d6/d75/classblaze_1_1Accuracy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a dynamic <img class="formulaInl" alt="$ M \times N $" src="../../form_18.png"/> matrix.The <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a> class template is the representation of an arbitrary sized matrix with <img class="formulaInl" alt="$ M \cdot N $" src="../../form_3.png"/> dynamically allocated elements of arbitrary type. The type of the elements and the storage order of the matrix can be specified via the two template parameters:  <a href="../../de/d1e/classblaze_1_1DynamicMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of an arbitrary sized vector.The <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">DynamicVector</a> class template is the representation of an arbitrary sized vector with dynamically allocated elements of arbitrary type. The type of the elements and the transpose flag of the vector can be specified via the two template parameters:  <a href="../../da/d9e/classblaze_1_1DynamicVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a fixed-sized matrix.The <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a> class template is the representation of a fixed-size matrix with statically allocated elements of arbitrary type. The type of the elements, the number of rows and columns and the storage order of the matrix can be specified via the four template parameters:  <a href="../../d3/dd3/classblaze_1_1StaticMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a fixed-sized vector.The <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> class template is the representation of a fixed-size vector with statically allocated elements of arbitrary type. The type of the elements, the number of elements and the transpose flag of the vector can be specified via the three template parameters:  <a href="../../d9/d3c/classblaze_1_1StaticVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative epsilon value for floating point data types.The <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative smallest difference between two values of any floating point data type. In order to assign a negative epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../d9/d70/classblaze_1_1NegativeEpsilon.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical epsilon value for floating point data types.The <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the smallest difference between two values of any floating point data type. In order to assign an epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br/>
 In order to handle epsilon values conveniently, the global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance <a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> is provided, which can be used wherever a floating point data type is required.  <a href="../../dd/d28/classblaze_1_1Epsilon.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html">Computation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all compute expression templates.The <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> class serves as a tag for all computational expression templates. All classes, that represent a mathematical computation (addition, subtraction, multiplication, division, absolute value calculation, ...) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as computational expression template. Only in case a class is derived from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class, the <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html" title="Compile time check whether the given type is a computational expression template.This type trait clas...">IsComputation</a> type trait recognizes the class as valid computational expression template.  <a href="../../de/dd5/structblaze_1_1Computation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense matrices.The <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html" title="Base class for dense matrices.The DenseMatrix class is a base class for all dense matrix classes...">DenseMatrix</a> class is a base class for all dense matrix classes. It provides an abstraction from the actual type of the dense matrix, but enables a conversion back to this type via the <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> base class.  <a href="../../d0/d89/structblaze_1_1DenseMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for N-dimensional dense vectors.The <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html" title="Base class for N-dimensional dense vectors.The DenseVector class is a base class for all arbitrarily ...">DenseVector</a> class is a base class for all arbitrarily sized (N-dimensional) dense vectors. It provides an abstraction from the actual type of the dense vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d1/db2/structblaze_1_1DenseVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d9e/classblaze_1_1DMatAbsExpr.html">DMatAbsExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the dense matrix <a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs()</a> function.The <a class="el" href="../../d5/d9e/classblaze_1_1DMatAbsExpr.html" title="Expression object for the dense matrix abs() function.The DMatAbsExpr class represents the compile ti...">DMatAbsExpr</a> class represents the compile time expression for the calculation of the absolute value of each element of a dense matrix via the <a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs()</a> function.  <a href="../../d5/d9e/classblaze_1_1DMatAbsExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html">DMatDMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-dense matrix additions.The <a class="el" href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html" title="Expression object for dense matrix-dense matrix additions.The DMatDMatAddExpr class represents the co...">DMatDMatAddExpr</a> class represents the compile time expression for additions between dense matrices with identical storage order.  <a href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html">DMatDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-dense matrix multiplications.The <a class="el" href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html" title="Expression object for dense matrix-dense matrix multiplications.The DMatDMatMultExpr class represents...">DMatDMatMultExpr</a> class represents the compile time expression for multiplications between row-major dense matrices.  <a href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html">DMatDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-dense matrix subtractions.The <a class="el" href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html" title="Expression object for dense matrix-dense matrix subtractions.The DMatDMatSubExpr class represents the...">DMatDMatSubExpr</a> class represents the compile time expression for subtractions between dense matrices with identical storage order.  <a href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dce/classblaze_1_1DMatDVecMultExpr.html">DMatDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-dense vector multiplications.The <a class="el" href="../../df/dce/classblaze_1_1DMatDVecMultExpr.html" title="Expression object for dense matrix-dense vector multiplications.The DMatDVecMultExpr class represents...">DMatDVecMultExpr</a> class represents the compile time expression for multiplications between row-major dense matrices and dense vectors.  <a href="../../df/dce/classblaze_1_1DMatDVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/classblaze_1_1DMatEvalExpr.html">DMatEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced evaluation of dense matrices.The <a class="el" href="../../db/d9a/classblaze_1_1DMatEvalExpr.html" title="Expression object for the forced evaluation of dense matrices.The DMatEvalExpr class represents the c...">DMatEvalExpr</a> class represents the compile time expression for the forced evaluation of a dense matrix.  <a href="../../db/d9a/classblaze_1_1DMatEvalExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da1/structblaze_1_1DMatScalarDivExprHelper.html">DMatScalarDivExprHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for divisions of a dense matrix by a scalar.The <a class="el" href="../../d1/da1/structblaze_1_1DMatScalarDivExprHelper.html" title="Helper class for divisions of a dense matrix by a scalar.The DMatScalarDivExprHelper class is an auxi...">DMatScalarDivExprHelper</a> class is an auxiliary class to define the return type of the division between a dense matrix and a scalar value.  <a href="../../d1/da1/structblaze_1_1DMatScalarDivExprHelper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db1/classblaze_1_1DMatScalarDivExpr.html">DMatScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for divisions of a dense matrix by a scalar.The <a class="el" href="../../db/db1/classblaze_1_1DMatScalarDivExpr.html" title="Expression object for divisions of a dense matrix by a scalar.The DMatScalarDivExpr class represents ...">DMatScalarDivExpr</a> class represents the compile time expression for divisions of dense matrices and by scalar values.  <a href="../../db/db1/classblaze_1_1DMatScalarDivExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html">DMatScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-scalar multiplications.The <a class="el" href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html" title="Expression object for dense matrix-scalar multiplications.The DMatScalarMultExpr class represents the...">DMatScalarMultExpr</a> class represents the compile time expression for multiplications between a dense matrix and a scalar value.  <a href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix additions.The <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html" title="Expression object for dense matrix-sparse matrix additions.The DMatSMatAddExpr class represents the c...">DMatSMatAddExpr</a> class represents the compile time expression for additions between a dense matrix and a sparse matrix with identical storage order.  <a href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html">DMatSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix multiplications.The <a class="el" href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html" title="Expression object for dense matrix-sparse matrix multiplications.The DMatSMatMultExpr class represent...">DMatSMatMultExpr</a> class represents the compile time expression for multiplications between a row-major dense matrix and a row-major sparse matrix.  <a href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html">DMatSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix subtractions.The <a class="el" href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html" title="Expression object for dense matrix-sparse matrix subtractions.The DMatSMatSubExpr class represents th...">DMatSMatSubExpr</a> class represents the compile time expression for subtractions between a dense matrix and a sparse matrix with identical storage order.  <a href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d34/classblaze_1_1DMatSVecMultExpr.html">DMatSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse vector multiplications.The <a class="el" href="../../d7/d34/classblaze_1_1DMatSVecMultExpr.html" title="Expression object for dense matrix-sparse vector multiplications.The DMatSVecMultExpr class represent...">DMatSVecMultExpr</a> class represents the compile time expression for multiplications between row-major dense matrices and sparse vectors.  <a href="../../d7/d34/classblaze_1_1DMatSVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose dense matrix additions.The <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html" title="Expression object for dense matrix-transpose dense matrix additions.The DMatTDMatAddExpr class repres...">DMatTDMatAddExpr</a> class represents the compile time expression for additions between a row-major dense matrix and column-major dense matrix.  <a href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html">DMatTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose dense matrix multiplications.The <a class="el" href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html" title="Expression object for dense matrix-transpose dense matrix multiplications.The DMatTDMatMultExpr class...">DMatTDMatMultExpr</a> class represents the compile time expression for multiplications between a row-major dense matrix and a column-major dense matrix.  <a href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose dense matrix subtractions.The <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html" title="Expression object for dense matrix-transpose dense matrix subtractions.The DMatTDMatSubExpr class rep...">DMatTDMatSubExpr</a> class represents the compile time expression for subtractions between a row-major dense matrix and a column-major dense matrix.  <a href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d86/classblaze_1_1DMatTransExpr.html">DMatTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix transpositions.The <a class="el" href="../../d1/d86/classblaze_1_1DMatTransExpr.html" title="Expression object for dense matrix transpositions.The DMatTransExpr class represents the compile time...">DMatTransExpr</a> class represents the compile time expression for transpositions of dense matrices.  <a href="../../d1/d86/classblaze_1_1DMatTransExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d12/classblaze_1_1DMatTransposer.html">DMatTransposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a dense matrix.The <a class="el" href="../../d9/d12/classblaze_1_1DMatTransposer.html" title="Expression object for the transposition of a dense matrix.The DMatTransposer class is a wrapper objec...">DMatTransposer</a> class is a wrapper object for the temporary transposition of a dense matrix.  <a href="../../d9/d12/classblaze_1_1DMatTransposer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix additions.The <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html" title="Expression object for dense matrix-sparse matrix additions.The DMatTSMatAddExpr class represents the ...">DMatTSMatAddExpr</a> class represents the compile time expression for additions between a row-major dense matrix and a column-major sparse matrix.  <a href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html">DMatTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose sparse matrix multiplications.The <a class="el" href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html" title="Expression object for dense matrix-transpose sparse matrix multiplications.The DMatTSMatMultExpr clas...">DMatTSMatMultExpr</a> class represents the compile time expression for multiplications between a row-major dense matrix and a column-major sparse matrix.  <a href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html">DMatTSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-transpose sparse matrix subtractions.The <a class="el" href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html" title="Expression object for dense matrix-transpose sparse matrix subtractions.The DMatTSMatSubExpr class re...">DMatTSMatSubExpr</a> class represents the compile time expression for subtractions between a row-major dense matrix and a column-major sparse matrix.  <a href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc0/classblaze_1_1DVecAbsExpr.html">DVecAbsExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the dense vector <a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs()</a> function.The <a class="el" href="../../dd/dc0/classblaze_1_1DVecAbsExpr.html" title="Expression object for the dense vector abs() function.The DVecAbsExpr class represents the compile ti...">DVecAbsExpr</a> class represents the compile time expression for the calculation of the absolute value of each element of a dense vector via the <a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs()</a> function.  <a href="../../dd/dc0/classblaze_1_1DVecAbsExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc4/classblaze_1_1DVecDVecAddExpr.html">DVecDVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector additions.The <a class="el" href="../../db/dc4/classblaze_1_1DVecDVecAddExpr.html" title="Expression object for dense vector-dense vector additions.The DVecDVecAddExpr class represents the co...">DVecDVecAddExpr</a> class represents the compile time expression for additions between dense vectors.  <a href="../../db/dc4/classblaze_1_1DVecDVecAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html">DVecDVecCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector cross products.The <a class="el" href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html" title="Expression object for dense vector-dense vector cross products.The DVecDVecCrossExpr class represents...">DVecDVecCrossExpr</a> class represents the compile time expression for cross products between dense vectors.  <a href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d76/classblaze_1_1DVecDVecMultExpr.html">DVecDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector multiplications.The <a class="el" href="../../d0/d76/classblaze_1_1DVecDVecMultExpr.html" title="Expression object for dense vector-dense vector multiplications.The DVecDVecMultExpr class represents...">DVecDVecMultExpr</a> class represents the compile time expression for componentwise multiplications between dense vectors.  <a href="../../d0/d76/classblaze_1_1DVecDVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d79/classblaze_1_1DVecDVecSubExpr.html">DVecDVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-dense vector subtractions.The <a class="el" href="../../de/d79/classblaze_1_1DVecDVecSubExpr.html" title="Expression object for dense vector-dense vector subtractions.The DVecDVecSubExpr class represents the...">DVecDVecSubExpr</a> class represents the compile time expression for subtractions between dense vectors.  <a href="../../de/d79/classblaze_1_1DVecDVecSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d94/classblaze_1_1DVecEvalExpr.html">DVecEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced evaluation of dense vectors.The <a class="el" href="../../d2/d94/classblaze_1_1DVecEvalExpr.html" title="Expression object for the forced evaluation of dense vectors.The DVecEvalExpr class represents the co...">DVecEvalExpr</a> class represents the compile time expression for the forced evaluation of a dense vector.  <a href="../../d2/d94/classblaze_1_1DVecEvalExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d64/structblaze_1_1DVecScalarDivExprHelper.html">DVecScalarDivExprHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for divisions of a dense vector by a scalar.The <a class="el" href="../../d9/d64/structblaze_1_1DVecScalarDivExprHelper.html" title="Helper class for divisions of a dense vector by a scalar.The DVecScalarDivExprHelper class is an auxi...">DVecScalarDivExprHelper</a> class is an auxiliary class to define the return type of the division between a dense vector and a scalar value.  <a href="../../d9/d64/structblaze_1_1DVecScalarDivExprHelper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db9/classblaze_1_1DVecScalarDivExpr.html">DVecScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for divisions of a dense vector by a scalar.The <a class="el" href="../../d5/db9/classblaze_1_1DVecScalarDivExpr.html" title="Expression object for divisions of a dense vector by a scalar.The DVecScalarDivExpr class represents ...">DVecScalarDivExpr</a> class represents the compile time expression for divisions of dense vectors by scalar values.  <a href="../../d5/db9/classblaze_1_1DVecScalarDivExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html">DVecScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-scalar multiplications.The <a class="el" href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html" title="Expression object for dense vector-scalar multiplications.The DVecScalarMultExpr class represents the...">DVecScalarMultExpr</a> class represents the compile time expression for multiplications between a dense vector and a scalar value.  <a href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html">DVecSVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector additions.The <a class="el" href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html" title="Expression object for dense vector-sparse vector additions.The DVecSVecAddExpr class represents the c...">DVecSVecAddExpr</a> class represents the compile time expression for additions between a dense vector and a sparse vector.  <a href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html">DVecSVecCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector cross products.The <a class="el" href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html" title="Expression object for dense vector-sparse vector cross products.The DVecSVecCrossExpr class represent...">DVecSVecCrossExpr</a> class represents the compile time expression for cross products between a dense vector and a sparse vector.  <a href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html">DVecSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector multiplications.The <a class="el" href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html" title="Expression object for dense vector-sparse vector multiplications.The DVecSVecMultExpr class represent...">DVecSVecMultExpr</a> class represents the compile time expression for componentwise multiplications between a dense vector and a sparse vector.  <a href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de0/classblaze_1_1DVecSVecSubExpr.html">DVecSVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector subtractions.The <a class="el" href="../../df/de0/classblaze_1_1DVecSVecSubExpr.html" title="Expression object for dense vector-sparse vector subtractions.The DVecSVecSubExpr class represents th...">DVecSVecSubExpr</a> class represents the compile time expression for subtractions between a dense vector and a sparse vector.  <a href="../../df/de0/classblaze_1_1DVecSVecSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html">DVecTDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for outer products between two dense vectors.The <a class="el" href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html" title="Expression object for outer products between two dense vectors.The DVecTDVecMultExpr class represents...">DVecTDVecMultExpr</a> class represents the compile time expression for outer products between dense vectors.  <a href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db6/classblaze_1_1DVecTransExpr.html">DVecTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector transpositions.The <a class="el" href="../../db/db6/classblaze_1_1DVecTransExpr.html" title="Expression object for dense vector transpositions.The DVecTransExpr class represents the compile time...">DVecTransExpr</a> class represents the compile time expression for transpositions of dense vectors.  <a href="../../db/db6/classblaze_1_1DVecTransExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html">DVecTransposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a dense vector.The <a class="el" href="../../d0/d30/classblaze_1_1DVecTransposer.html" title="Expression object for the transposition of a dense vector.The DVecTransposer class is a wrapper objec...">DVecTransposer</a> class is a wrapper object for the temporary transposition of a dense vector.  <a href="../../d0/d30/classblaze_1_1DVecTransposer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html">DVecTSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense vector-sparse vector outer products.The <a class="el" href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html" title="Expression object for dense vector-sparse vector outer products.The DVecTSVecMultExpr class represent...">DVecTSVecMultExpr</a> class represents the compile time expression for dense vector-sparse vector outer products.  <a href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all expression templates.The <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> class is the base class for all expression templates. All classes, that represent a mathematical operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as expression template. Only in case a class is derived from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class, the <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html" title="Compile time check whether the given type is an expression template.This type trait class tests wheth...">IsExpression</a> type trait recognizes the class as valid expression template.  <a href="../../d5/d2e/structblaze_1_1Expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matrices.The <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> class is a base class for all dense and sparse matrix classes within the Blaze library. It provides an abstraction from the actual type of the matrix, but enables a conversion back to this type via the 'Curiously Recurring Template Pattern' (CRTP).  <a href="../../d0/d5c/structblaze_1_1Matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d38/classblaze_1_1SMatAbsExpr.html">SMatAbsExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the sparse matrix <a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs()</a> function.The <a class="el" href="../../dc/d38/classblaze_1_1SMatAbsExpr.html" title="Expression object for the sparse matrix abs() function.The SMatAbsExpr class represents the compile t...">SMatAbsExpr</a> class represents the compile time expression for the calculation of the absolute value of each element of a sparse matrix via the <a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs()</a> function.  <a href="../../dc/d38/classblaze_1_1SMatAbsExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html">SMatDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-dense matrix multiplications.The <a class="el" href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html" title="Expression object for sparse matrix-dense matrix multiplications.The SMatDMatMultExpr class represent...">SMatDMatMultExpr</a> class represents the compile time expression for multiplications between a row-major sparse matrix and a row-major dense matrix.  <a href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html">SMatDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-dense matrix subtractions.The <a class="el" href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html" title="Expression object for sparse matrix-dense matrix subtractions.The SMatDMatSubExpr class represents th...">SMatDMatSubExpr</a> class represents the compile time expression for subtractions between a sparse matrix and a dense matrix with identical storage order.  <a href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d53/classblaze_1_1SMatDVecMultExpr.html">SMatDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-dense vector multiplications.The <a class="el" href="../../d5/d53/classblaze_1_1SMatDVecMultExpr.html" title="Expression object for sparse matrix-dense vector multiplications.The SMatDVecMultExpr class represent...">SMatDVecMultExpr</a> class represents the compile time expression for multiplications between row-major sparse matrices and dense vectors.  <a href="../../d5/d53/classblaze_1_1SMatDVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da4/classblaze_1_1SMatEvalExpr.html">SMatEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced evaluation of sparse matrices.The <a class="el" href="../../df/da4/classblaze_1_1SMatEvalExpr.html" title="Expression object for the forced evaluation of sparse matrices.The SMatEvalExpr class represents the ...">SMatEvalExpr</a> class represents the compile time expression for the forced evaluation of a sparse matrix.  <a href="../../df/da4/classblaze_1_1SMatEvalExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d94/structblaze_1_1SMatScalarDivExprHelper.html">SMatScalarDivExprHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for divisions of a sparse matrix by a scalar.The <a class="el" href="../../d4/d94/structblaze_1_1SMatScalarDivExprHelper.html" title="Helper class for divisions of a sparse matrix by a scalar.The SMatScalarDivExprHelper class is an aux...">SMatScalarDivExprHelper</a> class is an auxiliary class to define the return type of the division between a sparse matrix and a scalar value.  <a href="../../d4/d94/structblaze_1_1SMatScalarDivExprHelper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da4/classblaze_1_1SMatScalarDivExpr.html">SMatScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-scalar divisions.The SMatScalarMult class represents the compile time expression for divisions between a sparse matrix and a scalar value.  <a href="../../df/da4/classblaze_1_1SMatScalarDivExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6e/classblaze_1_1SMatScalarMultExpr.html">SMatScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-scalar multiplications.The SMatScalarMult class represents the compile time expression for multiplications between a sparse matrix and a scalar value.  <a href="../../db/d6e/classblaze_1_1SMatScalarMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html">SMatSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse matrix additions.The <a class="el" href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html" title="Expression object for sparse matrix-sparse matrix additions.The SMatSMatAddExpr class represents the ...">SMatSMatAddExpr</a> class represents the compile time expression for additions between two row-major sparse matrices.  <a href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html">SMatSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse matrix multiplications.The <a class="el" href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html" title="Expression object for sparse matrix-sparse matrix multiplications.The SMatSMatMultExpr class represen...">SMatSMatMultExpr</a> class represents the compile time expression for multiplications between row-major sparse matrices.  <a href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html">SMatSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse matrix subtractions.The <a class="el" href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html" title="Expression object for sparse matrix-sparse matrix subtractions.The SMatSMatSubExpr class represents t...">SMatSMatSubExpr</a> class represents the compile time expression for subtractions between sparse matrices.  <a href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html">SMatSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse vector multiplications.The <a class="el" href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html" title="Expression object for sparse matrix-sparse vector multiplications.The SMatSVecMultExpr class represen...">SMatSVecMultExpr</a> class represents the compile time expression for multiplications between row-major sparse matrices and sparse vectors.  <a href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html">SMatTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose dense matrix multiplications.The <a class="el" href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html" title="Expression object for sparse matrix-transpose dense matrix multiplications.The SMatTDMatMultExpr clas...">SMatTDMatMultExpr</a> class represents the compile time expression for multiplications between a row-major sparse matrix and a column-major dense matrix.  <a href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html">SMatTDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose dense matrix subtractions.The <a class="el" href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html" title="Expression object for sparse matrix-transpose dense matrix subtractions.The SMatTDMatSubExpr class re...">SMatTDMatSubExpr</a> class represents the compile time expression for subtractions between a row-major sparse matrix and a column-major dense matrix.  <a href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d09/classblaze_1_1SMatTransExpr.html">SMatTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix transpositions.The <a class="el" href="../../da/d09/classblaze_1_1SMatTransExpr.html" title="Expression object for sparse matrix transpositions.The SMatTransExpr class represents the compile tim...">SMatTransExpr</a> class represents the compile time expression for transpositions of sparse matrices.  <a href="../../da/d09/classblaze_1_1SMatTransExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dbd/classblaze_1_1SMatTransposer.html">SMatTransposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a sparse matrix.The <a class="el" href="../../de/dbd/classblaze_1_1SMatTransposer.html" title="Expression object for the transposition of a sparse matrix.The SMatTransposer class is a wrapper obje...">SMatTransposer</a> class is a wrapper object for the temporary transposition of a sparse matrix.  <a href="../../de/dbd/classblaze_1_1SMatTransposer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose sparse matrix additions.The <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html" title="Expression object for sparse matrix-transpose sparse matrix additions.The SMatTSMatAddExpr class repr...">SMatTSMatAddExpr</a> class represents the compile time expression for additions between a row-major sparse matrix and a column-major sparse matrix.  <a href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html">SMatTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose sparse matrix multiplications.The <a class="el" href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html" title="Expression object for sparse matrix-transpose sparse matrix multiplications.The SMatTSMatMultExpr cla...">SMatTSMatMultExpr</a> class represents the compile time expression for multiplications between a row-major and a column-major sparse matrix.  <a href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html">SMatTSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-transpose sparse matrix subtractions.The <a class="el" href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html" title="Expression object for sparse matrix-transpose sparse matrix subtractions.The SMatTSMatSubExpr class r...">SMatTSMatSubExpr</a> class represents the compile time expression for subtractions between a row-major sparse matrix and a column-major sparse matrix.  <a href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse matrices.The <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html" title="Base class for sparse matrices.The SparseMatrix class is a base class for all sparse matrix classes...">SparseMatrix</a> class is a base class for all sparse matrix classes. It provides an abstraction from the actual type of the sparse matrix, but enables a conversion back to this type via the <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> base class.  <a href="../../d7/d5d/structblaze_1_1SparseMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse vectors.The <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html" title="Base class for sparse vectors.The SparseVector class is a base class for all arbitrarily sized (N-dim...">SparseVector</a> class is a base class for all arbitrarily sized (N-dimensional) sparse vectors. It provides an abstraction from the actual type of the sparse vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d6/d31/structblaze_1_1SparseVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d50/classblaze_1_1SVecAbsExpr.html">SVecAbsExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the sparse vector <a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs()</a> function.The <a class="el" href="../../d8/d50/classblaze_1_1SVecAbsExpr.html" title="Expression object for the sparse vector abs() function.The SVecAbsExpr class represents the compile t...">SVecAbsExpr</a> class represents the compile time expression for the calculation of the absolute value of each element of a sparse vector via the <a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs()</a> function.  <a href="../../d8/d50/classblaze_1_1SVecAbsExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html">SVecDVecCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector cross products.The <a class="el" href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html" title="Expression object for sparse vector-dense vector cross products.The SVecDVecCrossExpr class represent...">SVecDVecCrossExpr</a> class represents the compile time expression for cross products between a sparse vector and a dense vector.  <a href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html">SVecDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector multiplications.The <a class="el" href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html" title="Expression object for sparse vector-dense vector multiplications.The SVecDVecMultExpr class represent...">SVecDVecMultExpr</a> class represents the compile time expression for componentwise multiplications between a sparse vector and a dense vector.  <a href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d09/classblaze_1_1SVecDVecSubExpr.html">SVecDVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector subtractions.The <a class="el" href="../../d8/d09/classblaze_1_1SVecDVecSubExpr.html" title="Expression object for sparse vector-dense vector subtractions.The SVecDVecSubExpr class represents th...">SVecDVecSubExpr</a> class represents the compile time expression for subtractions between a sparse vector and a dense vector.  <a href="../../d8/d09/classblaze_1_1SVecDVecSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d39/classblaze_1_1SVecEvalExpr.html">SVecEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the forced evaluation of sparse vectors.The <a class="el" href="../../d7/d39/classblaze_1_1SVecEvalExpr.html" title="Expression object for the forced evaluation of sparse vectors.The SVecEvalExpr class represents the c...">SVecEvalExpr</a> class represents the compile time expression for the forced evaluation of a sparse vector.  <a href="../../d7/d39/classblaze_1_1SVecEvalExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d58/structblaze_1_1SVecScalarDivExprHelper.html">SVecScalarDivExprHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for divisions of a sparse vector by a scalar.The <a class="el" href="../../d5/d58/structblaze_1_1SVecScalarDivExprHelper.html" title="Helper class for divisions of a sparse vector by a scalar.The SVecScalarDivExprHelper class is an aux...">SVecScalarDivExprHelper</a> class is an auxiliary class to define the return type of the division between a sparse vector and a scalar value.  <a href="../../d5/d58/structblaze_1_1SVecScalarDivExprHelper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d8f/classblaze_1_1SVecScalarDivExpr.html">SVecScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for divisions of a sparse vector by a scalar.The <a class="el" href="../../d7/d8f/classblaze_1_1SVecScalarDivExpr.html" title="Expression object for divisions of a sparse vector by a scalar.The SVecScalarDivExpr class represents...">SVecScalarDivExpr</a> class represents the compile time expression for divisions of sparse vectors by scalar values.  <a href="../../d7/d8f/classblaze_1_1SVecScalarDivExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html">SVecScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-scalar multiplications.The <a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html" title="Expression object for sparse vector-scalar multiplications.The SVecScalarMultExpr class represents th...">SVecScalarMultExpr</a> class represents the compile time expression for multiplications between a sparse vector and a scalar value.  <a href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html">SVecSVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector additions.The <a class="el" href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html" title="Expression object for sparse vector-sparse vector additions.The SVecSVecAddExpr class represents the ...">SVecSVecAddExpr</a> class represents the compile time expression for additions between sparse vectors.  <a href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html">SVecSVecCrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector cross products.The <a class="el" href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html" title="Expression object for sparse vector-sparse vector cross products.The SVecSVecCrossExpr class represen...">SVecSVecCrossExpr</a> class represents the compile time expression for cross products between sparse vectors.  <a href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html">SVecSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector multiplications.The <a class="el" href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html" title="Expression object for sparse vector-sparse vector multiplications.The SVecSVecMultExpr class represen...">SVecSVecMultExpr</a> class represents the compile time expression for componentwise multiplications between sparse vectors.  <a href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html">SVecSVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector subtractions.The <a class="el" href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html" title="Expression object for sparse vector-sparse vector subtractions.The SVecSVecSubExpr class represents t...">SVecSVecSubExpr</a> class represents the compile time expression for subtractions between sparse vectors.  <a href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html">SVecTDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-dense vector outer products.The <a class="el" href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html" title="Expression object for sparse vector-dense vector outer products.The SVecTDVecMultExpr class represent...">SVecTDVecMultExpr</a> class represents the compile time expression for sparse vector-dense vector outer products.  <a href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd7/classblaze_1_1SVecTransExpr.html">SVecTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector transpositions.The <a class="el" href="../../d9/dd7/classblaze_1_1SVecTransExpr.html" title="Expression object for sparse vector transpositions.The SVecTransExpr class represents the compile tim...">SVecTransExpr</a> class represents the compile time expression for transpositions of sparse vectors.  <a href="../../d9/dd7/classblaze_1_1SVecTransExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dd2/classblaze_1_1SVecTransposer.html">SVecTransposer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for the transposition of a sparse vector.The <a class="el" href="../../dd/dd2/classblaze_1_1SVecTransposer.html" title="Expression object for the transposition of a sparse vector.The SVecTransposer class is a wrapper obje...">SVecTransposer</a> class is a wrapper object for the temporary transposition of a sparse vector.  <a href="../../dd/dd2/classblaze_1_1SVecTransposer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html">SVecTSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse vector outer products.The <a class="el" href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html" title="Expression object for sparse vector-sparse vector outer products.The SVecTSVecMultExpr class represen...">SVecTSVecMultExpr</a> class represents the compile time expression for sparse vector-sparse vector outer products.  <a href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html">TDMatDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-dense matrix multiplications.The <a class="el" href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html" title="Expression object for transpose dense matrix-dense matrix multiplications.The TDMatDMatMultExpr class...">TDMatDMatMultExpr</a> class represents the compile time expression for multiplications between a column-major dense matrix and a row-major dense matrix.  <a href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd4/classblaze_1_1TDMatDVecMultExpr.html">TDMatDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-dense vector multiplications.The <a class="el" href="../../dc/dd4/classblaze_1_1TDMatDVecMultExpr.html" title="Expression object for transpose dense matrix-dense vector multiplications.The TDMatDVecMultExpr class...">TDMatDVecMultExpr</a> class represents the compile time expression for multiplications between column-major dense matrices and dense vectors.  <a href="../../dc/dd4/classblaze_1_1TDMatDVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for dense matrix-sparse matrix additions.The <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html" title="Expression object for dense matrix-sparse matrix additions.The TDMatSMatAddExpr class represents the ...">TDMatSMatAddExpr</a> class represents the compile time expression for additions between a column-major dense matrix and a row-major sparse matrix.  <a href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html">TDMatSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-sparse matrix multiplications.The <a class="el" href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html" title="Expression object for transpose dense matrix-sparse matrix multiplications.The TDMatSMatMultExpr clas...">TDMatSMatMultExpr</a> class represents the compile time expression for multiplications between a column-major dense matrix and a row-major sparse matrix.  <a href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html">TDMatSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-sparse matrix subtractions.The <a class="el" href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html" title="Expression object for transpose dense matrix-sparse matrix subtractions.The TDMatSMatSubExpr class re...">TDMatSMatSubExpr</a> class represents the compile time expression for subtractions between a row-major dense matrix and a column-major sparse matrix.  <a href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d0b/classblaze_1_1TDMatSVecMultExpr.html">TDMatSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-sparse vector multiplications.The <a class="el" href="../../d4/d0b/classblaze_1_1TDMatSVecMultExpr.html" title="Expression object for transpose dense matrix-sparse vector multiplications.The TDMatSVecMultExpr clas...">TDMatSVecMultExpr</a> class represents the compile time expression for multiplications between column-major dense matrices and sparse vectors.  <a href="../../d4/d0b/classblaze_1_1TDMatSVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html">TDMatTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-transpose dense matrix multiplications.The <a class="el" href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html" title="Expression object for transpose dense matrix-transpose dense matrix multiplications.The TDMatTDMatMultExpr class represents the compile time expression for multiplications between two column-major dense matrices.">TDMatTDMatMultExpr</a> class represents the compile time expression for multiplications between two column-major dense matrices.  <a href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html">TDMatTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense matrix-transpose sparse matrix multiplications.The <a class="el" href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html" title="Expression object for transpose dense matrix-transpose sparse matrix multiplications.The TDMatTSMatMultExpr class represents the compile time expression for multiplications between a column-major dense matrix and a column-major sparse matrix.">TDMatTSMatMultExpr</a> class represents the compile time expression for multiplications between a column-major dense matrix and a column-major sparse matrix.  <a href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d47/classblaze_1_1TDVecDMatMultExpr.html">TDVecDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense vector-dense matrix multiplications.The <a class="el" href="../../d8/d47/classblaze_1_1TDVecDMatMultExpr.html" title="Expression object for transpose dense vector-dense matrix multiplications.The TDVecDMatMultExpr class...">TDVecDMatMultExpr</a> class represents the compile time expression for multiplications between transpose dense vectors and dense matrices.  <a href="../../d8/d47/classblaze_1_1TDVecDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense vector-sparse matrix multiplications.The <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html" title="Expression object for transpose dense vector-sparse matrix multiplications.The TDVecSMatMultExpr clas...">TDVecSMatMultExpr</a> class represents the compile time expression for multiplications between transpose dense vectors and row-major sparse matrices.  <a href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html">TDVecTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense vector-transpose dense matrix multiplications.The <a class="el" href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html" title="Expression object for transpose dense vector-transpose dense matrix multiplications.The TDVecTDMatMultExpr class represents the compile time expression for multiplications between transpose dense vectors and column-major dense matrices.">TDVecTDMatMultExpr</a> class represents the compile time expression for multiplications between transpose dense vectors and column-major dense matrices.  <a href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose dense vector-transpose sparse matrix multiplications.The <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html" title="Expression object for transpose dense vector-transpose sparse matrix multiplications.The TDVecTSMatMultExpr class represents the compile time expression for multiplications between transpose dense vectors and column-major sparse matrices.">TDVecTSMatMultExpr</a> class represents the compile time expression for multiplications between transpose dense vectors and column-major sparse matrices.  <a href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html">TSMatDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-dense matrix multiplications.The <a class="el" href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html" title="Expression object for transpose sparse matrix-dense matrix multiplications.The TSMatDMatMultExpr clas...">TSMatDMatMultExpr</a> class represents the compile time expression for multiplications between a column-major sparse matrix and a row-major dense matrix.  <a href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html">TSMatDMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-dense matrix subtractions.The <a class="el" href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html" title="Expression object for transpose sparse matrix-dense matrix subtractions.The TSMatDMatSubExpr class re...">TSMatDMatSubExpr</a> class represents the compile time expression for subtractions between a column-major sparse matrix and a row-major dense matrix.  <a href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/ddb/classblaze_1_1TSMatDVecMultExpr.html">TSMatDVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-dense vector multiplications.The <a class="el" href="../../dc/ddb/classblaze_1_1TSMatDVecMultExpr.html" title="Expression object for transpose sparse matrix-dense vector multiplications.The TSMatDVecMultExpr clas...">TSMatDVecMultExpr</a> class represents the compile time expression for multiplications between column-major sparse matrices and dense vectors.  <a href="../../dc/ddb/classblaze_1_1TSMatDVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html">TSMatSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-sparse matrix multiplications.The <a class="el" href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html" title="Expression object for transpose sparse matrix-sparse matrix multiplications.The TSMatSMatMultExpr cla...">TSMatSMatMultExpr</a> class represents the compile time expression for multiplications between a column-major and a row-major sparse matrix.  <a href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html">TSMatSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-sparse matrix subtractions.The <a class="el" href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html" title="Expression object for transpose sparse matrix-sparse matrix subtractions.The TSMatSMatSubExpr class r...">TSMatSMatSubExpr</a> class represents the compile time expression for subtractions between a column-major sparse matrix and a row-major sparse matrix.  <a href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html">TSMatSVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse matrix-sparse vector multiplications.The <a class="el" href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html" title="Expression object for sparse matrix-sparse vector multiplications.The TSMatSVecMultExpr class represe...">TSMatSVecMultExpr</a> class represents the compile time expression for multiplications between column-major sparse matrices and sparse vectors.  <a href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html">TSMatTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-transpose dense matrix multiplications.The <a class="el" href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html" title="Expression object for transpose sparse matrix-transpose dense matrix multiplications.The TSMatTDMatMultExpr class represents the compile time expression for multiplications between a column-major sparse matrix and a column-major dense matrix.">TSMatTDMatMultExpr</a> class represents the compile time expression for multiplications between a column-major sparse matrix and a column-major dense matrix.  <a href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html">TSMatTSMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-transpose sparse matrix additions.The <a class="el" href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html" title="Expression object for transpose sparse matrix-transpose sparse matrix additions.The TSMatTSMatAddExpr...">TSMatTSMatAddExpr</a> class represents the compile time expression for additions between two column-major sparse matrices.  <a href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html">TSMatTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-transpose sparse matrix multiplications.The <a class="el" href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html" title="Expression object for transpose sparse matrix-transpose sparse matrix multiplications.The TSMatTSMatMultExpr class represents the compile time expression for multiplications between two column-major sparse matrices.">TSMatTSMatMultExpr</a> class represents the compile time expression for multiplications between two column-major sparse matrices.  <a href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html">TSMatTSMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse matrix-transpose sparse matrix subtractions.The <a class="el" href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html" title="Expression object for transpose sparse matrix-transpose sparse matrix subtractions.The TSMatTSMatSubExpr class represents the compile time expression for subtractions between two column-major sparse matrices.">TSMatTSMatSubExpr</a> class represents the compile time expression for subtractions between two column-major sparse matrices.  <a href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse vector-dense matrix multiplications.The <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html" title="Expression object for transpose sparse vector-dense matrix multiplications.The TSVecDMatMultExpr clas...">TSVecDMatMultExpr</a> class represents the compile time expression for multiplications between transpose sparse vectors and row-major dense matrices.  <a href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html">TSVecSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse matrix multiplications.The <a class="el" href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html" title="Expression object for sparse vector-sparse matrix multiplications.The TSVecSMatMultExpr class represe...">TSVecSMatMultExpr</a> class represents the compile time expression for multiplications between transpose sparse vectors and row-major sparse matrices.  <a href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for transpose sparse vector-transpose dense matrix multiplications.The <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html" title="Expression object for transpose sparse vector-transpose dense matrix multiplications.The TSVecTDMatMultExpr class represents the compile time expression for multiplications between transpose sparse vectors and column-major dense matrices.">TSVecTDMatMultExpr</a> class represents the compile time expression for multiplications between transpose sparse vectors and column-major dense matrices.  <a href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html">TSVecTSMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> object for sparse vector-sparse matrix multiplications.The <a class="el" href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html" title="Expression object for sparse vector-sparse matrix multiplications.The TSVecTSMatMultExpr class repres...">TSVecTSMatMultExpr</a> class represents the compile time expression for multiplications between transpose sparse vectors and column-major sparse matrices.  <a href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for N-dimensional vectors.The <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> class is a base class for all arbitrarily sized (N-dimensional) dense and sparse vector classes within the Blaze library. It provides an abstraction from the actual type of the vector, but enables a conversion back to this type via the 'Curiously Recurring Template Pattern' (CRTP).  <a href="../../da/d86/structblaze_1_1Vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity for built-in data types.The <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possibility to assign negative infinity values to built-in data types. As negative infinity value, the largest possible negative value of the corresponding data type is used. In order to assign the negative infinity value, the <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class can be implicitly converted to all signed integral and floating point data types:  <a href="../../db/da3/classblaze_1_1NegativeInfinity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity for built-in data types.The <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possiblity to assign a positive infinity value to built-in data types. As positive infinity value, the largest possible positive value of the corresponding data type is used. In order to assign the positive infinity value, the <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class can be implicitly converted to the following 13 built-in integral and floating point data types:  <a href="../../da/dff/classblaze_1_1Infinity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic characteristics of data types.The <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html" title="Intrinsic characteristics of data types.The IntrinsicTrait class template provides the intrinsic char...">IntrinsicTrait</a> class template provides the intrinsic characteristics of a specific data type:  <a href="../../d7/d73/classblaze_1_1IntrinsicTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de7/structblaze_1_1BoxLCP.html">BoxLCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A box linear complementarity problem (BLCP) data structure.The <a class="el" href="../../d8/de7/structblaze_1_1BoxLCP.html" title="A box linear complementarity problem (BLCP) data structure.The BoxLCP class represent a box linear co...">BoxLCP</a> class represent a box linear complementarity problem (BLCP) of the form <img class="formulaInl" alt="$ A \cdot x + b \leq 0 \quad\perp\quad \underline{x} \leq x \leq \bar{x} $" src="../../form_111.png"/>.  <a href="../../d8/de7/structblaze_1_1BoxLCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d46/structblaze_1_1ContactLCP.html">ContactLCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure for linear complementarity problems (LCPs) for contact mechanics.TODO.  <a href="../../d8/d46/structblaze_1_1ContactLCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/structblaze_1_1LCP.html">LCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear complementarity problem (<a class="el" href="../../db/d3a/structblaze_1_1LCP.html" title="A linear complementarity problem (LCP) data structure.The LCP class represent a linear complementarit...">LCP</a>) data structure.The <a class="el" href="../../db/d3a/structblaze_1_1LCP.html" title="A linear complementarity problem (LCP) data structure.The LCP class represent a linear complementarit...">LCP</a> class represent a linear complementarity problem of the form <img class="formulaInl" alt="$ A \cdot x + b \leq 0 \quad\perp\quad x \geq 0 $" src="../../form_116.png"/>.  <a href="../../db/d3a/structblaze_1_1LCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de6/structblaze_1_1LSE.html">LSE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear system of equations (<a class="el" href="../../dd/de6/structblaze_1_1LSE.html" title="A linear system of equations (LSE) data structure.The LSE class represent a linear system of equation...">LSE</a>) data structure.The <a class="el" href="../../dd/de6/structblaze_1_1LSE.html" title="A linear system of equations (LSE) data structure.The LSE class represent a linear system of equation...">LSE</a> class represent a linear system of equations of the form <img class="formulaInl" alt="$ A \cdot x + b = 0 $" src="../../form_117.png"/>.  <a href="../../dd/de6/structblaze_1_1LSE.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/daf/structblaze_1_1MixedLCP.html">MixedLCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mixed linear complementarity problem (MLCP) data structure.The <a class="el" href="../../db/d3a/structblaze_1_1LCP.html" title="A linear complementarity problem (LCP) data structure.The LCP class represent a linear complementarit...">LCP</a> class represent a mixed linear complementarity problem of the form.  <a href="../../d5/daf/structblaze_1_1MixedLCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df0/structblaze_1_1ModifiedBoxLCP.html">ModifiedBoxLCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified box linear complementarity problem (MBLCP) data structure.The <a class="el" href="../../df/df0/structblaze_1_1ModifiedBoxLCP.html" title="A modified box linear complementarity problem (MBLCP) data structure.The ModifiedBoxLCP class represe...">ModifiedBoxLCP</a> class represent a modified box linear complementarity problem (MBLCP) of the form.  <a href="../../df/df0/structblaze_1_1ModifiedBoxLCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a quaternion.Quaternions are a superior way to deal with rotations and orientations. This quaternion consists of 4 statically allocated elements, where the first element represents the real part and the three other elements represent the three imaginary parts. The naming convention of the elements is as following:  <a href="../../d5/d29/classblaze_1_1Quaternion.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient, generic implementation of a 3x3 rotation matrix.The <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html" title="Efficient, generic implementation of a 3x3 rotation matrix.The RotationMatrix class is the representa...">RotationMatrix</a> class is the representation of a 3x3 rotation matrix with a total of 9 statically allocated elements of arbitrary type. The naming convention of the elements is as following:  <a href="../../da/d11/classblaze_1_1RotationMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd5/classblaze_1_1CG.html">CG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conjugate gradient solver.TODO: description TODO: Problem formulation: <img class="formulaInl" alt="$ A \cdot x + b = 0 $" src="../../form_117.png"/> !!  <a href="../../d4/dd5/classblaze_1_1CG.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d34/classblaze_1_1CPG.html">CPG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the conjugate projected gradient algorithm.TODO: description of the <a class="el" href="../../d8/d34/classblaze_1_1CPG.html" title="Implementation of the conjugate projected gradient algorithm.TODO: description of the CPG solver TODO...">CPG</a> solver TODO: capabilities of the <a class="el" href="../../d8/d34/classblaze_1_1CPG.html" title="Implementation of the conjugate projected gradient algorithm.TODO: description of the CPG solver TODO...">CPG</a> solver (which <a class="el" href="../../db/d3a/structblaze_1_1LCP.html" title="A linear complementarity problem (LCP) data structure.The LCP class represent a linear complementarit...">LCP</a> problems, etc) TODO: known issues of the <a class="el" href="../../d8/d34/classblaze_1_1CPG.html" title="Implementation of the conjugate projected gradient algorithm.TODO: description of the CPG solver TODO...">CPG</a> solver.  <a href="../../d8/d34/classblaze_1_1CPG.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d76/classblaze_1_1GaussianElimination.html">GaussianElimination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the Gaussian elimination direct linear system solver.TODO: description TODO: Problem formulation: <img class="formulaInl" alt="$ A \cdot x + b = 0 $" src="../../form_117.png"/> !!  <a href="../../dc/d76/classblaze_1_1GaussianElimination.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d21/classblaze_1_1Lemke.html">Lemke</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../de/d21/classblaze_1_1Lemke.html" title="The Lemke pivoting algorithm for solving LCPs.TODO.">Lemke</a> pivoting algorithm for solving LCPs.TODO.  <a href="../../de/d21/classblaze_1_1Lemke.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d75/classblaze_1_1PGS.html">PGS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A projected Gauss-Seidel <a class="el" href="../../de/d4d/classblaze_1_1Solver.html" title="Base class for all solver classes.TODO: description of the Solver class TODO: description of its func...">Solver</a> for (box) LCPs.TODO: description of the <a class="el" href="../../df/d75/classblaze_1_1PGS.html" title="A projected Gauss-Seidel Solver for (box) LCPs.TODO: description of the PGS solver TODO: capabilities...">PGS</a> solver TODO: capabilities of the <a class="el" href="../../df/d75/classblaze_1_1PGS.html" title="A projected Gauss-Seidel Solver for (box) LCPs.TODO: description of the PGS solver TODO: capabilities...">PGS</a> solver (which <a class="el" href="../../db/d3a/structblaze_1_1LCP.html" title="A linear complementarity problem (LCP) data structure.The LCP class represent a linear complementarit...">LCP</a> problems, etc) TODO: known issues of the <a class="el" href="../../df/d75/classblaze_1_1PGS.html" title="A projected Gauss-Seidel Solver for (box) LCPs.TODO: description of the PGS solver TODO: capabilities...">PGS</a> solver.  <a href="../../df/d75/classblaze_1_1PGS.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d4d/classblaze_1_1Solver.html">Solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all solver classes.TODO: description of the <a class="el" href="../../de/d4d/classblaze_1_1Solver.html" title="Base class for all solver classes.TODO: description of the Solver class TODO: description of its func...">Solver</a> class TODO: description of its functionality.  <a href="../../de/d4d/classblaze_1_1Solver.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of a <img class="formulaInl" alt="$ M \times N $" src="../../form_18.png"/> compressed matrix.The <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> class template is the representation of an arbitrary sized sparse matrix with <img class="formulaInl" alt="$ M \cdot N $" src="../../form_3.png"/> dynamically allocated elements of arbitrary type. The type of the elements and the storage order of the matrix can be specified via the two template parameters:  <a href="../../da/d7a/classblaze_1_1CompressedMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient implementation of an arbitrary sized sparse vector.The <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">CompressedVector</a> class is the representation of an arbitrarily sized sparse vector, which stores only non-zero elements of arbitrary type. The type of the elements and the transpose flag of the vector can be specified via the two template parameters:  <a href="../../d5/d35/classblaze_1_1CompressedVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, <img class="formulaInl" alt="$ M \times N $" src="../../form_18.png"/> matrices.The <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> provides safe access to the elements of a non-const sparse matrices.<br/>
 The proxied access to the elements of a sparse matrix is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> class:  <a href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d71/classblaze_1_1SparseElement.html">SparseElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-value-pair for the sparse vectors and matrices.The <a class="el" href="../../d2/d71/classblaze_1_1SparseElement.html" title="Index-value-pair for the sparse vectors and matrices.The SparseElement class represents a single inde...">SparseElement</a> class represents a single index-value-pair of a sparse vector or sparse matrix.  <a href="../../d2/d71/classblaze_1_1SparseElement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, N-dimensional vectors.The <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> provides safe access to the elements of a non-const sparse vector.<br/>
 The proxied access to the elements of a sparse vector is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">CompressedVector</a> class:  <a href="../../df/de3/classblaze_1_1VectorAccessProxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9f/structblaze_1_1AbsExprTrait.html">AbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an absolute value expression.Via this type trait it is possible to evaluate the return type of an absolute value expression. Given the type <em>T</em>, which must be either a scalar, vector, or matrix type, the nested type <em>Type</em> corresponds to the resulting return type. In case the type of <em>T</em> doesn't fit or if no absolute value operation exists for the type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d9f/structblaze_1_1AbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc4/structblaze_1_1AddExprTrait.html">AddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of an addition expression.Via this type trait it is possible to evaluate the return type of an addition expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must be either scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case the types of <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be added, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dc4/structblaze_1_1AddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d18/structblaze_1_1AddTrait.html">AddTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class.">AddTrait</a> class.  <a href="../../db/d18/structblaze_1_1AddTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html">CMathTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html" title="Base template for the CMathTrait class.The CMathTrait template evaluates the return type of the mathe...">CMathTrait</a> class.The <a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html" title="Base template for the CMathTrait class.The CMathTrait template evaluates the return type of the mathe...">CMathTrait</a> template evaluates the return type of the mathematical functions defined in the C++ header &lt;cmath&gt; depending on the type of the template argument. In case of an integral data type or double precision argument, the return value of the functions is double, whereas the return type is float for single precision arguments and long double for long double precision arguments.  <a href="../../de/d19/structblaze_1_1CMathTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d57/structblaze_1_1CrossExprTrait.html">CrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a cross product expression.Via this type trait it is possible to evaluate the return type of a cross product expression. Given the two types <em>T1</em> and <em>T2</em>, which must be dense or sparse column vectors, the nested type <em>Type</em> corresponds to the resulting return type. In case the types of <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be used in a cross product, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d57/structblaze_1_1CrossExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html">CrossTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class.">CrossTrait</a> class.  <a href="../../d4/d9c/structblaze_1_1CrossTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d73/structblaze_1_1DivExprTrait.html">DivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the resulting expression type of a division.Via this type trait it is possible to evaluate the return type of a division expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, where <em>T1</em> must be either a scalar, vector, or matrix type and <em>T2</em> which must be a scalar type, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be divided, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d73/structblaze_1_1DivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html">DivTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class.">DivTrait</a> class.  <a href="../../d2/d67/structblaze_1_1DivTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d1d/structblaze_1_1DMatAbsExprTrait.html">DMatAbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix absolute value operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix absolute value operation. Given the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d1d/structblaze_1_1DMatAbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da5/structblaze_1_1DMatDMatAddExprTrait.html">DMatDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/dense matrix addition. Given the two row-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/da5/structblaze_1_1DMatDMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1DMatDMatMultExprTrait.html">DMatDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/dense matrix multiplication. Given the two row-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/df1/structblaze_1_1DMatDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d11/structblaze_1_1DMatDMatSubExprTrait.html">DMatDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/dense matrix subtraction. Given the two row-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d11/structblaze_1_1DMatDMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d54/structblaze_1_1DMatDVecMultExprTrait.html">DMatDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/dense vector multiplication. Given the row-major dense matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type or <em>VT</em> is not a non-transpose dense vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d54/structblaze_1_1DMatDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d25/structblaze_1_1DMatScalarDivExprTrait.html">DMatScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/scalar division. Given the row-major dense matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d25/structblaze_1_1DMatScalarDivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da4/structblaze_1_1DMatScalarMultExprTrait.html">DMatScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/scalar multiplication. Given the row-major dense matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/da4/structblaze_1_1DMatScalarMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dab/structblaze_1_1DMatSMatAddExprTrait.html">DMatSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/sparse matrix addition. Given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/dab/structblaze_1_1DMatSMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d84/structblaze_1_1DMatSMatMultExprTrait.html">DMatSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/sparse matrix multiplication. Given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d84/structblaze_1_1DMatSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d07/structblaze_1_1DMatSMatSubExprTrait.html">DMatSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/sparse matrix subtraction. Given the row-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d07/structblaze_1_1DMatSMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d42/structblaze_1_1DMatSVecMultExprTrait.html">DMatSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/sparse vector multiplication. Given the row-major dense matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major dense matrix type or <em>VT</em> is not a non-transpose sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d42/structblaze_1_1DMatSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da3/structblaze_1_1DMatTDMatAddExprTrait.html">DMatTDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix addition. Given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/da3/structblaze_1_1DMatTDMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3c/structblaze_1_1DMatTDMatMultExprTrait.html">DMatTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix multiplication. Given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d3c/structblaze_1_1DMatTDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d21/structblaze_1_1DMatTDMatSubExprTrait.html">DMatTDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose dense matrix subtraction. Given the row-major dense matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d21/structblaze_1_1DMatTDMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc3/structblaze_1_1DMatTSMatAddExprTrait.html">DMatTSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/transpose sparse matrix addition. Given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/dc3/structblaze_1_1DMatTSMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d14/structblaze_1_1DMatTSMatMultExprTrait.html">DMatTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/ transpose sparse matrix multiplication. Given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d14/structblaze_1_1DMatTSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc2/structblaze_1_1DMatTSMatSubExprTrait.html">DMatTSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix/ transpose sparse matrix subtraction. Given the row-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/dc2/structblaze_1_1DMatTSMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9c/structblaze_1_1DVecAbsExprTrait.html">DVecAbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector absolute value operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector absolute value operation. Given the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d9c/structblaze_1_1DVecAbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/structblaze_1_1DVecDVecAddExprTrait.html">DVecDVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector addition.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector addition. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d17/structblaze_1_1DVecDVecAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d42/structblaze_1_1DVecDVecCrossExprTrait.html">DVecDVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector cross product. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d42/structblaze_1_1DVecDVecCrossExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9b/structblaze_1_1DVecDVecMultExprTrait.html">DVecDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector multiplication. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/d9b/structblaze_1_1DVecDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d0f/structblaze_1_1DVecDVecSubExprTrait.html">DVecDVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense vector subtraction. Given the two non-transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d0f/structblaze_1_1DVecDVecSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfb/structblaze_1_1DVecScalarDivExprTrait.html">DVecScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/scalar division. Given the non-transpose dense vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose dense vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dfb/structblaze_1_1DVecScalarDivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d2e/structblaze_1_1DVecScalarMultExprTrait.html">DVecScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/scalar multiplication. Given the non-transpose dense vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose dense vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d2e/structblaze_1_1DVecScalarMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d85/structblaze_1_1DVecSVecAddExprTrait.html">DVecSVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector addition.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector addition. Given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d85/structblaze_1_1DVecSVecAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5e/structblaze_1_1DVecSVecCrossExprTrait.html">DVecSVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector cross product. Given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d5e/structblaze_1_1DVecSVecCrossExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dad/structblaze_1_1DVecSVecMultExprTrait.html">DVecSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector multiplication. Given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/dad/structblaze_1_1DVecSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d38/structblaze_1_1DVecSVecSubExprTrait.html">DVecSVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse vector subtraction. Given the non-transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d38/structblaze_1_1DVecSVecSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d92/structblaze_1_1DVecTDVecMultExprTrait.html">DVecTDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose dense vector multiplication (outer product). Given the non-transpose dense vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d92/structblaze_1_1DVecTDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d7a/structblaze_1_1DVecTSVecMultExprTrait.html">DVecTSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose sparse vector multiplication (outer product). Given the non-transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d7a/structblaze_1_1DVecTSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">MathTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class.">MathTrait</a> class.  <a href="../../d3/d6a/structblaze_1_1MathTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the resulting expression type of a multiplication.Via this type trait it is possible to evaluate the return type of a multiplication expression between scalars, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must be either scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be multiplied, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/da3/structblaze_1_1MultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class.  <a href="../../df/daf/structblaze_1_1MultTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db4/structblaze_1_1SMatAbsExprTrait.html">SMatAbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix absolute value operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix absolute value operation. Given the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/db4/structblaze_1_1SMatAbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d14/structblaze_1_1SMatDMatAddExprTrait.html">SMatDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/dense matrix addition. Given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d14/structblaze_1_1SMatDMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d14/structblaze_1_1SMatDMatMultExprTrait.html">SMatDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/dense matrix multiplication. Given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d14/structblaze_1_1SMatDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1a/structblaze_1_1SMatDMatSubExprTrait.html">SMatDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/dense matrix subtraction. Given the row-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/d1a/structblaze_1_1SMatDMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d40/structblaze_1_1SMatDVecMultExprTrait.html">SMatDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/dense vector multiplication. Given the row-major sparse matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type or <em>VT</em> is not a non-transpose dense vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d40/structblaze_1_1SMatDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d46/structblaze_1_1SMatScalarDivExprTrait.html">SMatScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/scalar division. Given the row-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d46/structblaze_1_1SMatScalarDivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d4d/structblaze_1_1SMatScalarMultExprTrait.html">SMatScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/scalar multiplication. Given the row-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d4d/structblaze_1_1SMatScalarMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d9c/structblaze_1_1SMatSMatAddExprTrait.html">SMatSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse matrix addition. Given the two row-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d9c/structblaze_1_1SMatSMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d59/structblaze_1_1SMatSMatMultExprTrait.html">SMatSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse matrix multiplication. Given the two row-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d59/structblaze_1_1SMatSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d43/structblaze_1_1SMatSMatSubExprTrait.html">SMatSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse matrix subtraction. Given the two row-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a row-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d43/structblaze_1_1SMatSMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d35/structblaze_1_1SMatSVecMultExprTrait.html">SMatSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/sparse vector multiplication. Given the row-major sparse matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a row-major sparse matrix type or <em>VT</em> is not a non-transpose sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d35/structblaze_1_1SMatSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9f/structblaze_1_1SMatTDMatAddExprTrait.html">SMatTDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix addition. Given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d9f/structblaze_1_1SMatTDMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d9d/structblaze_1_1SMatTDMatMultExprTrait.html">SMatTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix multiplication. Given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d9d/structblaze_1_1SMatTDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d76/structblaze_1_1SMatTDMatSubExprTrait.html">SMatTDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose dense matrix subtraction. Given the row-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d9/d76/structblaze_1_1SMatTDMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d48/structblaze_1_1SMatTSMatAddExprTrait.html">SMatTSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix addition. Given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d48/structblaze_1_1SMatTSMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dbb/structblaze_1_1SMatTSMatMultExprTrait.html">SMatTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix multiplication. Given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/dbb/structblaze_1_1SMatTSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da1/structblaze_1_1SMatTSMatSubExprTrait.html">SMatTSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix/transpose sparse matrix subtraction. Given the row-major sparse matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a row-major sparse matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/da1/structblaze_1_1SMatTSMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9b/structblaze_1_1SubExprTrait.html">SubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the return type of a subtraction expression.Via this type trait it is possible to evaluate the return type of a subtraction expression between scalar, vectors, and matrices. Given the two types <em>T1</em> and <em>T2</em>, which must be either scalar, vector, or matrix types, the nested type <em>Type</em> corresponds to the resulting return type. In case <em>T1</em> or <em>T2</em> don't fit or if the two types cannot be subtracted, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d9b/structblaze_1_1SubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html">SubTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class.">SubTrait</a> class.  <a href="../../dd/d27/structblaze_1_1SubTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbd/structblaze_1_1SVecAbsExprTrait.html">SVecAbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector absolute value operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector absolute value operation. Given the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/dbd/structblaze_1_1SVecAbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc3/structblaze_1_1SVecDVecAddExprTrait.html">SVecDVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector addition. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/dc3/structblaze_1_1SVecDVecAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/ddb/structblaze_1_1SVecDVecCrossExprTrait.html">SVecDVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector cross product. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/ddb/structblaze_1_1SVecDVecCrossExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d42/structblaze_1_1SVecDVecMultExprTrait.html">SVecDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector multiplication. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d42/structblaze_1_1SVecDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d8a/structblaze_1_1SVecDVecSubExprTrait.html">SVecDVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense vector subtraction. Given the non-transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type<em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d8a/structblaze_1_1SVecDVecSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd3/structblaze_1_1SVecScalarDivExprTrait.html">SVecScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/scalar division. Given the non-transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose sparse vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/dd3/structblaze_1_1SVecScalarDivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d16/structblaze_1_1SVecScalarMultExprTrait.html">SVecScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/scalar multiplication. Given the non-transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a non-transpose sparse vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d16/structblaze_1_1SVecScalarMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd9/structblaze_1_1SVecSVecAddExprTrait.html">SVecSVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector addition.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector addition. Given the two non-transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/dd9/structblaze_1_1SVecSVecAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ddd/structblaze_1_1SVecSVecCrossExprTrait.html">SVecSVecCrossExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector cross product.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector cross product. Given the two non-transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/ddd/structblaze_1_1SVecSVecCrossExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d94/structblaze_1_1SVecSVecMultExprTrait.html">SVecSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector multiplication. Given the two non-transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d94/structblaze_1_1SVecSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3e/structblaze_1_1SVecSVecSubExprTrait.html">SVecSVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse vector subtraction. Given the two non-transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d3e/structblaze_1_1SVecSVecSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dad/structblaze_1_1SVecTDVecMultExprTrait.html">SVecTDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose dense vector multiplication (outer product). Given the non-transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/dad/structblaze_1_1SVecTDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d83/structblaze_1_1SVecTSVecMultExprTrait.html">SVecTSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose sparse vector multiplication (outer product). Given the non-transpose sparse vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a non-transpose sparse vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/d83/structblaze_1_1SVecTSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d6c/structblaze_1_1TDMatAbsExprTrait.html">TDMatAbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense matrix absolute value operation.Via this type trait it is possible to evaluate the resulting expression type of a dense matrix absolute value operation. Given the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d6c/structblaze_1_1TDMatAbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d24/structblaze_1_1TDMatDMatAddExprTrait.html">TDMatDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix addition. Given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d24/structblaze_1_1TDMatDMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d09/structblaze_1_1TDMatDMatMultExprTrait.html">TDMatDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix multiplication. Given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d09/structblaze_1_1TDMatDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d15/structblaze_1_1TDMatDMatSubExprTrait.html">TDMatDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense matrix subtraction. Given the column-major dense matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d15/structblaze_1_1TDMatDMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6f/structblaze_1_1TDMatDVecMultExprTrait.html">TDMatDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/dense vector multiplication. Given the column-major dense matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type or <em>VT</em> is not a non-transpose dense vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/d6f/structblaze_1_1TDMatDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da0/structblaze_1_1TDMatScalarDivExprTrait.html">TDMatScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/scalar division. Given the column-major dense matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/da0/structblaze_1_1TDMatScalarDivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d61/structblaze_1_1TDMatScalarMultExprTrait.html">TDMatScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/scalar multiplication. Given the column-major dense matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../da/d61/structblaze_1_1TDMatScalarMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d21/structblaze_1_1TDMatSMatAddExprTrait.html">TDMatSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix addition. Given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d21/structblaze_1_1TDMatSMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d89/structblaze_1_1TDMatSMatMultExprTrait.html">TDMatSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix multiplication. Given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d89/structblaze_1_1TDMatSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d90/structblaze_1_1TDMatSMatSubExprTrait.html">TDMatSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse matrix subtraction. Given the column-major dense matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d90/structblaze_1_1TDMatSMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dee/structblaze_1_1TDMatSVecMultExprTrait.html">TDMatSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/sparse vector multiplication. Given the column-major dense matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major dense matrix type or <em>VT</em> is not a non-transpose sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/dee/structblaze_1_1TDMatSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d14/structblaze_1_1TDMatTDMatAddExprTrait.html">TDMatTDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose dense matrix addition. Given the two column-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d14/structblaze_1_1TDMatTDMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ded/structblaze_1_1TDMatTDMatMultExprTrait.html">TDMatTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose dense matrix multiplication. Given the two column-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/ded/structblaze_1_1TDMatTDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfa/structblaze_1_1TDMatTDMatSubExprTrait.html">TDMatTDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose dense matrix subtraction. Given the two column-major dense matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major dense matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/dfa/structblaze_1_1TDMatTDMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da3/structblaze_1_1TDMatTSMatAddExprTrait.html">TDMatTSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose sparse matrix addition. Given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/da3/structblaze_1_1TDMatTSMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc5/structblaze_1_1TDMatTSMatMultExprTrait.html">TDMatTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose sparse matrix multiplication. Given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/dc5/structblaze_1_1TDMatTSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d8b/structblaze_1_1TDMatTSMatSubExprTrait.html">TDMatTSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense matrix/transpose sparse matrix subtraction. Given the column-major dense matrix type <em>MT1</em> and the column-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major dense matrix type or <em>MT2</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d8b/structblaze_1_1TDMatTSMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d4c/structblaze_1_1TDVecAbsExprTrait.html">TDVecAbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector absolute value operation.Via this type trait it is possible to evaluate the resulting expression type of a dense vector absolute value operation. Given the transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d4c/structblaze_1_1TDVecAbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d4b/structblaze_1_1TDVecDMatMultExprTrait.html">TDVecDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/dense matrix multiplication. Given the transpose dense vector type <em>VT</em> and the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>MT</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d4b/structblaze_1_1TDVecDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/structblaze_1_1TDVecDVecMultExprTrait.html">TDVecDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/dense vector multiplication (inner product). Given the transpose dense vector type <em>VT1</em> and the non-transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d5e/structblaze_1_1TDVecDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d59/structblaze_1_1TDVecScalarDivExprTrait.html">TDVecScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/scalar division. Given the transpose dense vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d59/structblaze_1_1TDVecScalarDivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d39/structblaze_1_1TDVecScalarMultExprTrait.html">TDVecScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/scalar multiplication. Given the transpose dense vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/d39/structblaze_1_1TDVecScalarMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d02/structblaze_1_1TDVecSMatMultExprTrait.html">TDVecSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/sparse matrix multiplication. Given the transpose dense vector type <em>VT</em> and the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>MT</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dd/d02/structblaze_1_1TDVecSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/ded/structblaze_1_1TDVecSVecMultExprTrait.html">TDVecSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/sparse vector multiplication (inner product). Given the transpose dense vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/ded/structblaze_1_1TDVecSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dbe/structblaze_1_1TDVecTDMatMultExprTrait.html">TDVecTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose dense matrix multiplication. Given the transpose dense vector type <em>VT</em> and the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>MT</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/dbe/structblaze_1_1TDVecTDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d48/structblaze_1_1TDVecTDVecAddExprTrait.html">TDVecTDVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose dense vector addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose dense vector addition. Given the two transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d48/structblaze_1_1TDVecTDVecAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d96/structblaze_1_1TDVecTDVecMultExprTrait.html">TDVecTDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose dense vector multiplication. Given the two transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d96/structblaze_1_1TDVecTDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da4/structblaze_1_1TDVecTDVecSubExprTrait.html">TDVecTDVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose dense vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose dense vector subtraction. Given the two transpose dense vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/da4/structblaze_1_1TDVecTDVecSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d39/structblaze_1_1TDVecTSMatMultExprTrait.html">TDVecTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a dense vector/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a dense vector/transpose sparse matrix multiplication. Given the transpose dense vector type <em>VT</em> and the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose dense vector type or <em>MT</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/d39/structblaze_1_1TDVecTSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db9/structblaze_1_1TDVecTSVecAddExprTrait.html">TDVecTSVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose sparse vector addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose sparse vector addition. Given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../db/db9/structblaze_1_1TDVecTSVecAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da4/structblaze_1_1TDVecTSVecMultExprTrait.html">TDVecTSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose sparse vector multiplication. Given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/da4/structblaze_1_1TDVecTSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc3/structblaze_1_1TDVecTSVecSubExprTrait.html">TDVecTSVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose dense vector/transpose sparse vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose dense vector/transpose sparse vector subtraction. Given the transpose dense vector type <em>VT1</em> and the transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose dense vector type or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/dc3/structblaze_1_1TDVecTSVecSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d6a/structblaze_1_1TSMatAbsExprTrait.html">TSMatAbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse matrix absolute value operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse matrix absolute value operation. Given the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d6a/structblaze_1_1TSMatAbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d7a/structblaze_1_1TSMatDMatAddExprTrait.html">TSMatDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix addition. Given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d7a/structblaze_1_1TSMatDMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d45/structblaze_1_1TSMatDMatMultExprTrait.html">TSMatDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix multiplication. Given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d45/structblaze_1_1TSMatDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df5/structblaze_1_1TSMatDMatSubExprTrait.html">TSMatDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense matrix subtraction. Given the column-major sparse matrix type <em>MT1</em> and the row-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/df5/structblaze_1_1TSMatDMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d6c/structblaze_1_1TSMatDVecMultExprTrait.html">TSMatDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/dense vector multiplication. Given the column-major sparse matrix type <em>MT</em> and the non-transpose dense vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type or <em>VT</em> is not a non-transpose dense vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d6c/structblaze_1_1TSMatDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6e/structblaze_1_1TSMatScalarDivExprTrait.html">TSMatScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/scalar division. Given the column-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d1/d6e/structblaze_1_1TSMatScalarDivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4f/structblaze_1_1TSMatScalarMultExprTrait.html">TSMatScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/scalar multiplication. Given the column-major sparse matrix type <em>MT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../df/d4f/structblaze_1_1TSMatScalarMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/df7/structblaze_1_1TSMatSMatAddExprTrait.html">TSMatSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix addition. Given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/df7/structblaze_1_1TSMatSMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d96/structblaze_1_1TSMatSMatMultExprTrait.html">TSMatSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix multiplication. Given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d96/structblaze_1_1TSMatSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de9/structblaze_1_1TSMatSMatSubExprTrait.html">TSMatSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse matrix subtraction. Given the column-major sparse matrix type <em>MT1</em> and the row-major sparse matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../de/de9/structblaze_1_1TSMatSMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dbc/structblaze_1_1TSMatSVecMultExprTrait.html">TSMatSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/sparse vector multiplication. Given the column-major sparse matrix type <em>MT</em> and the non-transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT</em> is not a column-major sparse matrix type or <em>VT</em> is not a non-transpose sparse vector type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dbc/structblaze_1_1TSMatSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d27/structblaze_1_1TSMatTDMatAddExprTrait.html">TSMatTDMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose dense matrix addition. Given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d27/structblaze_1_1TSMatTDMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d13/structblaze_1_1TSMatTDMatMultExprTrait.html">TSMatTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose dense matrix multiplication. Given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d13/structblaze_1_1TSMatTDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db2/structblaze_1_1TSMatTDMatSubExprTrait.html">TSMatTDMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose dense matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose dense matrix subtraction. Given the column-major sparse matrix type <em>MT1</em> and the column-major dense matrix type <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> is not a column-major sparse matrix type or <em>MT2</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d0/db2/structblaze_1_1TSMatTDMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3f/structblaze_1_1TSMatTSMatAddExprTrait.html">TSMatTSMatAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose sparse matrix addition. Given the two column-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/d3f/structblaze_1_1TSMatTSMatAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d49/structblaze_1_1TSMatTSMatMultExprTrait.html">TSMatTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose sparse matrix multiplication. Given the two column-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d49/structblaze_1_1TSMatTSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de0/structblaze_1_1TSMatTSMatSubExprTrait.html">TSMatTSMatSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse matrix/transpose sparse matrix subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse matrix/transpose sparse matrix subtraction. Given the two column-major sparse matrix types <em>MT1</em> and <em>MT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>MT1</em> or <em>MT2</em> is not a column-major sparse matrix, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/de0/structblaze_1_1TSMatTSMatSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d79/structblaze_1_1TSVecAbsExprTrait.html">TSVecAbsExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector absolute value operation.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector absolute value operation. Given the transpose sparse vector type <em>VT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d79/structblaze_1_1TSVecAbsExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7b/structblaze_1_1TSVecDMatMultExprTrait.html">TSVecDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/dense matrix multiplication. Given the transpose sparse vector type <em>VT</em> and the row-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>MT</em> is not a row-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d7b/structblaze_1_1TSVecDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d75/structblaze_1_1TSVecDVecMultExprTrait.html">TSVecDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/dense vector multiplication (inner product). Given the transpose sparse vector type <em>VT1</em> and the non-transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a non-transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/d75/structblaze_1_1TSVecDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dfb/structblaze_1_1TSVecScalarDivExprTrait.html">TSVecScalarDivExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/scalar division.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/scalar division. Given the transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d4/dfb/structblaze_1_1TSVecScalarDivExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d98/structblaze_1_1TSVecScalarMultExprTrait.html">TSVecScalarMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/scalar multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/scalar multiplication. Given the transpose sparse vector type <em>VT</em> and the scalar type <em>ST</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>ST</em> is not a scalar type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d98/structblaze_1_1TSVecScalarMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/daf/structblaze_1_1TSVecSMatMultExprTrait.html">TSVecSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/sparse matrix multiplication. Given the transpose sparse vector type <em>VT</em> and the row-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>MT</em> is not a row-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d7/daf/structblaze_1_1TSVecSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d59/structblaze_1_1TSVecSVecMultExprTrait.html">TSVecSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/sparse vector multiplication (inner product). Given the transpose sparse vector type <em>VT1</em> and the non-transpose sparse vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a non-transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d59/structblaze_1_1TSVecSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8e/structblaze_1_1TSVecTDMatMultExprTrait.html">TSVecTDMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/transpose dense matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose dense matrix multiplication. Given the transpose sparse vector type <em>VT</em> and the column-major dense matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>MT</em> is not a column-major dense matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../dc/d8e/structblaze_1_1TSVecTDMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de5/structblaze_1_1TSVecTDVecAddExprTrait.html">TSVecTDVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose dense vector addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose dense vector addition. Given the transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/de5/structblaze_1_1TSVecTDVecAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/da5/structblaze_1_1TSVecTDVecMultExprTrait.html">TSVecTDVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose dense vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose dense vector multiplication. Given the transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/da5/structblaze_1_1TSVecTDVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d6e/structblaze_1_1TSVecTDVecSubExprTrait.html">TSVecTDVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose dense vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose dense vector subtraction. Given the transpose sparse vector type <em>VT1</em> and the transpose dense vector type <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> is not a transpose sparse vector type or <em>VT2</em> is not a transpose dense vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d3/d6e/structblaze_1_1TSVecTDVecSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/structblaze_1_1TSVecTSMatMultExprTrait.html">TSVecTSMatMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a sparse vector/transpose sparse matrix multiplication.Via this type trait it is possible to evaluate the resulting expression type of a sparse vector/transpose sparse matrix multiplication. Given the transpose sparse vector type <em>VT</em> and the column-major sparse matrix type <em>MT</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT</em> is not a transpose sparse vector type or <em>MT</em> is not a column-major sparse matrix type, the resulting data type <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d6/d8e/structblaze_1_1TSVecTSMatMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d9f/structblaze_1_1TSVecTSVecAddExprTrait.html">TSVecTSVecAddExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose sparse vector addition.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose sparse vector addition. Given the two transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d8/d9f/structblaze_1_1TSVecTSVecAddExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/structblaze_1_1TSVecTSVecMultExprTrait.html">TSVecTSVecMultExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose sparse vector multiplication.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose sparse vector multiplication. Given the two transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d5/d8c/structblaze_1_1TSVecTSVecMultExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d70/structblaze_1_1TSVecTSVecSubExprTrait.html">TSVecTSVecSubExprTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the expression type of a transpose sparse vector/transpose sparse vector subtraction.Via this type trait it is possible to evaluate the resulting expression type of a transpose sparse vector/transpose sparse vector subtraction. Given the two transpose sparse vector types <em>VT1</em> and <em>VT2</em>, the nested type <em>Type</em> corresponds to the resulting expression type. In case either <em>VT1</em> or <em>VT2</em> is not a transpose sparse vector type, the resulting <em>Type</em> is set to <em>INVALID_TYPE</em>.  <a href="../../d2/d70/structblaze_1_1TSVecTSVecSubExprTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5d/structblaze_1_1BaseElementType.html">BaseElementType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the base element type of a given data type.Via this type trait it is possible to evaluate the base (fundamental) element type at the heart of a given data type. Examples:  <a href="../../d7/d5d/structblaze_1_1BaseElementType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df4/structblaze_1_1CanAlias.html">CanAlias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check to evaluate the potential danger of aliasing effects.Via this type trait it is possible to evaluate the potential risk of aliasing problems of the given type. In case the given type potentially causes aliasing problems, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/df4/structblaze_1_1CanAlias.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d6d/structblaze_1_1IsBlasCompatible.html">IsBlasCompatible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is a data type compatible to the BLAS standard. The BLAS standard currently only supports float, double, complex&lt;float&gt; and complex&lt;double&gt; values. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type is BLAS compatible, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d6d/structblaze_1_1IsBlasCompatible.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html">IsColumnMajorMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for column-major matrix types.This type trait tests whether or not the given template argument is a column-major dense or sparse matrix type (i.e., a matrix whose storage order is set to <em>true</em>). In case the type is a column-major matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">IsComputation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a computational expression template.This type trait class tests whether or not the given type <em>Type</em> is a computational expression template (i.e. a mathematical operation such as an addition, a subtraction, a multiplication, a division, an absolute value calculation, ...). In order to qualify as a valid computational expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class. In case the given type is a valid computational expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/daf/structblaze_1_1IsComputation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">IsDenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for dense matrix types.This type trait tests whether or not the given template parameter is a dense, N-dimensional matrix type. In case the type is a dense matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">IsDenseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for dense vector types.This type trait tests whether or not the given template parameter is a dense, N-dimensional vector type. In case the type is a dense vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d50/structblaze_1_1IsDenseVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">IsExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an expression template.This type trait class tests whether or not the given type <em>Type</em> is a Blaze expression template or not. In order to qualify as a valid expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class. In case the given type is a valid expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d44/structblaze_1_1IsExpression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html">IsMatMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for expression types.This type trait tests whether or not the given template parameter is a type representing a matrix-matrix addition. In case the type is a matrix-matrix addition expression, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for expression types.This type trait tests whether or not the given template parameter is a type representing a matrix-matrix multiplication. In case the type is a matrix-matrix multiplication expression, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html">IsMatMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for expression types.This type trait tests whether or not the given template parameter is a type representing a matrix-matrix subtraction. In case the type is a matrix-matrix subtraction expression, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d44/structblaze_1_1IsMatrix.html">IsMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for matrix types.This type trait tests whether or not the given template parameter is a N-dimensional dense or sparse matrix type. In case the type is a matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d44/structblaze_1_1IsMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html">IsMatVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for expression types.This type trait tests whether or not the given template parameter is a type representing a matrix-vector multiplication. In case the type is a matrix-vector multiplication expression, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9b/structblaze_1_1IsResizable.html">IsResizable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for resizable data types.This type trait tests whether the given data type is a resizable data type. In case the data type can be resized (via the resize() function), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../db/d9b/structblaze_1_1IsResizable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html">IsRowMajorMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for row-major matrix types.This type trait tests whether or not the given template argument is a row-major dense or sparse matrix type (i.e., a matrix whose storage order is set to <em>true</em>). In case the type is a row-major matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">IsSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for sparse matrix types.This type trait tests whether or not the given template parameter is a sparse, N-dimensional matrix type. In case the type is a sparse matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d80/structblaze_1_1IsSparseMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">IsSparseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for sparse vector types.This type trait tests whether or not the given template parameter is a sparse, N-dimensional vector type. In case the type is a sparse vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/de1/structblaze_1_1IsSparseVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dca/structblaze_1_1IsTemporary.html">IsTemporary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a temporary vector or matrix type.This type trait class tests whether the given type is a temporary vector or matrix type, i.e. can be used for a temporary vector or matrix. In case the given type can be used as temporary, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/dca/structblaze_1_1IsTemporary.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd4/structblaze_1_1IsTransposeVector.html">IsTransposeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for transpose vector types.This type trait tests whether or not the given template argument is a transpose dense or sparse vector type (i.e., a vector whose transposition flag is set to 1). In case the type is a transpose vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/dd4/structblaze_1_1IsTransposeVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html">IsTVecMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for expression types.This type trait tests whether or not the given template parameter is a type representing a vector-matrix multiplication. In case the type is a vector-matrix multiplication expression, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de4/structblaze_1_1IsVector.html">IsVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vector types.This type trait tests whether or not the given template parameter is a N-dimensional dense or sparse vector type. In case the type is a vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/de4/structblaze_1_1IsVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html">IsVecVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for expression types.This type trait tests whether or not the given template parameter is a type representing a vector-vector addition. In case the type is a vector-vector addition expression, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html">IsVecVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for expression types.This type trait tests whether or not the given template parameter is a type representing a vector-vector multiplication. In case the type is a vector-vector multiplication expression, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html">IsVecVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for expression types.This type trait tests whether or not the given template parameter is a type representing a vector-vector subtraction. In case the type is a vector-vector subtraction expression, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check to query the requirement to evaluate an expression.Via this type trait it is possible to determine whether a given vector or matrix expression type requires an intermediate evaluation in the context of a compound expression. In case the given type requires an evaluation, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/df1/structblaze_1_1RequiresEvaluation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d85/classblaze_1_1AlignedStorage.html">AlignedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD data type with a fixed alignment.The <a class="el" href="../../d1/d85/classblaze_1_1AlignedStorage.html" title="POD data type with a fixed alignment.The AlignedStorage class template represents a POD data type wit...">AlignedStorage</a> class template represents a POD data type with a fixed alignment. Via this class it is possible to enforce a specific, type-based alignment for static data types. The required alignment is evaluated based on the given data type <em>T</em>. In case <em>T</em> is a built-in, vectorizable data type, <a class="el" href="../../d1/d85/classblaze_1_1AlignedStorage.html" title="POD data type with a fixed alignment.The AlignedStorage class template represents a POD data type wit...">AlignedStorage</a> enforces an alignment of 16 or 32 bytes, depending on the active SSE/AVX level. In all other cases, no specific alignment is enforced.  <a href="../../d1/d85/classblaze_1_1AlignedStorage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dfd/structblaze_1_1AlignmentTrait.html">AlignmentTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the required alignment of the given data type.The <a class="el" href="../../db/dfd/structblaze_1_1AlignmentTrait.html" title="Evaluation of the required alignment of the given data type.The AlignmentTrait class template evaluat...">AlignmentTrait</a> class template evaluates the required alignment for the given data type. For instance, for fundamental data types that can be vectorized via SSE or AVX instructions, the proper alignment is 16 or 32 bytes, respectively. For all other data types, a multiple of the alignment chosen by the compiler is returned. The evaluated alignment can be queried via the nested <em>value</em> member.  <a href="../../db/dfd/structblaze_1_1AlignmentTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html">DisableIfTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is Not An Error (SFINAE) class.The <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is Not An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../df/df2/structblaze_1_1DisableIfTrue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is Not An Error (SFINAE) class.The <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is Not An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d6/d36/structblaze_1_1DisableIf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da5/structblaze_1_1EmptyType.html">EmptyType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty data type for utility purposes.  <a href="../../d7/da5/structblaze_1_1EmptyType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html">EnableIfTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is Not An Error (SFINAE) class.The <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is Not An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d7/d2c/structblaze_1_1EnableIfTrue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is Not An Error (SFINAE) class.The <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is Not An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d9/d28/structblaze_1_1EnableIf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a string wrapper.The <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class is a wrapper class for the purpose to read input strings delimited by quotations from streams, like for instance "example input". All characters between the leading and the trailing quotation are extracted unchanged from the input stream, including whitespaces. The input string has to be in one single line. In case of input errors, the <em>std::istream::failbit</em> of the input stream is set.  <a href="../../da/dfc/classblaze_1_1InputString.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dea/structblaze_1_1Limits.html">Limits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical limits of built-in data types.The <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">Limits</a> class provides numerical limits for the following built-in data types:  <a href="../../d9/dea/structblaze_1_1Limits.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/classblaze_1_1MemoryPool.html">MemoryPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory pool for small objects.The memory pool efficiently improves the performance of dynamic memory allocations for small objects. By allocating a large block of memory that can be dynamically assigned to small objects, the memory allocation is reduced from a few hundred cycles to only a few cycles.<br/>
 The memory pool is build from memory blocks of type <a class="el" href="../../d2/d64/structblaze_1_1MemoryPool_1_1Block.html" title="Memory block within the memory bool.">Block</a>, which hold the memory for a specified number of objects. The memory of these blocks is managed as a single free list.  <a href="../../d2/d8d/classblaze_1_1MemoryPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dff/structblaze_1_1EqualTo.html">EqualTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type value comparison.The <a class="el" href="../../d4/dff/structblaze_1_1EqualTo.html" title="Compile time type value comparison.The EqualTo class templates evaluates whether the two given condit...">EqualTo</a> class templates evaluates whether the two given conditions <em>T1</em> and <em>T2</em> are equal to each other. In case <em>T1::value</em> is equal to <em>T2::value</em>, the <em>value</em> member enumeration is set to 1, otherwise it is set to 0.  <a href="../../d4/dff/structblaze_1_1EqualTo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type selection.The <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html" title="Compile time type selection.The IfTrue class template selects one of the two given types T1 and T2 de...">IfTrue</a> class template selects one of the two given types <em>T1</em> and <em>T2</em> depending on the <em>Condition</em> template argument. In case the <em>Condition</em> compile time constant expression evaluates to <em>true</em>, the member type definition <em>Type</em> is set to <em>T1</em>. In case <em>Condition</em> evaluates to <em>false</em>, <em>Type</em> is set to <em>T2</em>.  <a href="../../de/d6e/structblaze_1_1IfTrue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type selection.The <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> class template selects one of the two given types <em>T2</em> and <em>T3</em> depending on <em>T1</em>. In case <em>T1::value</em> evaluates to <em>true</em>, the member type definition <em>Type</em> is set to <em>T2</em>. In case <em>T1::value</em> evaluates to <em>false</em>, <em>Type</em> is set to <em>T3</em>.  <a href="../../d7/d0c/structblaze_1_1If.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d28/structblaze_1_1IfNot.html">IfNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type value comparison.The <a class="el" href="../../d3/d28/structblaze_1_1IfNot.html" title="Compile time type value comparison.The IfNot class template selects one of the two given types T2 and...">IfNot</a> class template selects one of the two given types <em>T2</em> and <em>T3</em> depending on <em>T1</em>. In case <em>T1::value</em> evaluates to <em>false</em>, the member type definition <em>Type</em> is set to <em>T2</em>. In case <em>T1::value</em> evaluates to <em>true</em>, <em>Type</em> is set to <em>T3</em>.  <a href="../../d3/d28/structblaze_1_1IfNot.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d4f/structblaze_1_1NotEqualTo.html">NotEqualTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type value comparison.The <a class="el" href="../../d8/d4f/structblaze_1_1NotEqualTo.html" title="Compile time type value comparison.The NotEqualTo class templates evaluates whether the two given con...">NotEqualTo</a> class templates evaluates whether the two given conditions <em>T1</em> and <em>T2</em> are not equal to each other. In case <em>T1::value</em> is not equal to <em>T2::value</em>, the <em>value</em> member enumeration is set to 1, otherwise it is set to 0.  <a href="../../d8/d4f/structblaze_1_1NotEqualTo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html">NonCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-copyable class instances.The <a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html" title="Base class for non-copyable class instances.The NonCopyable class is intended to work as a base class...">NonCopyable</a> class is intended to work as a base class for non-copyable classes. Both the copy constructor and the copy assignment operator are declared private and left undefined in order to prohibit copy operations of the derived classes.<br/>
.  <a href="../../dd/dbc/classblaze_1_1NonCopyable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/classblaze_1_1NonCreatable.html">NonCreatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-creatable (static) classes.The <a class="el" href="../../d6/d8e/classblaze_1_1NonCreatable.html" title="Base class for non-creatable (static) classes.The NonCreatable class is intended to work as a base cl...">NonCreatable</a> class is intended to work as a base class for non-creatable classes, i.e. classes that cannot be instantiated and exclusively offer static functions/data. Both the standard as well as the copy constructor and the copy assignment operator are declared private and left undefinded in order to prohibit the instantiation of objects of derived classes.<br/>
.  <a href="../../d6/d8e/classblaze_1_1NonCreatable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d82/classblaze_1_1Null.html">Null</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL pointer in C++. For this, the NULL macro is replaced by an instance of the <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a> class, which can only be assigned and compared with pointers and pointers-to-member. Therefore the use of NULL regains the type safety it lost in C++ due to the strict C++ type system.<br/>
 The NULL pointer is used exactly as before:  <a href="../../dd/d82/classblaze_1_1Null.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da4/classblaze_1_1NullType.html">NullType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type for generic codes.The <a class="el" href="../../dd/da4/classblaze_1_1NullType.html" title="Utility type for generic codes.The NullType class represents an invalid or terminating data type for ...">NullType</a> class represents an invalid or terminating data type for generic codes. For instance, the <a class="el" href="../../df/d88/structblaze_1_1TypeList.html" title="Implementation of a type list.The TypeList class is an implementation of a type list according to the...">TypeList</a> class uses the <a class="el" href="../../dd/da4/classblaze_1_1NullType.html" title="Utility type for generic codes.The NullType class represents an invalid or terminating data type for ...">NullType</a> as terminating data type for the type list.  <a href="../../dd/da4/classblaze_1_1NullType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html">ArrayDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-delete policy class.The <a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> policy functor class applies an array delete operation to the given argument. Note that the array delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply an <a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> functor to a pointer to an array of objects of incomplete type results in a compile time error!  <a href="../../d0/d60/structblaze_1_1ArrayDelete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d70/structblaze_1_1ConstantGrowth.html">ConstantGrowth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant growth policy class.The <a class="el" href="../../d3/d70/structblaze_1_1ConstantGrowth.html" title="Constant growth policy class.The ConstantGrowth policy class implements a constant growth strategy...">ConstantGrowth</a> policy class implements a constant growth strategy. It can be customized for any purpose: the <em>Growth</em> template argument specifies the constant increase of the given size.  <a href="../../d3/d70/structblaze_1_1ConstantGrowth.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4f/structblaze_1_1LinearGrowth.html">LinearGrowth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear growth policy class.The <a class="el" href="../../df/d4f/structblaze_1_1LinearGrowth.html" title="Linear growth policy class.The LinearGrowth policy class implements a linear growth strategy...">LinearGrowth</a> policy class implements a linear growth strategy. It can be customized for any purpose: the <em>Growth</em> template argument specifies the factor of the size growth.  <a href="../../df/d4f/structblaze_1_1LinearGrowth.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html">NoDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-delete policy class.  <a href="../../d8/dc7/structblaze_1_1NoDelete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3f/structblaze_1_1OptimalGrowth.html">OptimalGrowth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimal growth policy class.The <a class="el" href="../../d2/d3f/structblaze_1_1OptimalGrowth.html" title="Optimal growth policy class.The OptimalGrowth policy class implements the optimal growth strategy sug...">OptimalGrowth</a> policy class implements the optimal growth strategy suggested by Andrew Koenig for the std::vector class (see Andrew Koenig's column in the September 1998 issue of JOOP (Journal of Object-Oriented Programming), or the Dr. Dobb's article 'C++ Made Easier: How Vectors Grow', 2001). It applies an exponential growth strategy using a factor of 1.5 and additionally ensures that the sizes returns are always multiples of four.  <a href="../../d2/d3f/structblaze_1_1OptimalGrowth.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html">PtrDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer-delete policy class.The <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> policy functor class applies a delete operation to the given argument. Note that the delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply a <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> functor to a pointer to an object of incomplete type results in a compile time error!  <a href="../../d9/d94/structblaze_1_1PtrDelete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an iterator for pointer vectors.The <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> class follows the example of the random-access iterator classes of the STL. However, the focus of this iterator implementation is the use with (polymorphic) pointers. The implementation of the Blaze library eases the use of iterators over a range of pointers and improves the semantics on these pointers.<br/>
.  <a href="../../d2/d15/classblaze_1_1PtrIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a vector for (polymorphic) pointers.  <a href="../../d3/ddf/classblaze_1_1PtrVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number generator.The <a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> class encapsulates the initialization of the given random number generator with a pseudo-random seed obtained by the std::time() function. Currently, the mersenne-twister mt19937 as provided by the boost library is used per default. For more information see the class description of the boost library:  <a href="../../d0/dc4/classblaze_1_1Random.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dca/classblaze_1_1Rand.html">Rand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the <a class="el" href="../../db/dca/classblaze_1_1Rand.html" title="Default implementation of the Rand class for integral data types.This default implementation of the R...">Rand</a> class for integral data types.This default implementation of the <a class="el" href="../../db/dca/classblaze_1_1Rand.html" title="Default implementation of the Rand class for integral data types.This default implementation of the R...">Rand</a> class creates random, integral numbers in the range <img class="formulaInl" alt="$ [0..max] $" src="../../form_166.png"/>, where <em>max</em> is the maximal value of the given data type <em>T</em>.  <a href="../../db/dca/classblaze_1_1Rand.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc1/structblaze_1_1SelectType.html">SelectType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type selection.The <a class="el" href="../../da/dc1/structblaze_1_1SelectType.html" title="Compile time type selection.The SelectType class template selects one of the two given types T1 and T...">SelectType</a> class template selects one of the two given types <em>T1</em> and <em>T2</em> depending on the <em>Select</em> template argument. In case the <em>Select</em> compile time constant expression evaluates to <em>true</em>, the member type definition <em>Type</em> is set to <em>T1</em>. In case <em>Select</em> evaluates to <em>false</em>, <em>Type</em> is set to <em>T2</em>.  <a href="../../da/dc1/structblaze_1_1SelectType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d31/classblaze_1_1Dependency.html">Dependency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifetime dependency on a singleton object.The <a class="el" href="../../d4/d31/classblaze_1_1Dependency.html" title="Lifetime dependency on a singleton object.The Dependency template class represents a lifetime depende...">Dependency</a> template class represents a lifetime dependency on a singleton object based on the Blaze <a class="el" href="../../d4/d8d/classblaze_1_1Singleton.html" title="Base class for all lifetime managed singletons.The Singleton class represents the base class for all ...">Singleton</a> functionality. By use of the <a class="el" href="../../d4/d31/classblaze_1_1Dependency.html" title="Lifetime dependency on a singleton object.The Dependency template class represents a lifetime depende...">Dependency</a> template, any class can by either public or non-public inheritance or composition define a single or multiple lifetime dependencies on one or several singletons, which guarantees that the singleton instance(s) will be destroyed after the dependent object. The following example demonstrates both the inheritance as well as the composition approach:  <a href="../../d4/d31/classblaze_1_1Dependency.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8d/classblaze_1_1Singleton.html">Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all lifetime managed singletons.The <a class="el" href="../../d4/d8d/classblaze_1_1Singleton.html" title="Base class for all lifetime managed singletons.The Singleton class represents the base class for all ...">Singleton</a> class represents the base class for all lifetime managed singletons of the Blaze library. Classes, which are supposed to be implemented in terms of the singleton pattern, only have to derive from this class in order to gain all basic characteristics of a singleton:  <a href="../../d4/d8d/classblaze_1_1Singleton.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d81/structblaze_1_1SizeTrait.html">SizeTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d6/d81/structblaze_1_1SizeTrait.html" title="Base template for the SizeTrait class.The SizeTrait class template evaluates the larger of the two gi...">SizeTrait</a> class.The <a class="el" href="../../d6/d81/structblaze_1_1SizeTrait.html" title="Base template for the SizeTrait class.The SizeTrait class template evaluates the larger of the two gi...">SizeTrait</a> class template evaluates the larger of the two given data types by use of the sizeof operator. <a class="el" href="../../d6/d81/structblaze_1_1SizeTrait.html" title="Base template for the SizeTrait class.The SizeTrait class template evaluates the larger of the two gi...">SizeTrait</a> defines the data types <em>Large</em> for the larger of the two given data types and <em>Small</em> for the smaller data type. In case both data types have the same size, the first given data type <em>T1</em> is chosen as the large and <em>T2</em> as the small data type.  <a href="../../d6/d81/structblaze_1_1SizeTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html">SystemClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">System clock of the Blaze library.The <a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html" title="System clock of the Blaze library.The SystemClock class represents the system clock of the Blaze libr...">SystemClock</a> class represents the system clock of the Blaze library. The system clock is the central timing functionality that can be used to query for the start time of the process, the current timestamp and the elapsed time since the start of the process. The following example demonstrates how the single system clock instance is acquired via the <a class="el" href="../../d4/d3a/group__util.html#ga0547f7041f58ea87ba920e520236bd12" title="Returns a handle to the Blaze system clock.">theSystemClock()</a> functcion and how the system clock can be used:  <a href="../../dd/dc7/classblaze_1_1SystemClock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7d/classblaze_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a single thread of execution.  <a href="../../de/d7d/classblaze_1_1Thread.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a thread pool.  <a href="../../db/d38/classblaze_1_1ThreadPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d88/structblaze_1_1TypeList.html">TypeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a type list.The <a class="el" href="../../df/d88/structblaze_1_1TypeList.html" title="Implementation of a type list.The TypeList class is an implementation of a type list according to the...">TypeList</a> class is an implementation of a type list according to the example of Andrei Alexandrescu. The type list merely consists of the two data types <em>Head</em> and <em>Tail</em>. In order to create type lists of more data types, the <a class="el" href="../../df/d88/structblaze_1_1TypeList.html" title="Implementation of a type list.The TypeList class is an implementation of a type list according to the...">TypeList</a> class is used recursively:  <a href="../../df/d88/structblaze_1_1TypeList.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d90/structblaze_1_1HasSize.html">HasSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of a type at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> is exactly <em>Size</em> bytes large, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d90/structblaze_1_1HasSize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html">Has1Byte</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly one byte. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has one byte, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d94/structblaze_1_1Has1Byte.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html">Has2Bytes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly two bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has two bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d49/structblaze_1_1Has2Bytes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html">Has4Bytes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d99/structblaze_1_1Has4Bytes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html">Has8Bytes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1Has8Bytes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html">HaveSameSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of two types at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> an object of type <em>T1</em> has the same size as an object of type <em>T2</em>, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d76/classblaze_1_1HaveSameSize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html">IsArithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for arithmetic data types.This type trait tests whether or not the given template parameter is a (possibly cv-qualified) arithmetic (integral or floating point) data type. In case the type is an arithmetic type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dc/daf/structblaze_1_1IsArithmetic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html">IsBaseOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relationship between the two types <em>Base</em> and <em>Derived</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>Derived</em> is a type derived from <em>Base</em> or the same type as <em>Base</em> the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d07/classblaze_1_1IsBaseOf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html">IsBoolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for boolean types.This type trait tests whether or not the given template parameter is of boolean type. In case the type is a boolean (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d48/structblaze_1_1IsBoolean.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">IsBuiltin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for built-in data types.This type trait tests whether or not the given template parameter is a built-in/fundamental data type. In case the type is a built-in type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d1c/structblaze_1_1IsBuiltin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html">IsCharacter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for character types.This type trait tests whether or not the given template parameter is a character type (i.e., either char, signed char, unsigned char, or wchar_t, possibly cv-qualified). In case the type is a character type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d32/structblaze_1_1IsCharacter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d97/structblaze_1_1IsClass.html">IsClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> type trait tests whether or not the given template parameter is a (possibly cv-qualified) class type. In case the given data type is a class type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dd/d97/structblaze_1_1IsClass.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">IsComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for complex types.This type trait tests whether or not the given template parameter is a complex data type. In case the type is a complex data type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/da9/structblaze_1_1IsComplex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html">IsConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for constant data types.The <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> type trait tests whether or not the given template parameter is a (top level) const-qualified data type. In case the given data type is const-qualified, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d5f/structblaze_1_1IsConst.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html">IsConvertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time pointer relationship constraint.This type traits tests whether the first given template argument can be converted to the second template argument via copy construction. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the first argument can be converted to the second argument, the <em>value</em> member enumeration is set to 1, the nested type definition <em>type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d98/structblaze_1_1IsConvertible.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d60/structblaze_1_1IsDouble.html">IsDouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for double precision floating point types.This type trait tests whether or not the given template parameter is of double type. In case the type is double (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d60/structblaze_1_1IsDouble.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d07/structblaze_1_1IsFloat.html">IsFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision floating point types.This type trait tests whether or not the given template parameter is of float type. In case the type is float (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d07/structblaze_1_1IsFloat.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html">IsFloatingPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for floating point data types.This type trait tests whether or not the given template parameter is a floating point data type (ignoring the cv-qualifiers). In case the type is a floating point data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html">IsInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integer types.This type trait tests whether or not the given template parameter is an integer type (i.e., either (signed) int or unsigned int, possibly cv-qualified). In case the type is an integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d5e/structblaze_1_1IsInteger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integral data types.This type trait tests whether or not the given template parameter is an integral data type. In case the type is an integral data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d73/structblaze_1_1IsIntegral.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d40/structblaze_1_1IsLong.html">IsLong</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for long integer types.This type trait tests whether or not the given template parameter is a long integer type (i.e., either (signed) long or unsigned long, possibly cv-qualified). In case the type is a long integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d40/structblaze_1_1IsLong.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html">IsLongDouble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for extended precision floating point types.This type trait tests whether or not the given template parameter is of long double type. In case the type is long double (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d34/structblaze_1_1IsLongDouble.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric types.This type trait tests whether or not the given template parameter is a numeric data type. Blaze considers all integral (except <em>bool</em>), floating point, and complex data types as numeric data types. In case the type is a numeric type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/dea/structblaze_1_1IsNumeric.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db8/structblaze_1_1IsObject.html">IsObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is an object type. All types are considered object types except references, <em>void</em>, and function types. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>T</em> is an object type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/db8/structblaze_1_1IsObject.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db0/structblaze_1_1IsPod.html">IsPod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for pod data types.This type trait tests whether or not the given template parameter is a POD (Plain Old Data) or not. In case the type is a POD, the <em>value</em> member enumeration is set o 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/db0/structblaze_1_1IsPod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html">IsPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a pointer type (including function pointers, but excluding pointers to members) or not. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a pointer type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d0f/structblaze_1_1IsPointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dad/structblaze_1_1IsReference.html">IsReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is a reference type (including references to functions). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a reference type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/dad/structblaze_1_1IsReference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html">IsStrictlySame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are not ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type, then the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1IsStrictlySame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d89/structblaze_1_1IsSame.html">IsSame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type (ignoring the cv-qualifiers), then the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d89/structblaze_1_1IsSame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d59/structblaze_1_1IsShort.html">IsShort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for short integer types.This type trait tests whether or not the given template parameter is a short integer type (i.e., either (signed) short or unsigned short, possibly cv-qualified). In case the type is a short integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d59/structblaze_1_1IsShort.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/def/structblaze_1_1IsSigned.html">IsSigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for signed data types.This type trait tests whether or not the given template parameter is a signed integral data type. In case the type is a signed (possibly cv-qualified) data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/def/structblaze_1_1IsSigned.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html">IsUnsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unsigned data types.This type trait tests whether or not the given template parameter is an unsigned, integral data type. In case the type is an unsigned (possibly cv-qualified) data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d8c/structblaze_1_1IsUnsigned.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html">IsVectorizable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vectorizable types.Depending on the available instruction set (SSE, SSE2, AVX, MIC, ...), this type trait tests whether or not the given template parameter is a vectorizable type, i.e. a type for which intrinsic vector operations and optimizations can be used. Currently, only signed/unsigned short, signed/unsigned int, signed/unsigned long, float, and double are considered to be vectorizable types. In case the type is vectorizable, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsVectorizable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html">IsVoid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <em>void</em> data type.This type trait tests whether or not the given template parameter is of type <em>void</em> (ignoring the cv-qualifiers). In case the type is of type <em>void</em>, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d6b/structblaze_1_1IsVoid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html">IsVolatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for volatile data types.The <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> type trait tests whether or not the given template parameter is a (top level) volatile-qualified data type. In case the given data type is volatile, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/db9/structblaze_1_1IsVolatile.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">RemoveConst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of const-qualifiers.The <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait removes all top level 'const' qualifiers from the given type <em>T</em>.  <a href="../../d9/d25/structblaze_1_1RemoveConst.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">RemoveCV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level cv-qualifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes all top level cv-qualifiers from the given type <em>T</em>.  <a href="../../d0/d1c/structblaze_1_1RemoveCV.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">RemovePointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of pointer modifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes any pointer modifiers from the given type <em>T</em>.  <a href="../../df/d04/structblaze_1_1RemovePointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">RemoveReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of reference modifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes any reference modifiers from the given type <em>T</em>.  <a href="../../d5/df4/structblaze_1_1RemoveReference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">RemoveVolatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of volatile-qualifiers.The <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait removes all top level 'volatile' qualifiers from the given type <em>T</em>.  <a href="../../d9/de6/structblaze_1_1RemoveVolatile.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-in unsigned integral type in order to be able to extract non-negative unsigned integral values from an input stream.  <a href="../../da/d54/classblaze_1_1UnsignedValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d20/structblaze_1_1IsEven.html">IsEven</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether a compile time constant expression is even.This value trait tests whether the given integral value <em>N</em> is an even value. In case the value is even, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d20/structblaze_1_1IsEven.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d04/structblaze_1_1IsOdd.html">IsOdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether a compile time constant expression is odd.This value trait tests whether the given integral value <em>N</em> is an odd value. In case the value is odd, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d04/structblaze_1_1IsOdd.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d6c/structblaze_1_1IsPowerOf.html">IsPowerOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for a power relationship of integral values to a given base.This value trait tests whether the given integral value <em>N</em> is a power of the base <em>B</em> according to the equation <img class="formulaInl" alt="$ B^x = N $" src="../../form_169.png"/>, where x is any positive integer in the range <img class="formulaInl" alt="$ [0..\infty) $" src="../../form_170.png"/>. In case the value is a power of <em>B</em>, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d6c/structblaze_1_1IsPowerOf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d71/classblaze_1_1sse__int8__t.html">sse_int8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type for 8-bit integral data values.  <a href="../../d5/d71/classblaze_1_1sse__int8__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7f/classblaze_1_1sse__int16__t.html">sse_int16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type for 16-bit integral data values.  <a href="../../de/d7f/classblaze_1_1sse__int16__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc9/classblaze_1_1sse__int32__t.html">sse_int32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type for 32-bit integral data values.  <a href="../../d4/dc9/classblaze_1_1sse__int32__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db7/classblaze_1_1sse__int64__t.html">sse_int64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type for 64-bit integral data values.  <a href="../../d1/db7/classblaze_1_1sse__int64__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d42/classblaze_1_1sse__float__t.html">sse_float_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type for 32-bit single precision floating point data values.  <a href="../../df/d42/classblaze_1_1sse__float__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd0/classblaze_1_1sse__double__t.html">sse_double_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type for 64-bit double precision floating point data values.  <a href="../../d4/dd0/classblaze_1_1sse__double__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d1e/classblaze_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex data type of the Blaze library.  <a href="../../d3/d1e/classblaze_1_1complex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dee/classblaze_1_1Length.html">Length</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculating the length of a type list.The <a class="el" href="../../db/dee/classblaze_1_1Length.html" title="Calculating the length of a type list.The Length class can be used to obtain the length of a type lis...">Length</a> class can be used to obtain the length of a type list (i.e. the number of contained types). In order to obtain the length of a type list, the <a class="el" href="../../db/dee/classblaze_1_1Length.html" title="Calculating the length of a type list.The Length class can be used to obtain the length of a type lis...">Length</a> class has to be instantiated for a particular type list. The length of the type list can be obtained using the member enumeration <em>value</em>. The following example gives an impression of the use of the <a class="el" href="../../db/dee/classblaze_1_1Length.html" title="Calculating the length of a type list.The Length class can be used to obtain the length of a type lis...">Length</a> class:  <a href="../../db/dee/classblaze_1_1Length.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d79/classblaze_1_1TypeAt.html">TypeAt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexing a type list.The <a class="el" href="../../d6/d79/classblaze_1_1TypeAt.html" title="Indexing a type list.The TypeAt class can be used to access a type list at a specified position to qu...">TypeAt</a> class can be used to access a type list at a specified position to query the according type. In order to index a type list, the <a class="el" href="../../d6/d79/classblaze_1_1TypeAt.html" title="Indexing a type list.The TypeAt class can be used to access a type list at a specified position to qu...">TypeAt</a> class has to be instantiated for a particular type list and an index value. The indexed type is available via the member type definition <em>Result</em>. The following example gives an impression of the use of the <a class="el" href="../../d6/d79/classblaze_1_1TypeAt.html" title="Indexing a type list.The TypeAt class can be used to access a type list at a specified position to qu...">TypeAt</a> class:  <a href="../../d6/d79/classblaze_1_1TypeAt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d43/classblaze_1_1Contains.html">Contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searching a type list.The <a class="el" href="../../df/d43/classblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class can be used to search the type list for a particular type <em>Type</em>. In contrast to the <a class="el" href="../../d6/d56/classblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class, the <a class="el" href="../../df/d43/classblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class does not evaluate the index of the type but only checks whether or not the type is contained in the type list. Additionally, in contrast to the <a class="el" href="../../d6/df4/classblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class, the <a class="el" href="../../df/d43/classblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class strictly searches for the given type <em>Type</em> and not for a related data type. In case the type is contained in the type list, the <em>value</em> member enumeration is set to 1, else it is set to 0. In order to check whether a type is part of a type list, the <a class="el" href="../../df/d43/classblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class has to be instantiated for a particular type list and another type. The following example gives an impression of the use of the <a class="el" href="../../df/d43/classblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class:  <a href="../../df/d43/classblaze_1_1Contains.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df4/classblaze_1_1ContainsRelated.html">ContainsRelated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searching a type list.The <a class="el" href="../../d6/df4/classblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class can be used to search the type list for a type related to <em>Type</em>. In contrast to the <a class="el" href="../../df/d43/classblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> class, the <a class="el" href="../../d6/df4/classblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class only searches for a type the given data type <em>Type</em> can be converted to. In case a related type is found in the type list, the <em>value</em> member enumeration is set to 1, else it is set to 0. In order to check whether a related type is contained in the type list, the <a class="el" href="../../d6/df4/classblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class has to be instantiated for a particular type list and another type. The following example gives an impression of the use of the <a class="el" href="../../d6/df4/classblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> class:  <a href="../../d6/df4/classblaze_1_1ContainsRelated.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d56/classblaze_1_1IndexOf.html">IndexOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searching a type list.The <a class="el" href="../../d6/d56/classblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class can be used to search the type list for a particular type <em>Type</em>. In contrast to the <a class="el" href="../../df/d43/classblaze_1_1Contains.html" title="Searching a type list.The Contains class can be used to search the type list for a particular type Ty...">Contains</a> and the <a class="el" href="../../d6/df4/classblaze_1_1ContainsRelated.html" title="Searching a type list.The ContainsRelated class can be used to search the type list for a type relate...">ContainsRelated</a> classes, the <a class="el" href="../../d6/d56/classblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class evaluates the index of the given type in the type list. In case the type is contained in the type list, the <em>value</em> member represents the index of the queried type. Otherwise the <em>value</em> member is set to -1. In order to search for a type, the <a class="el" href="../../d6/d56/classblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class has to be instantiated for a particular type list and a search type. The following example gives an impression of the use of the <a class="el" href="../../d6/d56/classblaze_1_1IndexOf.html" title="Searching a type list.The IndexOf class can be used to search the type list for a particular type Typ...">IndexOf</a> class:  <a href="../../d6/d56/classblaze_1_1IndexOf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dee/classblaze_1_1Append.html">Append</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appending a type to a type list.The <a class="el" href="../../d5/dee/classblaze_1_1Append.html" title="Appending a type to a type list.The Append class can be used to append the data type Type to a type l...">Append</a> class can be used to append the data type <em>Type</em> to a type list <em>TList</em>. In order to append a data type, the <a class="el" href="../../d5/dee/classblaze_1_1Append.html" title="Appending a type to a type list.The Append class can be used to append the data type Type to a type l...">Append</a> class has to be instantiated for a particular type list and another type. The following example gives an impression of the use of the <a class="el" href="../../d5/dee/classblaze_1_1Append.html" title="Appending a type to a type list.The Append class can be used to append the data type Type to a type l...">Append</a> class:  <a href="../../d5/dee/classblaze_1_1Append.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type of the Blaze library.  <a href="../../d9/dcd/classblaze_1_1size__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">ptrdiff_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer difference type of the Blaze library.  <a href="../../d2/d8c/classblaze_1_1ptrdiff__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3b/classblaze_1_1int8__t.html">int8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integer type of the Blaze library.  <a href="../../d6/d3b/classblaze_1_1int8__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da1/classblaze_1_1uint8__t.html">uint8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned integer type of the Blaze library.  <a href="../../da/da1/classblaze_1_1uint8__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d66/classblaze_1_1int16__t.html">int16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integer type of the Blaze library.  <a href="../../d9/d66/classblaze_1_1int16__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3a/classblaze_1_1uint16__t.html">uint16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned integer type of the Blaze library.  <a href="../../de/d3a/classblaze_1_1uint16__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d2d/classblaze_1_1int32__t.html">int32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integer type of the Blaze library.  <a href="../../de/d2d/classblaze_1_1int32__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">uint32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integer type of the Blaze library.  <a href="../../d6/dba/classblaze_1_1uint32__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">int64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer type of the Blaze library.  <a href="../../d8/dc7/classblaze_1_1int64__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d68/classblaze_1_1uint64__t.html">uint64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned integer type of the Blaze library.  <a href="../../d5/d68/classblaze_1_1uint64__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa774f520d2b69fe578f63dd8e4ded3a5"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a></td></tr>
<tr class="memdesc:gaa774f520d2b69fe578f63dd8e4ded3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point data type of the Blaze library.This type definition offers the possibility to switch the floating point precision of the Blaze library between float, double and long double.  <a href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5"></a><br/></td></tr>
<tr class="separator:gaa774f520d2b69fe578f63dd8e4ded3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356b5fc73ed7b611169b7fd771e263a9"><td class="memItemLeft" align="right" valign="top">typedef boost::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga356b5fc73ed7b611169b7fd771e263a9">RNG</a></td></tr>
<tr class="memdesc:ga356b5fc73ed7b611169b7fd771e263a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the random number generator of the Blaze library.This type definition represents the type of the random number generated used in the Blaze library. The default random number generator is the boost::mt19937 mersenne-twister pseudo random number generator. For more information see the class description of the boost library:  <a href="../../d1/d44/group__config.html#ga356b5fc73ed7b611169b7fd771e263a9"></a><br/></td></tr>
<tr class="separator:ga356b5fc73ed7b611169b7fd771e263a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf8042d19f34f0b92991c1b5182776ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf8042d19f34f0b92991c1b5182776ef"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a><br class="typebreak"/>
&lt; float, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#gadf8042d19f34f0b92991c1b5182776ef">CMatMxNf</a></td></tr>
<tr class="memdesc:gadf8042d19f34f0b92991c1b5182776ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">MxN single precision matrix. <br/></td></tr>
<tr class="separator:gadf8042d19f34f0b92991c1b5182776ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27af73955dba011ffd3239b7f5af0a58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27af73955dba011ffd3239b7f5af0a58"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a><br class="typebreak"/>
&lt; double, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga27af73955dba011ffd3239b7f5af0a58">CMatMxNd</a></td></tr>
<tr class="memdesc:ga27af73955dba011ffd3239b7f5af0a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">MxN double precision matrix. <br/></td></tr>
<tr class="separator:ga27af73955dba011ffd3239b7f5af0a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649c2884e96069717e21f14616065ed4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga649c2884e96069717e21f14616065ed4"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga649c2884e96069717e21f14616065ed4">CMatMxN</a></td></tr>
<tr class="memdesc:ga649c2884e96069717e21f14616065ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">MxN matrix with system-specific precision. <br/></td></tr>
<tr class="separator:ga649c2884e96069717e21f14616065ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94ef6e8a7ee17e2e88c10c9a33f8b1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad94ef6e8a7ee17e2e88c10c9a33f8b1f"></a>
typedef <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a><br class="typebreak"/>
&lt; float, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gad94ef6e8a7ee17e2e88c10c9a33f8b1f">CVecNf</a></td></tr>
<tr class="memdesc:gad94ef6e8a7ee17e2e88c10c9a33f8b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed single precision vector. <br/></td></tr>
<tr class="separator:gad94ef6e8a7ee17e2e88c10c9a33f8b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1dd39a0823c251913f35e5fcb7da5ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad1dd39a0823c251913f35e5fcb7da5ec"></a>
typedef <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a><br class="typebreak"/>
&lt; double, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gad1dd39a0823c251913f35e5fcb7da5ec">CVecNd</a></td></tr>
<tr class="memdesc:gad1dd39a0823c251913f35e5fcb7da5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed double precision vector. <br/></td></tr>
<tr class="separator:gad1dd39a0823c251913f35e5fcb7da5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbcf90ff9fbab9ffbed0cd53dfb8698f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbcf90ff9fbab9ffbed0cd53dfb8698f"></a>
typedef <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gabbcf90ff9fbab9ffbed0cd53dfb8698f">CVecN</a></td></tr>
<tr class="memdesc:gabbcf90ff9fbab9ffbed0cd53dfb8698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed vector with system-specific precision. <br/></td></tr>
<tr class="separator:gabbcf90ff9fbab9ffbed0cd53dfb8698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02756b13a6281fecdae07754dba4fe14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga02756b13a6281fecdae07754dba4fe14"></a>
typedef <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; float, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#ga02756b13a6281fecdae07754dba4fe14">MatMxNf</a></td></tr>
<tr class="memdesc:ga02756b13a6281fecdae07754dba4fe14"><td class="mdescLeft">&#160;</td><td class="mdescRight">MxN single precision matrix. <br/></td></tr>
<tr class="separator:ga02756b13a6281fecdae07754dba4fe14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56feff2a454f4cc17ae16c826c3c125d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56feff2a454f4cc17ae16c826c3c125d"></a>
typedef <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; double, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#ga56feff2a454f4cc17ae16c826c3c125d">MatMxNd</a></td></tr>
<tr class="memdesc:ga56feff2a454f4cc17ae16c826c3c125d"><td class="mdescLeft">&#160;</td><td class="mdescRight">MxN double precision matrix. <br/></td></tr>
<tr class="separator:ga56feff2a454f4cc17ae16c826c3c125d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35391b557d6036fbc96d6c2e2365c545"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35391b557d6036fbc96d6c2e2365c545"></a>
typedef <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#ga35391b557d6036fbc96d6c2e2365c545">MatMxN</a></td></tr>
<tr class="memdesc:ga35391b557d6036fbc96d6c2e2365c545"><td class="mdescLeft">&#160;</td><td class="mdescRight">MxN matrix with system-specific precision. <br/></td></tr>
<tr class="separator:ga35391b557d6036fbc96d6c2e2365c545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9d5776bb858ba7ff844cdab3592b0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5c9d5776bb858ba7ff844cdab3592b0c"></a>
typedef <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; float, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html#ga5c9d5776bb858ba7ff844cdab3592b0c">VecNf</a></td></tr>
<tr class="memdesc:ga5c9d5776bb858ba7ff844cdab3592b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional single precision vector. <br/></td></tr>
<tr class="separator:ga5c9d5776bb858ba7ff844cdab3592b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7ed44ff7c67f1651652f5f488546aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5e7ed44ff7c67f1651652f5f488546aa"></a>
typedef <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; double, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html#ga5e7ed44ff7c67f1651652f5f488546aa">VecNd</a></td></tr>
<tr class="memdesc:ga5e7ed44ff7c67f1651652f5f488546aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional double precision vector. <br/></td></tr>
<tr class="separator:ga5e7ed44ff7c67f1651652f5f488546aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20a643700dcef788e21bc33ff23a2e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad20a643700dcef788e21bc33ff23a2e0"></a>
typedef <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, <br class="typebreak"/>
false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html#gad20a643700dcef788e21bc33ff23a2e0">VecN</a></td></tr>
<tr class="memdesc:gad20a643700dcef788e21bc33ff23a2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional vector with system-specific precision. <br/></td></tr>
<tr class="separator:gad20a643700dcef788e21bc33ff23a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799ee538a2f300937fb62483099d4c1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga799ee538a2f300937fb62483099d4c1a"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; short &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga799ee538a2f300937fb62483099d4c1a">sse_short_t</a></td></tr>
<tr class="memdesc:ga799ee538a2f300937fb62483099d4c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsic data type for 'short'. <br/></td></tr>
<tr class="separator:ga799ee538a2f300937fb62483099d4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce98e1c51b44e7ad2d0afb8eb6d0d63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ce98e1c51b44e7ad2d0afb8eb6d0d63"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a><br class="typebreak"/>
&lt; unsigned short &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga4ce98e1c51b44e7ad2d0afb8eb6d0d63">sse_ushort_t</a></td></tr>
<tr class="memdesc:ga4ce98e1c51b44e7ad2d0afb8eb6d0d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsic data type for 'unsigned short'. <br/></td></tr>
<tr class="separator:ga4ce98e1c51b44e7ad2d0afb8eb6d0d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72cf8946ebfa3fba4483b43ccf9ea46b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72cf8946ebfa3fba4483b43ccf9ea46b"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; int &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga72cf8946ebfa3fba4483b43ccf9ea46b">sse_int_t</a></td></tr>
<tr class="memdesc:ga72cf8946ebfa3fba4483b43ccf9ea46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsic data type for 'int'. <br/></td></tr>
<tr class="separator:ga72cf8946ebfa3fba4483b43ccf9ea46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b7e31bff92cad5a5bfe8554acf6446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1b7e31bff92cad5a5bfe8554acf6446"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a><br class="typebreak"/>
&lt; unsigned int &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gab1b7e31bff92cad5a5bfe8554acf6446">sse_uint_t</a></td></tr>
<tr class="memdesc:gab1b7e31bff92cad5a5bfe8554acf6446"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsic data type for 'unsigned int'. <br/></td></tr>
<tr class="separator:gab1b7e31bff92cad5a5bfe8554acf6446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2099ed501a417364a64ccbce6167e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b2099ed501a417364a64ccbce6167e8"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; long &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga6b2099ed501a417364a64ccbce6167e8">sse_long_t</a></td></tr>
<tr class="memdesc:ga6b2099ed501a417364a64ccbce6167e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsic data type for 'long int'. <br/></td></tr>
<tr class="separator:ga6b2099ed501a417364a64ccbce6167e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084ed7ba1d94828bb556b9aa6286c604"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga084ed7ba1d94828bb556b9aa6286c604"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a><br class="typebreak"/>
&lt; unsigned long &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga084ed7ba1d94828bb556b9aa6286c604">sse_ulong_t</a></td></tr>
<tr class="memdesc:ga084ed7ba1d94828bb556b9aa6286c604"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrinsic data type for 'unsigned long int'. <br/></td></tr>
<tr class="separator:ga084ed7ba1d94828bb556b9aa6286c604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97e6a3715225add2b6c686534e9604b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa97e6a3715225add2b6c686534e9604b"></a>
typedef <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#gaa97e6a3715225add2b6c686534e9604b">Quat</a></td></tr>
<tr class="memdesc:gaa97e6a3715225add2b6c686534e9604b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html" title="Efficient implementation of a quaternion.Quaternions are a superior way to deal with rotations and or...">Quaternion</a> of real type. <br/></td></tr>
<tr class="separator:gaa97e6a3715225add2b6c686534e9604b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe7389eb148b5dadf5e06e8e0e31860"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7fe7389eb148b5dadf5e06e8e0e31860"></a>
typedef <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga7fe7389eb148b5dadf5e06e8e0e31860">Rot3</a></td></tr>
<tr class="memdesc:ga7fe7389eb148b5dadf5e06e8e0e31860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation matrix of real type. <br/></td></tr>
<tr class="separator:ga7fe7389eb148b5dadf5e06e8e0e31860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac627b2d6800b097b98ea6bbc180d900b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac627b2d6800b097b98ea6bbc180d900b"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; float, 2UL, 2UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ac627b2d6800b097b98ea6bbc180d900b">Mat2x2f</a></td></tr>
<tr class="memdesc:ac627b2d6800b097b98ea6bbc180d900b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2x2 single precision matrix. <br/></td></tr>
<tr class="separator:ac627b2d6800b097b98ea6bbc180d900b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26af3fa3c65992af98e575e36cdb785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26af3fa3c65992af98e575e36cdb785"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; double, 2UL, 2UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ae26af3fa3c65992af98e575e36cdb785">Mat2x2d</a></td></tr>
<tr class="memdesc:ae26af3fa3c65992af98e575e36cdb785"><td class="mdescLeft">&#160;</td><td class="mdescRight">2x2 double precision matrix. <br/></td></tr>
<tr class="separator:ae26af3fa3c65992af98e575e36cdb785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfaf57d6a7dd4955f867b2594e38700"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bfaf57d6a7dd4955f867b2594e38700"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, 2UL, 2UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a1bfaf57d6a7dd4955f867b2594e38700">Mat2x2</a></td></tr>
<tr class="memdesc:a1bfaf57d6a7dd4955f867b2594e38700"><td class="mdescLeft">&#160;</td><td class="mdescRight">2x2 matrix with system-specific precision. <br/></td></tr>
<tr class="separator:a1bfaf57d6a7dd4955f867b2594e38700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d692d9066b395b37d60b98333c6441e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d692d9066b395b37d60b98333c6441e"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; float, 3UL, 3UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7d692d9066b395b37d60b98333c6441e">Mat3x3f</a></td></tr>
<tr class="memdesc:a7d692d9066b395b37d60b98333c6441e"><td class="mdescLeft">&#160;</td><td class="mdescRight">3x3 single precision matrix. <br/></td></tr>
<tr class="separator:a7d692d9066b395b37d60b98333c6441e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40425befe026b45c6b55010111bb1544"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40425befe026b45c6b55010111bb1544"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; double, 3UL, 3UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a40425befe026b45c6b55010111bb1544">Mat3x3d</a></td></tr>
<tr class="memdesc:a40425befe026b45c6b55010111bb1544"><td class="mdescLeft">&#160;</td><td class="mdescRight">3x3 double precision matrix. <br/></td></tr>
<tr class="separator:a40425befe026b45c6b55010111bb1544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e2903a7cd676e1b0d714a372c2b5cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e2903a7cd676e1b0d714a372c2b5cb"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, 3UL, 3UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a75e2903a7cd676e1b0d714a372c2b5cb">Mat3x3</a></td></tr>
<tr class="memdesc:a75e2903a7cd676e1b0d714a372c2b5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">3x3 matrix with system-specific precision. <br/></td></tr>
<tr class="separator:a75e2903a7cd676e1b0d714a372c2b5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77d724d021d5e0b41a81ccb22cd765c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77d724d021d5e0b41a81ccb22cd765c"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; float, 4UL, 4UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad77d724d021d5e0b41a81ccb22cd765c">Mat4x4f</a></td></tr>
<tr class="memdesc:ad77d724d021d5e0b41a81ccb22cd765c"><td class="mdescLeft">&#160;</td><td class="mdescRight">4x4 single precision matrix. <br/></td></tr>
<tr class="separator:ad77d724d021d5e0b41a81ccb22cd765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c00f55bbc6128c235be6be93a154b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7c00f55bbc6128c235be6be93a154b4"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; double, 4UL, 4UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ac7c00f55bbc6128c235be6be93a154b4">Mat4x4d</a></td></tr>
<tr class="memdesc:ac7c00f55bbc6128c235be6be93a154b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">4x4 double precision matrix. <br/></td></tr>
<tr class="separator:ac7c00f55bbc6128c235be6be93a154b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fcd260861d38be00aec41c96a2c14f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68fcd260861d38be00aec41c96a2c14f"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, 4UL, 4UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a68fcd260861d38be00aec41c96a2c14f">Mat4x4</a></td></tr>
<tr class="memdesc:a68fcd260861d38be00aec41c96a2c14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">4x4 matrix with system-specific precision. <br/></td></tr>
<tr class="separator:a68fcd260861d38be00aec41c96a2c14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50579a1c855e9c54609f1279d3b9acbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50579a1c855e9c54609f1279d3b9acbf"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; float, 5UL, 5UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a50579a1c855e9c54609f1279d3b9acbf">Mat5x5f</a></td></tr>
<tr class="memdesc:a50579a1c855e9c54609f1279d3b9acbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">5x5 single precision matrix. <br/></td></tr>
<tr class="separator:a50579a1c855e9c54609f1279d3b9acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8edb6c78fce5fbbb7bf032bb666ae2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8edb6c78fce5fbbb7bf032bb666ae2"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; double, 5UL, 5UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#afa8edb6c78fce5fbbb7bf032bb666ae2">Mat5x5d</a></td></tr>
<tr class="memdesc:afa8edb6c78fce5fbbb7bf032bb666ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">5x5 double precision matrix. <br/></td></tr>
<tr class="separator:afa8edb6c78fce5fbbb7bf032bb666ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8cc71305f1c6edec96af75bc866e52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f8cc71305f1c6edec96af75bc866e52"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, 5UL, 5UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a0f8cc71305f1c6edec96af75bc866e52">Mat5x5</a></td></tr>
<tr class="memdesc:a0f8cc71305f1c6edec96af75bc866e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">5x5 matrix with system-specific precision. <br/></td></tr>
<tr class="separator:a0f8cc71305f1c6edec96af75bc866e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7bd72314841b7854efb4efacf84540"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb7bd72314841b7854efb4efacf84540"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; float, 6UL, 6UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#abb7bd72314841b7854efb4efacf84540">Mat6x6f</a></td></tr>
<tr class="memdesc:abb7bd72314841b7854efb4efacf84540"><td class="mdescLeft">&#160;</td><td class="mdescRight">6x6 single precision matrix. <br/></td></tr>
<tr class="separator:abb7bd72314841b7854efb4efacf84540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1757108d9faa867b904c487a764a8075"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1757108d9faa867b904c487a764a8075"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; double, 6UL, 6UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a1757108d9faa867b904c487a764a8075">Mat6x6d</a></td></tr>
<tr class="memdesc:a1757108d9faa867b904c487a764a8075"><td class="mdescLeft">&#160;</td><td class="mdescRight">6x6 double precision matrix. <br/></td></tr>
<tr class="separator:a1757108d9faa867b904c487a764a8075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc335aa2245e642a02a0659bdeefd2da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc335aa2245e642a02a0659bdeefd2da"></a>
typedef <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, 6UL, 6UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#acc335aa2245e642a02a0659bdeefd2da">Mat6x6</a></td></tr>
<tr class="memdesc:acc335aa2245e642a02a0659bdeefd2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">6x6 matrix with system-specific precision. <br/></td></tr>
<tr class="separator:acc335aa2245e642a02a0659bdeefd2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7960921ee5d186dd26776e8d70b35d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff7960921ee5d186dd26776e8d70b35d"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; float, 2UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aff7960921ee5d186dd26776e8d70b35d">Vec2f</a></td></tr>
<tr class="memdesc:aff7960921ee5d186dd26776e8d70b35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-dimensional single precision vector. <br/></td></tr>
<tr class="separator:aff7960921ee5d186dd26776e8d70b35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b16d94d0ab3618a209d73de07dccd6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b16d94d0ab3618a209d73de07dccd6e"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; double, 2UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a1b16d94d0ab3618a209d73de07dccd6e">Vec2d</a></td></tr>
<tr class="memdesc:a1b16d94d0ab3618a209d73de07dccd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-dimensional double precision vector. <br/></td></tr>
<tr class="separator:a1b16d94d0ab3618a209d73de07dccd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47289e3eabf7e8b5483fdb8498c610ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47289e3eabf7e8b5483fdb8498c610ef"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, 2UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a47289e3eabf7e8b5483fdb8498c610ef">Vec2</a></td></tr>
<tr class="memdesc:a47289e3eabf7e8b5483fdb8498c610ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-dimensional vector with system-specific precision. <br/></td></tr>
<tr class="separator:a47289e3eabf7e8b5483fdb8498c610ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff7f9f56b520bb493aff9c8163fbb60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abff7f9f56b520bb493aff9c8163fbb60"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; float, 3UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#abff7f9f56b520bb493aff9c8163fbb60">Vec3f</a></td></tr>
<tr class="memdesc:abff7f9f56b520bb493aff9c8163fbb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-dimensional single precision vector. <br/></td></tr>
<tr class="separator:abff7f9f56b520bb493aff9c8163fbb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c1db9fbae4fb5c48a34eab4fc59993"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43c1db9fbae4fb5c48a34eab4fc59993"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; double, 3UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a43c1db9fbae4fb5c48a34eab4fc59993">Vec3d</a></td></tr>
<tr class="memdesc:a43c1db9fbae4fb5c48a34eab4fc59993"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-dimensional double precision vector. <br/></td></tr>
<tr class="separator:a43c1db9fbae4fb5c48a34eab4fc59993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2e610d162c248ac1dffac367326af3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac2e610d162c248ac1dffac367326af3"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, 3UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aac2e610d162c248ac1dffac367326af3">Vec3</a></td></tr>
<tr class="memdesc:aac2e610d162c248ac1dffac367326af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-dimensional vector with system-specific precision. <br/></td></tr>
<tr class="separator:aac2e610d162c248ac1dffac367326af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30327a10486a67584153e63396542d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa30327a10486a67584153e63396542d1"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; float, 6UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aa30327a10486a67584153e63396542d1">Vec6f</a></td></tr>
<tr class="memdesc:aa30327a10486a67584153e63396542d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">6-dimensional single precision vector. <br/></td></tr>
<tr class="separator:aa30327a10486a67584153e63396542d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f896fb5af63596d6e97460139496b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31f896fb5af63596d6e97460139496b1"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; double, 6UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a31f896fb5af63596d6e97460139496b1">Vec6d</a></td></tr>
<tr class="memdesc:a31f896fb5af63596d6e97460139496b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">6-dimensional double precision vector. <br/></td></tr>
<tr class="separator:a31f896fb5af63596d6e97460139496b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dfc3c0a6d6c5eb728170edbb33c9c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51dfc3c0a6d6c5eb728170edbb33c9c9"></a>
typedef <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>, 6UL, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a51dfc3c0a6d6c5eb728170edbb33c9c9">Vec6</a></td></tr>
<tr class="memdesc:a51dfc3c0a6d6c5eb728170edbb33c9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">6-dimensional vector with system-specific precision. <br/></td></tr>
<tr class="separator:a51dfc3c0a6d6c5eb728170edbb33c9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717f03c9a8efb450fbe93bb091715d41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga717f03c9a8efb450fbe93bb091715d41"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga717f03c9a8efb450fbe93bb091715d41">byte</a></td></tr>
<tr class="memdesc:ga717f03c9a8efb450fbe93bb091715d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte data type of the Blaze library.The <em>byte</em> data type is guaranteed to be an integral data type of size 1. <br/></td></tr>
<tr class="separator:ga717f03c9a8efb450fbe93bb091715d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51501d11e1575bb19857805e953374b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga51501d11e1575bb19857805e953374b0"></a>
typedef boost::false_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga51501d11e1575bb19857805e953374b0">FalseType</a></td></tr>
<tr class="memdesc:ga51501d11e1575bb19857805e953374b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type/value traits base class.The FalseType class is used as base class for type traits and value traits that evaluate to <em>false</em>. <br/></td></tr>
<tr class="separator:ga51501d11e1575bb19857805e953374b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f70ec9de722c70928b8b85cb3613a9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f70ec9de722c70928b8b85cb3613a9d"></a>
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html">SystemClock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga5f70ec9de722c70928b8b85cb3613a9d">SystemClockID</a></td></tr>
<tr class="memdesc:ga5f70ec9de722c70928b8b85cb3613a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for the system clock of the Blaze library. <br/></td></tr>
<tr class="separator:ga5f70ec9de722c70928b8b85cb3613a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242cb995877991e8eb1ef9e5b7c19313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga242cb995877991e8eb1ef9e5b7c19313"></a>
typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html">SystemClock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga242cb995877991e8eb1ef9e5b7c19313">ConstSystemClockID</a></td></tr>
<tr class="memdesc:ga242cb995877991e8eb1ef9e5b7c19313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for the system clock of the Blaze library. <br/></td></tr>
<tr class="separator:ga242cb995877991e8eb1ef9e5b7c19313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8c782eb16b2134ae70864788baaed1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa8c782eb16b2134ae70864788baaed1"></a>
typedef boost::true_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaaa8c782eb16b2134ae70864788baaed1">TrueType</a></td></tr>
<tr class="memdesc:gaaa8c782eb16b2134ae70864788baaed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits base class.The TrueType class is used as base class for type traits and value traits that evaluate to <em>true</em>. <br/></td></tr>
<tr class="separator:gaaa8c782eb16b2134ae70864788baaed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3059b61931f29e6cdb0175b7e96108"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba3059b61931f29e6cdb0175b7e96108"></a>
typedef <a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaba3059b61931f29e6cdb0175b7e96108">large_t</a></td></tr>
<tr class="memdesc:gaba3059b61931f29e6cdb0175b7e96108"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest available signed integer data type. <br/></td></tr>
<tr class="separator:gaba3059b61931f29e6cdb0175b7e96108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ce6bfe70ea9dc573085dbd1089bfe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga68ce6bfe70ea9dc573085dbd1089bfe1"></a>
typedef <a class="el" href="../../d5/d68/classblaze_1_1uint64__t.html">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga68ce6bfe70ea9dc573085dbd1089bfe1">ularge_t</a></td></tr>
<tr class="memdesc:ga68ce6bfe70ea9dc573085dbd1089bfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest available unsigned integer data type. <br/></td></tr>
<tr class="separator:ga68ce6bfe70ea9dc573085dbd1089bfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f0fa27c14041df892fbaf250ed3bda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga22f0fa27c14041df892fbaf250ed3bda"></a>
typedef <a class="el" href="../../d4/d3a/group__util.html#ga68ce6bfe70ea9dc573085dbd1089bfe1">ularge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga22f0fa27c14041df892fbaf250ed3bda">id_t</a></td></tr>
<tr class="memdesc:ga22f0fa27c14041df892fbaf250ed3bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer data type for integral IDs. <br/></td></tr>
<tr class="separator:ga22f0fa27c14041df892fbaf250ed3bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabb8e75edc779325153b83682719245ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabb8e75edc779325153b83682719245ad">EulerRotation</a> { <br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada118e24268bcf97b44eec6df1a07e18a8">XYZs</a> = 0, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adab20056066766b8e028bfd748cc2e8b38">ZYXr</a> = 1, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adaf30a23352c5321a1f764e8ac8c6eba54">XYXs</a> = 2, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada46a059abef1f46af288cae9692e561be">XYXr</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adab2e079e6efc89f78d11fdc8284de24bd">XZYs</a> = 4, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adac13c774667287e4cc5f4f1e4e334edeb">YZXr</a> = 5, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adab8b9789db84f69432b11846ac6731aed">XZXs</a> = 6, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada766f40a51c48eb40b39510cd04fddf99">XZXr</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada8bfb50618a15f695dcff16a3c4bca732">YZXs</a> = 8, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada2b05988456cbed5b823eb9ab3a210dae">XZYr</a> = 9, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada3e4e02d0fd147e52a9f06803df312a7f">YZYs</a> = 10, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada4e21a6d803a2dcbbee5ad9f2b1432396">YZYr</a> = 11, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada1f93c75f60f4723a914e5b0455510417">YXZs</a> = 12, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adaa30cc7c9cbe77e371e6f5a7d8eb07e35">ZXYr</a> = 13, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adacce1d91a90c6890ddcd734d0995ac6c6">YXYs</a> = 14, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada0995487f6da326a3417b528267a687d8">YXYr</a> = 15, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada625d83e6ba3d600e127237f9a95388be">ZXYs</a> = 16, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada0b1676c74a1276f43d5c98609e4ecee2">YXZr</a> = 17, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adaa10fea420d4a43929fb869abeb33450d">ZXZs</a> = 18, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada62dcb377d9ba6127d1b04d1296eda7a0">ZXZr</a> = 19, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada4287618f6f42cedea058a13eebe445b0">ZYXs</a> = 20, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada49f76665b83c6931debef5f1c10b29fa">XYZr</a> = 21, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada18f50b0b2f770fed42f7056d00992d00">ZYZs</a> = 22, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada2d12ca7957fb70a17bcc525be5a13cc8">ZYZr</a> = 23
<br/>
 }</td></tr>
<tr class="memdesc:gabb8e75edc779325153b83682719245ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of the Euler rotationThis codes are needed for the EulerAngles function in order to calculate the Euler angles for a specific combination of rotations.  <a href="../../de/df1/group__math.html#gabb8e75edc779325153b83682719245ad">More...</a><br/></td></tr>
<tr class="separator:gabb8e75edc779325153b83682719245ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a781ebe21d450f8210a6d3faff39aaf3f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:a781ebe21d450f8210a6d3faff39aaf3f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a781ebe21d450f8210a6d3faff39aaf3f">operator&lt;=</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:a781ebe21d450f8210a6d3faff39aaf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#a781ebe21d450f8210a6d3faff39aaf3f"></a><br/></td></tr>
<tr class="separator:a781ebe21d450f8210a6d3faff39aaf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0752b785a47c338222a9eee3d9221799"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:a0752b785a47c338222a9eee3d9221799"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a0752b785a47c338222a9eee3d9221799">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:a0752b785a47c338222a9eee3d9221799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#a0752b785a47c338222a9eee3d9221799"></a><br/></td></tr>
<tr class="separator:a0752b785a47c338222a9eee3d9221799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188f3a0469d483574d9890cfff75595d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:a188f3a0469d483574d9890cfff75595d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a188f3a0469d483574d9890cfff75595d">operator&gt;=</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:a188f3a0469d483574d9890cfff75595d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#a188f3a0469d483574d9890cfff75595d"></a><br/></td></tr>
<tr class="separator:a188f3a0469d483574d9890cfff75595d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64738f0618d70a2975c7bbfc876cc84a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:a64738f0618d70a2975c7bbfc876cc84a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a64738f0618d70a2975c7bbfc876cc84a">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:a64738f0618d70a2975c7bbfc876cc84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#a64738f0618d70a2975c7bbfc876cc84a"></a><br/></td></tr>
<tr class="separator:a64738f0618d70a2975c7bbfc876cc84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17abc6a6b11aecfc787e01c600e0546b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17abc6a6b11aecfc787e01c600e0546b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a17abc6a6b11aecfc787e01c600e0546b">operator&lt;=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:a17abc6a6b11aecfc787e01c600e0546b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#a17abc6a6b11aecfc787e01c600e0546b"></a><br/></td></tr>
<tr class="separator:a17abc6a6b11aecfc787e01c600e0546b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa9b68879cea6b50867c5018151bee4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fa9b68879cea6b50867c5018151bee4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7fa9b68879cea6b50867c5018151bee4">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:a7fa9b68879cea6b50867c5018151bee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#a7fa9b68879cea6b50867c5018151bee4"></a><br/></td></tr>
<tr class="separator:a7fa9b68879cea6b50867c5018151bee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46c931e3c38d084981c9ebe8611a3b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa46c931e3c38d084981c9ebe8611a3b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aa46c931e3c38d084981c9ebe8611a3b6">operator&gt;=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:aa46c931e3c38d084981c9ebe8611a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#aa46c931e3c38d084981c9ebe8611a3b6"></a><br/></td></tr>
<tr class="separator:aa46c931e3c38d084981c9ebe8611a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add532f78625cbf286b84fa5d4d8b32ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add532f78625cbf286b84fa5d4d8b32ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#add532f78625cbf286b84fa5d4d8b32ce">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:add532f78625cbf286b84fa5d4d8b32ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#add532f78625cbf286b84fa5d4d8b32ce"></a><br/></td></tr>
<tr class="separator:add532f78625cbf286b84fa5d4d8b32ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c328fc213609bb1ca7950c114a6cd1"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ae3c328fc213609bb1ca7950c114a6cd1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ae3c328fc213609bb1ca7950c114a6cd1">operator&lt;=</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ae3c328fc213609bb1ca7950c114a6cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#ae3c328fc213609bb1ca7950c114a6cd1"></a><br/></td></tr>
<tr class="separator:ae3c328fc213609bb1ca7950c114a6cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e0741c8241a36753d0cc87df99461"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:a1d8e0741c8241a36753d0cc87df99461"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a1d8e0741c8241a36753d0cc87df99461">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:a1d8e0741c8241a36753d0cc87df99461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#a1d8e0741c8241a36753d0cc87df99461"></a><br/></td></tr>
<tr class="separator:a1d8e0741c8241a36753d0cc87df99461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bff1ddbeb77e5c4fcf10092802ed0b"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ad4bff1ddbeb77e5c4fcf10092802ed0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad4bff1ddbeb77e5c4fcf10092802ed0b">operator&gt;=</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ad4bff1ddbeb77e5c4fcf10092802ed0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#ad4bff1ddbeb77e5c4fcf10092802ed0b"></a><br/></td></tr>
<tr class="separator:ad4bff1ddbeb77e5c4fcf10092802ed0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae9de028e10fdadac0f290e069a1a14"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:a7ae9de028e10fdadac0f290e069a1a14"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7ae9de028e10fdadac0f290e069a1a14">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:a7ae9de028e10fdadac0f290e069a1a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#a7ae9de028e10fdadac0f290e069a1a14"></a><br/></td></tr>
<tr class="separator:a7ae9de028e10fdadac0f290e069a1a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fff484ed6fc2a78db73d2e3f19ff1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a078fff484ed6fc2a78db73d2e3f19ff1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a078fff484ed6fc2a78db73d2e3f19ff1">operator&lt;=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:a078fff484ed6fc2a78db73d2e3f19ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#a078fff484ed6fc2a78db73d2e3f19ff1"></a><br/></td></tr>
<tr class="separator:a078fff484ed6fc2a78db73d2e3f19ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00734ffb630fb7fbb9864ae0845629e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00734ffb630fb7fbb9864ae0845629e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a00734ffb630fb7fbb9864ae0845629e2">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:a00734ffb630fb7fbb9864ae0845629e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#a00734ffb630fb7fbb9864ae0845629e2"></a><br/></td></tr>
<tr class="separator:a00734ffb630fb7fbb9864ae0845629e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a9ea78dadddb5de9278854251cc8f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19a9ea78dadddb5de9278854251cc8f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a19a9ea78dadddb5de9278854251cc8f4">operator&gt;=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:a19a9ea78dadddb5de9278854251cc8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#a19a9ea78dadddb5de9278854251cc8f4"></a><br/></td></tr>
<tr class="separator:a19a9ea78dadddb5de9278854251cc8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858866c9c17929b12f6970c90128c932"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a858866c9c17929b12f6970c90128c932"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a858866c9c17929b12f6970c90128c932">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:a858866c9c17929b12f6970c90128c932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#a858866c9c17929b12f6970c90128c932"></a><br/></td></tr>
<tr class="separator:a858866c9c17929b12f6970c90128c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf0f17914afcea53bd79d0da9b5ae863"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaaf0f17914afcea53bd79d0da9b5ae863"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d9e/classblaze_1_1DMatAbsExpr.html">DMatAbsExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863">abs</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gaaf0f17914afcea53bd79d0da9b5ae863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the absolute values of each single element of <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863"></a><br/></td></tr>
<tr class="separator:gaaf0f17914afcea53bd79d0da9b5ae863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d2d/classblaze_1_1DMatDMatAddExpr.html">DMatDMatAddExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5b169a4b41e240ee939d6027dcf61c52">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5b169a4b41e240ee939d6027dcf61c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5b169a4b41e240ee939d6027dcf61c52"></a><br/></td></tr>
<tr class="separator:ga5b169a4b41e240ee939d6027dcf61c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2ef15ea991616b38c3ffa80834ae5c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gade2ef15ea991616b38c3ffa80834ae5c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d40/classblaze_1_1DMatDMatMultExpr.html">DMatDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gade2ef15ea991616b38c3ffa80834ae5c">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gade2ef15ea991616b38c3ffa80834ae5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two row-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gade2ef15ea991616b38c3ffa80834ae5c"></a><br/></td></tr>
<tr class="separator:gade2ef15ea991616b38c3ffa80834ae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7b2dabfa699f5714783cf446221758"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga1d7b2dabfa699f5714783cf446221758"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/ddb/classblaze_1_1DMatDMatSubExpr.html">DMatDMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1d7b2dabfa699f5714783cf446221758">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1d7b2dabfa699f5714783cf446221758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense matrices with identical storage order ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_88.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1d7b2dabfa699f5714783cf446221758"></a><br/></td></tr>
<tr class="separator:ga1d7b2dabfa699f5714783cf446221758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../df/dce/classblaze_1_1DMatDVecMultExpr.html">DMatDVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga772dd5fcf447845bc8fcc3ac8cf1ad86">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga772dd5fcf447845bc8fcc3ac8cf1ad86"></a><br/></td></tr>
<tr class="separator:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012e8376b6a90ae026e49788155babf2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga012e8376b6a90ae026e49788155babf2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga012e8376b6a90ae026e49788155babf2">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga012e8376b6a90ae026e49788155babf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga012e8376b6a90ae026e49788155babf2"></a><br/></td></tr>
<tr class="separator:ga012e8376b6a90ae026e49788155babf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d9a/classblaze_1_1DMatEvalExpr.html">DMatEvalExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">eval</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:gacb9f8190d38edb0e52d9c376da5486d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense matrix expression <em>dm</em>.  <a href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6"></a><br/></td></tr>
<tr class="separator:gacb9f8190d38edb0e52d9c376da5486d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1122725f3073b7d691b1883471a2d40"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:gab1122725f3073b7d691b1883471a2d40"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, typename <br class="typebreak"/>
<a class="el" href="../../d1/da1/structblaze_1_1DMatScalarDivExprHelper.html">DMatScalarDivExprHelper</a>&lt; T1, <br class="typebreak"/>
T2, SO &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab1122725f3073b7d691b1883471a2d40">operator/</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gab1122725f3073b7d691b1883471a2d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the division of a dense matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_93.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gab1122725f3073b7d691b1883471a2d40"></a><br/></td></tr>
<tr class="separator:gab1122725f3073b7d691b1883471a2d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a799677a2c718def787efc2504e401a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga4a799677a2c718def787efc2504e401a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d8b/classblaze_1_1DMatScalarMultExpr.html">DMatScalarMultExpr</a>&lt; MT, <br class="typebreak"/>
typename <a class="el" href="../../d7/d5d/structblaze_1_1BaseElementType.html">BaseElementType</a>&lt; MT &gt;<br class="typebreak"/>
::Type, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4a799677a2c718def787efc2504e401a">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga4a799677a2c718def787efc2504e401a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_94.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4a799677a2c718def787efc2504e401a"></a><br/></td></tr>
<tr class="separator:ga4a799677a2c718def787efc2504e401a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga520e8e9495c866851f6bf16f600b5eca"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga520e8e9495c866851f6bf16f600b5eca"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga520e8e9495c866851f6bf16f600b5eca">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga520e8e9495c866851f6bf16f600b5eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_34.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga520e8e9495c866851f6bf16f600b5eca"></a><br/></td></tr>
<tr class="separator:ga520e8e9495c866851f6bf16f600b5eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20053ce72b11c41ac3a13a8fd93966ef"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga20053ce72b11c41ac3a13a8fd93966ef"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;<br class="typebreak"/>
, typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga20053ce72b11c41ac3a13a8fd93966ef">operator*</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga20053ce72b11c41ac3a13a8fd93966ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_95.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga20053ce72b11c41ac3a13a8fd93966ef"></a><br/></td></tr>
<tr class="separator:ga20053ce72b11c41ac3a13a8fd93966ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga694fc9c7f56eeb00d82c413d5d94cf77">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense matrix and a sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga694fc9c7f56eeb00d82c413d5d94cf77"></a><br/></td></tr>
<tr class="separator:ga694fc9c7f56eeb00d82c413d5d94cf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f46fd8e099778f075cef873b15947c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga39f46fd8e099778f075cef873b15947c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d65/classblaze_1_1DMatSMatAddExpr.html">DMatSMatAddExpr</a>&lt; T2, T1, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga39f46fd8e099778f075cef873b15947c">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga39f46fd8e099778f075cef873b15947c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse matrix and a dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga39f46fd8e099778f075cef873b15947c"></a><br/></td></tr>
<tr class="separator:ga39f46fd8e099778f075cef873b15947c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a69a009d857b36f4b607edbeede502a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2a69a009d857b36f4b607edbeede502a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d2b/classblaze_1_1DMatSMatMultExpr.html">DMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2a69a009d857b36f4b607edbeede502a">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2a69a009d857b36f4b607edbeede502a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga2a69a009d857b36f4b607edbeede502a"></a><br/></td></tr>
<tr class="separator:ga2a69a009d857b36f4b607edbeede502a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f1afd8e1de67f79795d150708931b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga02f1afd8e1de67f79795d150708931b9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/deb/classblaze_1_1DMatSMatSubExpr.html">DMatSMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga02f1afd8e1de67f79795d150708931b9">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga02f1afd8e1de67f79795d150708931b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense matrix and a sparse matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga02f1afd8e1de67f79795d150708931b9"></a><br/></td></tr>
<tr class="separator:ga02f1afd8e1de67f79795d150708931b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae207ab7da28fcdb71b662e4714dcf066"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae207ab7da28fcdb71b662e4714dcf066"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d7/d34/classblaze_1_1DMatSVecMultExpr.html">DMatSVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae207ab7da28fcdb71b662e4714dcf066">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae207ab7da28fcdb71b662e4714dcf066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="../../de/d90/group__dense__vector.html#gae207ab7da28fcdb71b662e4714dcf066"></a><br/></td></tr>
<tr class="separator:gae207ab7da28fcdb71b662e4714dcf066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73bd8f2e202abf61042ada0dd4306931"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga73bd8f2e202abf61042ada0dd4306931"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga73bd8f2e202abf61042ada0dd4306931">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga73bd8f2e202abf61042ada0dd4306931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga73bd8f2e202abf61042ada0dd4306931"></a><br/></td></tr>
<tr class="separator:ga73bd8f2e202abf61042ada0dd4306931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f61cc2c64216a380a84db1433f8bb25"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3f61cc2c64216a380a84db1433f8bb25"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3f61cc2c64216a380a84db1433f8bb25">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3f61cc2c64216a380a84db1433f8bb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major and a colum-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga3f61cc2c64216a380a84db1433f8bb25"></a><br/></td></tr>
<tr class="separator:ga3f61cc2c64216a380a84db1433f8bb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga971f11d3e0d74e13a1435c42bd33365f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga971f11d3e0d74e13a1435c42bd33365f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/dbe/classblaze_1_1DMatTDMatAddExpr.html">DMatTDMatAddExpr</a>&lt; T2, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga971f11d3e0d74e13a1435c42bd33365f">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga971f11d3e0d74e13a1435c42bd33365f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga971f11d3e0d74e13a1435c42bd33365f"></a><br/></td></tr>
<tr class="separator:ga971f11d3e0d74e13a1435c42bd33365f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5707ef23374bab4bee818b45edff483f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5707ef23374bab4bee818b45edff483f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d8a/classblaze_1_1DMatTDMatMultExpr.html">DMatTDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga5707ef23374bab4bee818b45edff483f">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5707ef23374bab4bee818b45edff483f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga5707ef23374bab4bee818b45edff483f"></a><br/></td></tr>
<tr class="separator:ga5707ef23374bab4bee818b45edff483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe43da57a9a142f65a8c8dfbbc7b4a7f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafe43da57a9a142f65a8c8dfbbc7b4a7f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gafe43da57a9a142f65a8c8dfbbc7b4a7f">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafe43da57a9a142f65a8c8dfbbc7b4a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_88.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gafe43da57a9a142f65a8c8dfbbc7b4a7f"></a><br/></td></tr>
<tr class="separator:gafe43da57a9a142f65a8c8dfbbc7b4a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0734adabb6aee028f9f094c64fde6ab4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0734adabb6aee028f9f094c64fde6ab4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d16/classblaze_1_1DMatTDMatSubExpr.html">DMatTDMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga0734adabb6aee028f9f094c64fde6ab4">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0734adabb6aee028f9f094c64fde6ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_88.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga0734adabb6aee028f9f094c64fde6ab4"></a><br/></td></tr>
<tr class="separator:ga0734adabb6aee028f9f094c64fde6ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76200b1dad6b7f87831941fa6eaa0b72"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga76200b1dad6b7f87831941fa6eaa0b72"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d86/classblaze_1_1DMatTransExpr.html">DMatTransExpr</a>&lt; MT,!SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72">trans</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;dm)</td></tr>
<tr class="memdesc:ga76200b1dad6b7f87831941fa6eaa0b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72"></a><br/></td></tr>
<tr class="separator:ga76200b1dad6b7f87831941fa6eaa0b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9b2e3869791221577cba8ab897ad68"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gacb9b2e3869791221577cba8ab897ad68"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacb9b2e3869791221577cba8ab897ad68">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacb9b2e3869791221577cba8ab897ad68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gacb9b2e3869791221577cba8ab897ad68"></a><br/></td></tr>
<tr class="separator:gacb9b2e3869791221577cba8ab897ad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d61/classblaze_1_1DMatTSMatAddExpr.html">DMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7f1119e6cc68946e48a0620679bd6d06">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7f1119e6cc68946e48a0620679bd6d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7f1119e6cc68946e48a0620679bd6d06"></a><br/></td></tr>
<tr class="separator:ga7f1119e6cc68946e48a0620679bd6d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82218827b4f2e2748e9fec868b66690"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad82218827b4f2e2748e9fec868b66690"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/ddc/classblaze_1_1DMatTSMatMultExpr.html">DMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad82218827b4f2e2748e9fec868b66690">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad82218827b4f2e2748e9fec868b66690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gad82218827b4f2e2748e9fec868b66690"></a><br/></td></tr>
<tr class="separator:gad82218827b4f2e2748e9fec868b66690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d76/classblaze_1_1DMatTSMatSubExpr.html">DMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gad2a348f4c6ca1ff497f56003dd22cb66">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gad2a348f4c6ca1ff497f56003dd22cb66"></a><br/></td></tr>
<tr class="separator:gad2a348f4c6ca1ff497f56003dd22cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/dc0/classblaze_1_1DVecAbsExpr.html">DVecAbsExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0cc328e0a8995b75b93180c8dfbd2757">abs</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the absolute values of each single element of <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#ga0cc328e0a8995b75b93180c8dfbd2757"></a><br/></td></tr>
<tr class="separator:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacade1745b146d7c63876fdd2bd755ce6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gacade1745b146d7c63876fdd2bd755ce6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/dc4/classblaze_1_1DVecDVecAddExpr.html">DVecDVecAddExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacade1745b146d7c63876fdd2bd755ce6">operator+</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacade1745b146d7c63876fdd2bd755ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>).  <a href="../../de/d90/group__dense__vector.html#gacade1745b146d7c63876fdd2bd755ce6"></a><br/></td></tr>
<tr class="separator:gacade1745b146d7c63876fdd2bd755ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa687a75e64beca784394faf86435249c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa687a75e64beca784394faf86435249c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/da6/classblaze_1_1DVecDVecCrossExpr.html">DVecDVecCrossExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa687a75e64beca784394faf86435249c">operator%</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa687a75e64beca784394faf86435249c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaa687a75e64beca784394faf86435249c"></a><br/></td></tr>
<tr class="separator:gaa687a75e64beca784394faf86435249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a0127d216ecef466edad068782d9e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaf6a0127d216ecef466edad068782d9e4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d76/classblaze_1_1DVecDVecMultExpr.html">DVecDVecMultExpr</a>&lt; T1, T2, <br class="typebreak"/>
TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf6a0127d216ecef466edad068782d9e4">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf6a0127d216ecef466edad068782d9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaf6a0127d216ecef466edad068782d9e4"></a><br/></td></tr>
<tr class="separator:gaf6a0127d216ecef466edad068782d9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/d79/classblaze_1_1DVecDVecSubExpr.html">DVecDVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd0d441ba5993e9b6df62c534cec34c9">operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafd0d441ba5993e9b6df62c534cec34c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>).  <a href="../../de/d90/group__dense__vector.html#gafd0d441ba5993e9b6df62c534cec34c9"></a><br/></td></tr>
<tr class="separator:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/d94/classblaze_1_1DVecEvalExpr.html">DVecEvalExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab9e162d0ea6b3e4493b9666c6730d690">eval</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gab9e162d0ea6b3e4493b9666c6730d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense vector expression <em>dv</em>.  <a href="../../de/d90/group__dense__vector.html#gab9e162d0ea6b3e4493b9666c6730d690"></a><br/></td></tr>
<tr class="separator:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522af93898ec5c11cfeab2045caf9875"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga522af93898ec5c11cfeab2045caf9875"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, typename <br class="typebreak"/>
<a class="el" href="../../d9/d64/structblaze_1_1DVecScalarDivExprHelper.html">DVecScalarDivExprHelper</a>&lt; T1, <br class="typebreak"/>
T2, TF &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga522af93898ec5c11cfeab2045caf9875">operator/</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga522af93898ec5c11cfeab2045caf9875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a dense vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_101.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga522af93898ec5c11cfeab2045caf9875"></a><br/></td></tr>
<tr class="separator:ga522af93898ec5c11cfeab2045caf9875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/de8/classblaze_1_1DVecScalarMultExpr.html">DVecScalarMultExpr</a>&lt; VT, <br class="typebreak"/>
typename <a class="el" href="../../d7/d5d/structblaze_1_1BaseElementType.html">BaseElementType</a>&lt; VT &gt;<br class="typebreak"/>
::Type, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga74b6a05f757de44c4daf52b23538cfaf">operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga74b6a05f757de44c4daf52b23538cfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_102.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga74b6a05f757de44c4daf52b23538cfaf"></a><br/></td></tr>
<tr class="separator:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4a5cc3fa262a06eeba8ab4f0d4c3777e">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_46.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga4a5cc3fa262a06eeba8ab4f0d4c3777e"></a><br/></td></tr>
<tr class="separator:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;<br class="typebreak"/>
, typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac6096b0a74a5fbf88317a167bc29fa61">operator*</a> (T1 scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gac6096b0a74a5fbf88317a167bc29fa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_103.png"/>).  <a href="../../de/d90/group__dense__vector.html#gac6096b0a74a5fbf88317a167bc29fa61"></a><br/></td></tr>
<tr class="separator:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html">DVecSVecAddExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac46fecdd6785f66d7521f88db40dd1b9">operator+</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac46fecdd6785f66d7521f88db40dd1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>).  <a href="../../de/d90/group__dense__vector.html#gac46fecdd6785f66d7521f88db40dd1b9"></a><br/></td></tr>
<tr class="separator:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362d09a6d64deafb689d21a6f7559c78"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga362d09a6d64deafb689d21a6f7559c78"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d67/classblaze_1_1DVecSVecAddExpr.html">DVecSVecAddExpr</a>&lt; T2, T1, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga362d09a6d64deafb689d21a6f7559c78">operator+</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga362d09a6d64deafb689d21a6f7559c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga362d09a6d64deafb689d21a6f7559c78"></a><br/></td></tr>
<tr class="separator:ga362d09a6d64deafb689d21a6f7559c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/da6/classblaze_1_1DVecSVecCrossExpr.html">DVecSVecCrossExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaff63460a43ecf99ed5dc7c51cd505f04">operator%</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaff63460a43ecf99ed5dc7c51cd505f04"></a><br/></td></tr>
<tr class="separator:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/dd2/classblaze_1_1DVecSVecMultExpr.html">DVecSVecMultExpr</a>&lt; T1, T2, <br class="typebreak"/>
TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab3fbcd035fcb7ffda672fbc102afb585">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab3fbcd035fcb7ffda672fbc102afb585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gab3fbcd035fcb7ffda672fbc102afb585"></a><br/></td></tr>
<tr class="separator:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/de0/classblaze_1_1DVecSVecSubExpr.html">DVecSVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4d9d2740625e6b7d83d77e0284ae21e4">operator-</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga4d9d2740625e6b7d83d77e0284ae21e4"></a><br/></td></tr>
<tr class="separator:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/dcd/classblaze_1_1DVecTDVecMultExpr.html">DVecTDVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga282c791c739c8c0d1d8e7c82bf0391ad">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the outer product of two dense vectors ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_104.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga282c791c739c8c0d1d8e7c82bf0391ad"></a><br/></td></tr>
<tr class="separator:ga282c791c739c8c0d1d8e7c82bf0391ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393d4b96ce4e176295d336a195dd05af"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga393d4b96ce4e176295d336a195dd05af"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/db6/classblaze_1_1DVecTransExpr.html">DVecTransExpr</a>&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga393d4b96ce4e176295d336a195dd05af">trans</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga393d4b96ce4e176295d336a195dd05af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense vector.  <a href="../../de/d90/group__dense__vector.html#ga393d4b96ce4e176295d336a195dd05af"></a><br/></td></tr>
<tr class="separator:ga393d4b96ce4e176295d336a195dd05af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/da5/classblaze_1_1DVecTSVecMultExpr.html">DVecTSVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaebd2a470dd21fec4c42c12135e2bcbb4">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the dense vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_104.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaebd2a470dd21fec4c42c12135e2bcbb4"></a><br/></td></tr>
<tr class="separator:gaebd2a470dd21fec4c42c12135e2bcbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdd80159dc2299ff82d77a494f877a0"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gaccdd80159dc2299ff82d77a494f877a0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d38/classblaze_1_1SMatAbsExpr.html">SMatAbsExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaccdd80159dc2299ff82d77a494f877a0">abs</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gaccdd80159dc2299ff82d77a494f877a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the absolute values of each single element of <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gaccdd80159dc2299ff82d77a494f877a0"></a><br/></td></tr>
<tr class="separator:gaccdd80159dc2299ff82d77a494f877a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2332eeb931fe442419745885fc0bac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaff2332eeb931fe442419745885fc0bac"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/dc5/classblaze_1_1SMatDMatMultExpr.html">SMatDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaff2332eeb931fe442419745885fc0bac">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaff2332eeb931fe442419745885fc0bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaff2332eeb931fe442419745885fc0bac"></a><br/></td></tr>
<tr class="separator:gaff2332eeb931fe442419745885fc0bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7889e29abeda750915b8c5a2fc061242"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga7889e29abeda750915b8c5a2fc061242"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/db6/classblaze_1_1SMatDMatSubExpr.html">SMatDMatSubExpr</a>&lt; T1, T2, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7889e29abeda750915b8c5a2fc061242">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7889e29abeda750915b8c5a2fc061242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse matrix and a dense matrix with identical storage order ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7889e29abeda750915b8c5a2fc061242"></a><br/></td></tr>
<tr class="separator:ga7889e29abeda750915b8c5a2fc061242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d5/d53/classblaze_1_1SMatDVecMultExpr.html">SMatDVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa2e3b97cb2cb32f3037b4cb0b82d30bb">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="../../de/d90/group__dense__vector.html#gaa2e3b97cb2cb32f3037b4cb0b82d30bb"></a><br/></td></tr>
<tr class="separator:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e6513f0b783fd27d9c1977f2efbfc0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga15e6513f0b783fd27d9c1977f2efbfc0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga15e6513f0b783fd27d9c1977f2efbfc0">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga15e6513f0b783fd27d9c1977f2efbfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga15e6513f0b783fd27d9c1977f2efbfc0"></a><br/></td></tr>
<tr class="separator:ga15e6513f0b783fd27d9c1977f2efbfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/da4/classblaze_1_1SMatEvalExpr.html">SMatEvalExpr</a>&lt; MT, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae18cc9f2429336161ac3cdc8087b0fd2">eval</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse matrix expression <em>sm</em>.  <a href="../../d0/d45/group__sparse__matrix.html#gae18cc9f2429336161ac3cdc8087b0fd2"></a><br/></td></tr>
<tr class="separator:gae18cc9f2429336161ac3cdc8087b0fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931aeb2b9e7003f2cbfdc0d5ef3c690a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga931aeb2b9e7003f2cbfdc0d5ef3c690a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, typename <br class="typebreak"/>
<a class="el" href="../../d4/d94/structblaze_1_1SMatScalarDivExprHelper.html">SMatScalarDivExprHelper</a>&lt; T1, <br class="typebreak"/>
T2, SO &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga931aeb2b9e7003f2cbfdc0d5ef3c690a">operator/</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga931aeb2b9e7003f2cbfdc0d5ef3c690a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the division of a sparse matrix by a scalar value ( <img class="formulaInl" alt="$ A=B/s $" src="../../form_93.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga931aeb2b9e7003f2cbfdc0d5ef3c690a"></a><br/></td></tr>
<tr class="separator:ga931aeb2b9e7003f2cbfdc0d5ef3c690a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ff748e81c24f0685cdba4b935002a1"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga93ff748e81c24f0685cdba4b935002a1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d6e/classblaze_1_1SMatScalarMultExpr.html">SMatScalarMultExpr</a>&lt; MT, <br class="typebreak"/>
typename <a class="el" href="../../d7/d5d/structblaze_1_1BaseElementType.html">BaseElementType</a>&lt; MT &gt;<br class="typebreak"/>
::Type, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga93ff748e81c24f0685cdba4b935002a1">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga93ff748e81c24f0685cdba4b935002a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse matrix ( <img class="formulaInl" alt="$ A = -B $" src="../../form_94.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga93ff748e81c24f0685cdba4b935002a1"></a><br/></td></tr>
<tr class="separator:ga93ff748e81c24f0685cdba4b935002a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03db9d13199c1f9d63d6ce091f06a43"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:gad03db9d13199c1f9d63d6ce091f06a43"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad03db9d13199c1f9d63d6ce091f06a43">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:gad03db9d13199c1f9d63d6ce091f06a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix and a scalar value ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_34.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gad03db9d13199c1f9d63d6ce091f06a43"></a><br/></td></tr>
<tr class="separator:gad03db9d13199c1f9d63d6ce091f06a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30e6919b85993c58ff5de610d2db4b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gae30e6919b85993c58ff5de610d2db4b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;<br class="typebreak"/>
, typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gae30e6919b85993c58ff5de610d2db4b6">operator*</a> (T1 scalar, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gae30e6919b85993c58ff5de610d2db4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse matrix ( <img class="formulaInl" alt="$ A=s*B $" src="../../form_95.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gae30e6919b85993c58ff5de610d2db4b6"></a><br/></td></tr>
<tr class="separator:gae30e6919b85993c58ff5de610d2db4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d18/classblaze_1_1SMatSMatAddExpr.html">SMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga9d6d0bef279f8d41722214ba0a93c191">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9d6d0bef279f8d41722214ba0a93c191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga9d6d0bef279f8d41722214ba0a93c191"></a><br/></td></tr>
<tr class="separator:ga9d6d0bef279f8d41722214ba0a93c191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d13/classblaze_1_1SMatSMatMultExpr.html">SMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7be5ba7d99f09441c139d426c172ad7f">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7be5ba7d99f09441c139d426c172ad7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga7be5ba7d99f09441c139d426c172ad7f"></a><br/></td></tr>
<tr class="separator:ga7be5ba7d99f09441c139d426c172ad7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d92/classblaze_1_1SMatSMatSubExpr.html">SMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1b71cdd1a878c14f672b47a3522575e1">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1b71cdd1a878c14f672b47a3522575e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two row-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_88.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga1b71cdd1a878c14f672b47a3522575e1"></a><br/></td></tr>
<tr class="separator:ga1b71cdd1a878c14f672b47a3522575e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc13ee206a0186ed04d82757fcddbb2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9dc13ee206a0186ed04d82757fcddbb2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d6/dbf/classblaze_1_1SMatSVecMultExpr.html">SMatSVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9dc13ee206a0186ed04d82757fcddbb2">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga9dc13ee206a0186ed04d82757fcddbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_105.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga9dc13ee206a0186ed04d82757fcddbb2"></a><br/></td></tr>
<tr class="separator:ga9dc13ee206a0186ed04d82757fcddbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9172e9da5cda16c231c1c62dabeb0b06"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga9172e9da5cda16c231c1c62dabeb0b06"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9172e9da5cda16c231c1c62dabeb0b06">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga9172e9da5cda16c231c1c62dabeb0b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga9172e9da5cda16c231c1c62dabeb0b06"></a><br/></td></tr>
<tr class="separator:ga9172e9da5cda16c231c1c62dabeb0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd88fb6252c24b32b19dcf37f3c79196"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafd88fb6252c24b32b19dcf37f3c79196"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d43/classblaze_1_1SMatTDMatMultExpr.html">SMatTDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gafd88fb6252c24b32b19dcf37f3c79196">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafd88fb6252c24b32b19dcf37f3c79196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gafd88fb6252c24b32b19dcf37f3c79196"></a><br/></td></tr>
<tr class="separator:gafd88fb6252c24b32b19dcf37f3c79196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/de7/classblaze_1_1SMatTDMatSubExpr.html">SMatTDMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga1720d2f0702c0f77bc4991a287d98d1e">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga1720d2f0702c0f77bc4991a287d98d1e"></a><br/></td></tr>
<tr class="separator:ga1720d2f0702c0f77bc4991a287d98d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba33c86733edba197072130453b7982"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga7ba33c86733edba197072130453b7982"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d09/classblaze_1_1SMatTransExpr.html">SMatTransExpr</a>&lt; MT,!SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7ba33c86733edba197072130453b7982">trans</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;sm)</td></tr>
<tr class="memdesc:ga7ba33c86733edba197072130453b7982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse matrix.  <a href="../../d0/d45/group__sparse__matrix.html#ga7ba33c86733edba197072130453b7982"></a><br/></td></tr>
<tr class="separator:ga7ba33c86733edba197072130453b7982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112e886e84bf2d9155a12623fa1131a9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga112e886e84bf2d9155a12623fa1131a9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga112e886e84bf2d9155a12623fa1131a9">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga112e886e84bf2d9155a12623fa1131a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga112e886e84bf2d9155a12623fa1131a9"></a><br/></td></tr>
<tr class="separator:ga112e886e84bf2d9155a12623fa1131a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d9c/classblaze_1_1SMatTSMatAddExpr.html">SMatTSMatAddExpr</a>&lt; T2, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaf69176ce01c8deed13b6288d04e7fb4e">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaf69176ce01c8deed13b6288d04e7fb4e"></a><br/></td></tr>
<tr class="separator:gaf69176ce01c8deed13b6288d04e7fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dc8/classblaze_1_1SMatTSMatMultExpr.html">SMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga4fc17104bcd6eac213fcc2574e68eff7">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga4fc17104bcd6eac213fcc2574e68eff7"></a><br/></td></tr>
<tr class="separator:ga4fc17104bcd6eac213fcc2574e68eff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f555464ba008c823eab85d659a2abe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac7f555464ba008c823eab85d659a2abe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/dad/classblaze_1_1SMatTSMatSubExpr.html">SMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac7f555464ba008c823eab85d659a2abe">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac7f555464ba008c823eab85d659a2abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a row-major and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_88.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gac7f555464ba008c823eab85d659a2abe"></a><br/></td></tr>
<tr class="separator:gac7f555464ba008c823eab85d659a2abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d50/classblaze_1_1SVecAbsExpr.html">SVecAbsExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4030f434bb2acdea2622f2ca07df99e6">abs</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4030f434bb2acdea2622f2ca07df99e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the absolute values of each single element of <em>sv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#ga4030f434bb2acdea2622f2ca07df99e6"></a><br/></td></tr>
<tr class="separator:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26f9406627cf1059b01755eb635e1f2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae26f9406627cf1059b01755eb635e1f2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/dbd/classblaze_1_1SVecDVecCrossExpr.html">SVecDVecCrossExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae26f9406627cf1059b01755eb635e1f2">operator%</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae26f9406627cf1059b01755eb635e1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>).  <a href="../../de/d90/group__dense__vector.html#gae26f9406627cf1059b01755eb635e1f2"></a><br/></td></tr>
<tr class="separator:gae26f9406627cf1059b01755eb635e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d1/dd1/classblaze_1_1SVecDVecMultExpr.html">SVecDVecMultExpr</a>&lt; T1, T2, <br class="typebreak"/>
TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga931bca871bc8961db7f2a7b5d9892b3c">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga931bca871bc8961db7f2a7b5d9892b3c"></a><br/></td></tr>
<tr class="separator:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e490c7a24853b803499ba9e3becaa50"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga5e490c7a24853b803499ba9e3becaa50"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d8/d09/classblaze_1_1SVecDVecSubExpr.html">SVecDVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5e490c7a24853b803499ba9e3becaa50">operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5e490c7a24853b803499ba9e3becaa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga5e490c7a24853b803499ba9e3becaa50"></a><br/></td></tr>
<tr class="separator:ga5e490c7a24853b803499ba9e3becaa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d7/d39/classblaze_1_1SVecEvalExpr.html">SVecEvalExpr</a>&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac9a411c9688799b2ef0f334c98f216cf">eval</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gac9a411c9688799b2ef0f334c98f216cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse vector expression <em>dv</em>.  <a href="../../d6/d2f/group__sparse__vector.html#gac9a411c9688799b2ef0f334c98f216cf"></a><br/></td></tr>
<tr class="separator:gac9a411c9688799b2ef0f334c98f216cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga828cdd739516d9e1c08e42a328483d8d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga828cdd739516d9e1c08e42a328483d8d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, typename <br class="typebreak"/>
<a class="el" href="../../d5/d58/structblaze_1_1SVecScalarDivExprHelper.html">SVecScalarDivExprHelper</a>&lt; T1, <br class="typebreak"/>
T2, TF &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga828cdd739516d9e1c08e42a328483d8d">operator/</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga828cdd739516d9e1c08e42a328483d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_101.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga828cdd739516d9e1c08e42a328483d8d"></a><br/></td></tr>
<tr class="separator:ga828cdd739516d9e1c08e42a328483d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d7/dc2/classblaze_1_1SVecScalarMultExpr.html">SVecScalarMultExpr</a>&lt; VT, <br class="typebreak"/>
typename <a class="el" href="../../d7/d5d/structblaze_1_1BaseElementType.html">BaseElementType</a>&lt; VT &gt;<br class="typebreak"/>
::Type, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab6ef1ca2e0a236659aaf0df816b52c52">operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_102.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gab6ef1ca2e0a236659aaf0df816b52c52"></a><br/></td></tr>
<tr class="separator:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a13a11aab1762aba19e74a9cea87266"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga2a13a11aab1762aba19e74a9cea87266"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2a13a11aab1762aba19e74a9cea87266">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga2a13a11aab1762aba19e74a9cea87266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_46.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga2a13a11aab1762aba19e74a9cea87266"></a><br/></td></tr>
<tr class="separator:ga2a13a11aab1762aba19e74a9cea87266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;<br class="typebreak"/>
, typename <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga19736a03fdce17b21867a7d4ce5e4587">operator*</a> (T1 scalar, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga19736a03fdce17b21867a7d4ce5e4587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_103.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga19736a03fdce17b21867a7d4ce5e4587"></a><br/></td></tr>
<tr class="separator:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d63/classblaze_1_1SVecSVecAddExpr.html">SVecSVecAddExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3012773ba555712c006466a901f2b7b6">operator+</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3012773ba555712c006466a901f2b7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga3012773ba555712c006466a901f2b7b6"></a><br/></td></tr>
<tr class="separator:ga3012773ba555712c006466a901f2b7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d7d/classblaze_1_1SVecSVecCrossExpr.html">SVecSVecCrossExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga29a3e2901fb6e319d4792001d250b9b0">operator%</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga29a3e2901fb6e319d4792001d250b9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga29a3e2901fb6e319d4792001d250b9b0"></a><br/></td></tr>
<tr class="separator:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/ddb/classblaze_1_1SVecSVecMultExpr.html">SVecSVecMultExpr</a>&lt; T1, T2, <br class="typebreak"/>
TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaaccf01f6322bcd426a734b284aa123b8">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaccf01f6322bcd426a734b284aa123b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gaaccf01f6322bcd426a734b284aa123b8"></a><br/></td></tr>
<tr class="separator:gaaccf01f6322bcd426a734b284aa123b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/d48/classblaze_1_1SVecSVecSubExpr.html">SVecSVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1a9bad0a58b194a184fa8b9e14618a4f">operator-</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga1a9bad0a58b194a184fa8b9e14618a4f"></a><br/></td></tr>
<tr class="separator:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25c477c724abcfb4503afc172a51c3f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa25c477c724abcfb4503afc172a51c3f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/d3b/classblaze_1_1SVecTDVecMultExpr.html">SVecTDVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa25c477c724abcfb4503afc172a51c3f">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa25c477c724abcfb4503afc172a51c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the sparse vector-dense vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_104.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa25c477c724abcfb4503afc172a51c3f"></a><br/></td></tr>
<tr class="separator:gaa25c477c724abcfb4503afc172a51c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad025086deb216a3db59994cd9f141089"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gad025086deb216a3db59994cd9f141089"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dd7/classblaze_1_1SVecTransExpr.html">SVecTransExpr</a>&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gad025086deb216a3db59994cd9f141089">trans</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gad025086deb216a3db59994cd9f141089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse vector.  <a href="../../d6/d2f/group__sparse__vector.html#gad025086deb216a3db59994cd9f141089"></a><br/></td></tr>
<tr class="separator:gad025086deb216a3db59994cd9f141089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab41594bee8f746276b88e56b2b92051"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaab41594bee8f746276b88e56b2b92051"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d04/classblaze_1_1SVecTSVecMultExpr.html">SVecTSVecMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaab41594bee8f746276b88e56b2b92051">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaab41594bee8f746276b88e56b2b92051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the sparse vector-sparse vector outer product ( <img class="formulaInl" alt="$ A=\vec{b}*\vec{c}^T $" src="../../form_104.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaab41594bee8f746276b88e56b2b92051"></a><br/></td></tr>
<tr class="separator:gaab41594bee8f746276b88e56b2b92051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99703844f7b1351016e47780277efb7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gab99703844f7b1351016e47780277efb7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/dc9/classblaze_1_1TDMatDMatMultExpr.html">TDMatDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gab99703844f7b1351016e47780277efb7">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab99703844f7b1351016e47780277efb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gab99703844f7b1351016e47780277efb7"></a><br/></td></tr>
<tr class="separator:gab99703844f7b1351016e47780277efb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../dc/dd4/classblaze_1_1TDMatDVecMultExpr.html">TDMatDVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae70d2b23499b4e8bee9ca6ef02ec0c91">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="../../de/d90/group__dense__vector.html#gae70d2b23499b4e8bee9ca6ef02ec0c91"></a><br/></td></tr>
<tr class="separator:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga4b0a2b26e02f2ca345af2094585db4be">operator+</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4b0a2b26e02f2ca345af2094585db4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga4b0a2b26e02f2ca345af2094585db4be"></a><br/></td></tr>
<tr class="separator:ga4b0a2b26e02f2ca345af2094585db4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d0526756a2befd345af87726c5014e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga72d0526756a2befd345af87726c5014e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d0c/classblaze_1_1TDMatSMatAddExpr.html">TDMatSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga72d0526756a2befd345af87726c5014e">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga72d0526756a2befd345af87726c5014e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a row-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga72d0526756a2befd345af87726c5014e"></a><br/></td></tr>
<tr class="separator:ga72d0526756a2befd345af87726c5014e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc6107dda539d41695e8f9f2ebf005c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7fc6107dda539d41695e8f9f2ebf005c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/dfb/classblaze_1_1TDMatSMatMultExpr.html">TDMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7fc6107dda539d41695e8f9f2ebf005c">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7fc6107dda539d41695e8f9f2ebf005c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga7fc6107dda539d41695e8f9f2ebf005c"></a><br/></td></tr>
<tr class="separator:ga7fc6107dda539d41695e8f9f2ebf005c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d5b/classblaze_1_1TDMatSMatSubExpr.html">TDMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa31b65149566c26b3f8d9d75ca24c6e5">operator-</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major dense matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaa31b65149566c26b3f8d9d75ca24c6e5"></a><br/></td></tr>
<tr class="separator:gaa31b65149566c26b3f8d9d75ca24c6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d4/d0b/classblaze_1_1TDMatSVecMultExpr.html">TDMatSVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0c99693a856adeaec5e4a50baf3d72d7">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga0c99693a856adeaec5e4a50baf3d72d7"></a><br/></td></tr>
<tr class="separator:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaebf997f6e7e5fa0809d404ee89c2d7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gabaebf997f6e7e5fa0809d404ee89c2d7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dd/d6f/classblaze_1_1TDMatTDMatMultExpr.html">TDMatTDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gabaebf997f6e7e5fa0809d404ee89c2d7">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabaebf997f6e7e5fa0809d404ee89c2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two column-major dense matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gabaebf997f6e7e5fa0809d404ee89c2d7"></a><br/></td></tr>
<tr class="separator:gabaebf997f6e7e5fa0809d404ee89c2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55603ebcaa45b68183c06b156040cabb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga55603ebcaa45b68183c06b156040cabb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d9c/classblaze_1_1TDMatTSMatMultExpr.html">TDMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga55603ebcaa45b68183c06b156040cabb">operator*</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga55603ebcaa45b68183c06b156040cabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a column-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga55603ebcaa45b68183c06b156040cabb"></a><br/></td></tr>
<tr class="separator:ga55603ebcaa45b68183c06b156040cabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d8/d47/classblaze_1_1TDVecDMatMultExpr.html">TDVecDMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga545f87ad5a7df86714ebf79fa949ac9a">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga545f87ad5a7df86714ebf79fa949ac9a"></a><br/></td></tr>
<tr class="separator:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada61a5175e8bee0111464a947259e7be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gada61a5175e8bee0111464a947259e7be"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gada61a5175e8bee0111464a947259e7be">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gada61a5175e8bee0111464a947259e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>).  <a href="../../de/d90/group__dense__vector.html#gada61a5175e8bee0111464a947259e7be"></a><br/></td></tr>
<tr class="separator:gada61a5175e8bee0111464a947259e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabffb97c0a6209458be80e0a1248aad83"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gabffb97c0a6209458be80e0a1248aad83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; TDVecDVecMultExprHelper&lt; T1, <br class="typebreak"/>
T2 &gt;, const typename <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a><br class="typebreak"/>
&lt; typename T1::ElementType, <br class="typebreak"/>
typename T2::ElementType &gt;<br class="typebreak"/>
::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabffb97c0a6209458be80e0a1248aad83">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabffb97c0a6209458be80e0a1248aad83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).  <a href="../../de/d90/group__dense__vector.html#gabffb97c0a6209458be80e0a1248aad83"></a><br/></td></tr>
<tr class="separator:gabffb97c0a6209458be80e0a1248aad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7855e55b0a6aabe64451dbb98ed16780"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7855e55b0a6aabe64451dbb98ed16780"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga7855e55b0a6aabe64451dbb98ed16780">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga7855e55b0a6aabe64451dbb98ed16780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga7855e55b0a6aabe64451dbb98ed16780"></a><br/></td></tr>
<tr class="separator:ga7855e55b0a6aabe64451dbb98ed16780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f074f8895555f6ffba3904b7f0db905"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga9f074f8895555f6ffba3904b7f0db905"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga9f074f8895555f6ffba3904b7f0db905">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga9f074f8895555f6ffba3904b7f0db905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga9f074f8895555f6ffba3904b7f0db905"></a><br/></td></tr>
<tr class="separator:ga9f074f8895555f6ffba3904b7f0db905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38eeea18da3978abfc138b094e984f6d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga38eeea18da3978abfc138b094e984f6d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga38eeea18da3978abfc138b094e984f6d">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga38eeea18da3978abfc138b094e984f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga38eeea18da3978abfc138b094e984f6d"></a><br/></td></tr>
<tr class="separator:ga38eeea18da3978abfc138b094e984f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0706e3e8f11a655f2b85a2d887db749"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa0706e3e8f11a655f2b85a2d887db749"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../db/de4/classblaze_1_1TDVecTDMatMultExpr.html">TDVecTDMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa0706e3e8f11a655f2b85a2d887db749">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:gaa0706e3e8f11a655f2b85a2d887db749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gaa0706e3e8f11a655f2b85a2d887db749"></a><br/></td></tr>
<tr class="separator:gaa0706e3e8f11a655f2b85a2d887db749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49fcf8ec0db2827fb54deec5a3905c9f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga49fcf8ec0db2827fb54deec5a3905c9f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga49fcf8ec0db2827fb54deec5a3905c9f">operator*</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga49fcf8ec0db2827fb54deec5a3905c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga49fcf8ec0db2827fb54deec5a3905c9f"></a><br/></td></tr>
<tr class="separator:ga49fcf8ec0db2827fb54deec5a3905c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91fac7612d334d056573a01255a42f5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac91fac7612d334d056573a01255a42f5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/ddb/classblaze_1_1TSMatDMatMultExpr.html">TSMatDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac91fac7612d334d056573a01255a42f5">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac91fac7612d334d056573a01255a42f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gac91fac7612d334d056573a01255a42f5"></a><br/></td></tr>
<tr class="separator:gac91fac7612d334d056573a01255a42f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/d71/classblaze_1_1TSMatDMatSubExpr.html">TSMatDMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga2a19e16624e4520852a11d2a443d1ba5">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2a19e16624e4520852a11d2a443d1ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major sparse matrix and a row-major dense matrix ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga2a19e16624e4520852a11d2a443d1ba5"></a><br/></td></tr>
<tr class="separator:ga2a19e16624e4520852a11d2a443d1ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade884e87c42ffd73fab8b47c28437b6d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gade884e87c42ffd73fab8b47c28437b6d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../dc/ddb/classblaze_1_1TSMatDVecMultExpr.html">TSMatDVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gade884e87c42ffd73fab8b47c28437b6d">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gade884e87c42ffd73fab8b47c28437b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="../../de/d90/group__dense__vector.html#gade884e87c42ffd73fab8b47c28437b6d"></a><br/></td></tr>
<tr class="separator:gade884e87c42ffd73fab8b47c28437b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../db/dc3/classblaze_1_1TSMatSMatMultExpr.html">TSMatSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gaa8d0ec5eb55760f5c13f4f3311c7c8db">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#gaa8d0ec5eb55760f5c13f4f3311c7c8db"></a><br/></td></tr>
<tr class="separator:gaa8d0ec5eb55760f5c13f4f3311c7c8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ef8d85c5124466413b19db53823068"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga62ef8d85c5124466413b19db53823068"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/d0d/classblaze_1_1TSMatSMatSubExpr.html">TSMatSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga62ef8d85c5124466413b19db53823068">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga62ef8d85c5124466413b19db53823068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a column-major and a row-major sparse matrix ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_88.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga62ef8d85c5124466413b19db53823068"></a><br/></td></tr>
<tr class="separator:ga62ef8d85c5124466413b19db53823068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../de/d16/classblaze_1_1TSMatSVecMultExpr.html">TSMatSVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae59ab01e702dfd082c425a359b7c2bf2">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae59ab01e702dfd082c425a359b7c2bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gae59ab01e702dfd082c425a359b7c2bf2"></a><br/></td></tr>
<tr class="separator:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61db726d567fb847824781084a1a04a8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga61db726d567fb847824781084a1a04a8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d9f/classblaze_1_1TSMatTDMatMultExpr.html">TSMatTDMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga61db726d567fb847824781084a1a04a8">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga61db726d567fb847824781084a1a04a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a column-major dense matrix ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga61db726d567fb847824781084a1a04a8"></a><br/></td></tr>
<tr class="separator:ga61db726d567fb847824781084a1a04a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d90/classblaze_1_1TSMatTSMatAddExpr.html">TSMatTSMatAddExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga1672d9c402ae8df5b15063e9905e9b1d">operator+</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B+C $" src="../../form_86.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga1672d9c402ae8df5b15063e9905e9b1d"></a><br/></td></tr>
<tr class="separator:ga1672d9c402ae8df5b15063e9905e9b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ea4f1b211288029950a99e1e109971"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga69ea4f1b211288029950a99e1e109971"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d0/dec/classblaze_1_1TSMatTSMatMultExpr.html">TSMatTSMatMultExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga69ea4f1b211288029950a99e1e109971">operator*</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga69ea4f1b211288029950a99e1e109971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga69ea4f1b211288029950a99e1e109971"></a><br/></td></tr>
<tr class="separator:ga69ea4f1b211288029950a99e1e109971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d7793334fbcfec19fae5365a921d4a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga01d7793334fbcfec19fae5365a921d4a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3f/classblaze_1_1TSMatTSMatSubExpr.html">TSMatTSMatSubExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga01d7793334fbcfec19fae5365a921d4a">operator-</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga01d7793334fbcfec19fae5365a921d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two column-major sparse matrices ( <img class="formulaInl" alt="$ A=B-C $" src="../../form_88.png"/>).  <a href="../../d0/d45/group__sparse__matrix.html#ga01d7793334fbcfec19fae5365a921d4a"></a><br/></td></tr>
<tr class="separator:ga01d7793334fbcfec19fae5365a921d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c34013e7f4749d14b7e41803d969742"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0c34013e7f4749d14b7e41803d969742"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga0c34013e7f4749d14b7e41803d969742">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga0c34013e7f4749d14b7e41803d969742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="../../db/df0/group__dense__matrix.html#ga0c34013e7f4749d14b7e41803d969742"></a><br/></td></tr>
<tr class="separator:ga0c34013e7f4749d14b7e41803d969742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5974dacb6ef941fef3fc7f4eaba3ada4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5974dacb6ef941fef3fc7f4eaba3ada4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5974dacb6ef941fef3fc7f4eaba3ada4">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga5974dacb6ef941fef3fc7f4eaba3ada4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>).  <a href="../../de/d90/group__dense__vector.html#ga5974dacb6ef941fef3fc7f4eaba3ada4"></a><br/></td></tr>
<tr class="separator:ga5974dacb6ef941fef3fc7f4eaba3ada4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa669e7fdfba70b0a9b33729e7bf329d6">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gaa669e7fdfba70b0a9b33729e7bf329d6"></a><br/></td></tr>
<tr class="separator:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfec08873101a5b3600d7c34be7d5c54"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gacfec08873101a5b3600d7c34be7d5c54"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d1/da7/classblaze_1_1TSVecSMatMultExpr.html">TSVecSMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gacfec08873101a5b3600d7c34be7d5c54">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:gacfec08873101a5b3600d7c34be7d5c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gacfec08873101a5b3600d7c34be7d5c54"></a><br/></td></tr>
<tr class="separator:gacfec08873101a5b3600d7c34be7d5c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83623e4c5981d7e844e29039ea19cdb3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga83623e4c5981d7e844e29039ea19cdb3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga83623e4c5981d7e844e29039ea19cdb3">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga83623e4c5981d7e844e29039ea19cdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga83623e4c5981d7e844e29039ea19cdb3"></a><br/></td></tr>
<tr class="separator:ga83623e4c5981d7e844e29039ea19cdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga75acb12c5e42f8164aeb6c1272a77580">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga75acb12c5e42f8164aeb6c1272a77580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#ga75acb12c5e42f8164aeb6c1272a77580"></a><br/></td></tr>
<tr class="separator:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac469d59c9cdd3e1e31442eb141f01976"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac469d59c9cdd3e1e31442eb141f01976"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gac469d59c9cdd3e1e31442eb141f01976">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:gac469d59c9cdd3e1e31442eb141f01976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="../../db/df0/group__dense__matrix.html#gac469d59c9cdd3e1e31442eb141f01976"></a><br/></td></tr>
<tr class="separator:gac469d59c9cdd3e1e31442eb141f01976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae781cf418b2fb59650e1480a9a672114"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae781cf418b2fb59650e1480a9a672114"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a><br class="typebreak"/>
&lt; <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">IsMatMatMultExpr</a>&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../df/d31/classblaze_1_1TSVecTSMatMultExpr.html">TSVecTSMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae781cf418b2fb59650e1480a9a672114">operator*</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:gae781cf418b2fb59650e1480a9a672114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="../../d6/d2f/group__sparse__vector.html#gae781cf418b2fb59650e1480a9a672114"></a><br/></td></tr>
<tr class="separator:gae781cf418b2fb59650e1480a9a672114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ac2de583edd4130033e1120f9c83bb"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga84ac2de583edd4130033e1120f9c83bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga84ac2de583edd4130033e1120f9c83bb">size</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga84ac2de583edd4130033e1120f9c83bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the vector.  <a href="../../dc/dcf/group__vector.html#ga84ac2de583edd4130033e1120f9c83bb"></a><br/></td></tr>
<tr class="separator:ga84ac2de583edd4130033e1120f9c83bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d26ff247dbb23184d714d2ffb40d5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac2d26ff247dbb23184d714d2ffb40d5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;<br class="typebreak"/>
, Load&lt; T, sizeof(T)&gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gac2d26ff247dbb23184d714d2ffb40d5d">load</a> (const T *address)</td></tr>
<tr class="memdesc:gac2d26ff247dbb23184d714d2ffb40d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of integral values.  <a href="../../df/daa/group__intrinsics.html#gac2d26ff247dbb23184d714d2ffb40d5d"></a><br/></td></tr>
<tr class="separator:gac2d26ff247dbb23184d714d2ffb40d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8071424c7636c3218ee9dcdddecabb66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d42/classblaze_1_1sse__float__t.html">sse_float_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga8071424c7636c3218ee9dcdddecabb66">load</a> (const float *address)</td></tr>
<tr class="memdesc:ga8071424c7636c3218ee9dcdddecabb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'float' values.  <a href="../../df/daa/group__intrinsics.html#ga8071424c7636c3218ee9dcdddecabb66"></a><br/></td></tr>
<tr class="separator:ga8071424c7636c3218ee9dcdddecabb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd9cb80af68b3a615b72c49e9bb267ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd0/classblaze_1_1sse__double__t.html">sse_double_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gadd9cb80af68b3a615b72c49e9bb267ae">load</a> (const double *address)</td></tr>
<tr class="memdesc:gadd9cb80af68b3a615b72c49e9bb267ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a vector of 'double' values.  <a href="../../df/daa/group__intrinsics.html#gadd9cb80af68b3a615b72c49e9bb267ae"></a><br/></td></tr>
<tr class="separator:gadd9cb80af68b3a615b72c49e9bb267ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db3d792710ece048f71e163a646a650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d66/classblaze_1_1int16__t.html">int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga3db3d792710ece048f71e163a646a650">sum</a> (const <a class="el" href="../../de/d7f/classblaze_1_1sse__int16__t.html">sse_int16_t</a> &amp;a)</td></tr>
<tr class="memdesc:ga3db3d792710ece048f71e163a646a650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 16-bit integral intrinsic vector.  <a href="../../df/daa/group__intrinsics.html#ga3db3d792710ece048f71e163a646a650"></a><br/></td></tr>
<tr class="separator:ga3db3d792710ece048f71e163a646a650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga502570edf21cdcd930708a74040af39a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d2d/classblaze_1_1int32__t.html">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga502570edf21cdcd930708a74040af39a">sum</a> (const <a class="el" href="../../d4/dc9/classblaze_1_1sse__int32__t.html">sse_int32_t</a> &amp;a)</td></tr>
<tr class="memdesc:ga502570edf21cdcd930708a74040af39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the 32-bit integral intrinsic vector.  <a href="../../df/daa/group__intrinsics.html#ga502570edf21cdcd930708a74040af39a"></a><br/></td></tr>
<tr class="separator:ga502570edf21cdcd930708a74040af39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf310b1f886c7536a67f878431d98e8cf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gaf310b1f886c7536a67f878431d98e8cf">sum</a> (const <a class="el" href="../../df/d42/classblaze_1_1sse__float__t.html">sse_float_t</a> &amp;a)</td></tr>
<tr class="memdesc:gaf310b1f886c7536a67f878431d98e8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the single precision floating point intrinsic vector.  <a href="../../df/daa/group__intrinsics.html#gaf310b1f886c7536a67f878431d98e8cf"></a><br/></td></tr>
<tr class="separator:gaf310b1f886c7536a67f878431d98e8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eabb67232a976e2f6ea44778a00184c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga7eabb67232a976e2f6ea44778a00184c">sum</a> (const <a class="el" href="../../d4/dd0/classblaze_1_1sse__double__t.html">sse_double_t</a> &amp;a)</td></tr>
<tr class="memdesc:ga7eabb67232a976e2f6ea44778a00184c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the double precision floating point intrinsic vector.  <a href="../../df/daa/group__intrinsics.html#ga7eabb67232a976e2f6ea44778a00184c"></a><br/></td></tr>
<tr class="separator:ga7eabb67232a976e2f6ea44778a00184c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7337e23a01474d5da47bf3fa2b98cdfe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7337e23a01474d5da47bf3fa2b98cdfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt;, Set<br class="typebreak"/>
&lt; T, sizeof(T)&gt; &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga7337e23a01474d5da47bf3fa2b98cdfe">set</a> (T value)</td></tr>
<tr class="memdesc:ga7337e23a01474d5da47bf3fa2b98cdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given integral value.  <a href="../../df/daa/group__intrinsics.html#ga7337e23a01474d5da47bf3fa2b98cdfe"></a><br/></td></tr>
<tr class="separator:ga7337e23a01474d5da47bf3fa2b98cdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57489ca3c5fd2b7ad322e3c3c493febd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d42/classblaze_1_1sse__float__t.html">sse_float_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga57489ca3c5fd2b7ad322e3c3c493febd">set</a> (float value)</td></tr>
<tr class="memdesc:ga57489ca3c5fd2b7ad322e3c3c493febd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 'float' value.  <a href="../../df/daa/group__intrinsics.html#ga57489ca3c5fd2b7ad322e3c3c493febd"></a><br/></td></tr>
<tr class="separator:ga57489ca3c5fd2b7ad322e3c3c493febd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5374eeb83e5b18362adae5291973d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd0/classblaze_1_1sse__double__t.html">sse_double_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gad5374eeb83e5b18362adae5291973d10">set</a> (double value)</td></tr>
<tr class="memdesc:gad5374eeb83e5b18362adae5291973d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the vector to the given 'double' value.  <a href="../../df/daa/group__intrinsics.html#gad5374eeb83e5b18362adae5291973d10"></a><br/></td></tr>
<tr class="separator:gad5374eeb83e5b18362adae5291973d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0620c71f3cbaec604eedb89bbe44c9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gad0620c71f3cbaec604eedb89bbe44c9c">setzero</a> (<a class="el" href="../../d5/d71/classblaze_1_1sse__int8__t.html">sse_int8_t</a> &amp;value)</td></tr>
<tr class="memdesc:gad0620c71f3cbaec604eedb89bbe44c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral intrinsic type with 16 8-bit data values to zero.  <a href="../../df/daa/group__intrinsics.html#gad0620c71f3cbaec604eedb89bbe44c9c"></a><br/></td></tr>
<tr class="separator:gad0620c71f3cbaec604eedb89bbe44c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace33d96d0f0f119c1dbfb5b2a7eec7e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gace33d96d0f0f119c1dbfb5b2a7eec7e3">setzero</a> (<a class="el" href="../../de/d7f/classblaze_1_1sse__int16__t.html">sse_int16_t</a> &amp;value)</td></tr>
<tr class="memdesc:gace33d96d0f0f119c1dbfb5b2a7eec7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral intrinsic type with 8 16-bit data values to zero.  <a href="../../df/daa/group__intrinsics.html#gace33d96d0f0f119c1dbfb5b2a7eec7e3"></a><br/></td></tr>
<tr class="separator:gace33d96d0f0f119c1dbfb5b2a7eec7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1725aecdcb80ece80073df6fb72ed9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gad1725aecdcb80ece80073df6fb72ed9c">setzero</a> (<a class="el" href="../../d4/dc9/classblaze_1_1sse__int32__t.html">sse_int32_t</a> &amp;value)</td></tr>
<tr class="memdesc:gad1725aecdcb80ece80073df6fb72ed9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral intrinsic type with 4 32-bit data values to zero.  <a href="../../df/daa/group__intrinsics.html#gad1725aecdcb80ece80073df6fb72ed9c"></a><br/></td></tr>
<tr class="separator:gad1725aecdcb80ece80073df6fb72ed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54dadc2eb807a9b28296afd844cd080c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga54dadc2eb807a9b28296afd844cd080c">setzero</a> (<a class="el" href="../../d1/db7/classblaze_1_1sse__int64__t.html">sse_int64_t</a> &amp;value)</td></tr>
<tr class="memdesc:ga54dadc2eb807a9b28296afd844cd080c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an integral intrinsic type with 2 64-bit data values to zero.  <a href="../../df/daa/group__intrinsics.html#ga54dadc2eb807a9b28296afd844cd080c"></a><br/></td></tr>
<tr class="separator:ga54dadc2eb807a9b28296afd844cd080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2afc519f8a5cb53356469ec5ea1eecea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga2afc519f8a5cb53356469ec5ea1eecea">setzero</a> (<a class="el" href="../../df/d42/classblaze_1_1sse__float__t.html">sse_float_t</a> &amp;value)</td></tr>
<tr class="memdesc:ga2afc519f8a5cb53356469ec5ea1eecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting a floating point intrinsic type with 4 32-bit single precision data values to zero.  <a href="../../df/daa/group__intrinsics.html#ga2afc519f8a5cb53356469ec5ea1eecea"></a><br/></td></tr>
<tr class="separator:ga2afc519f8a5cb53356469ec5ea1eecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e6f6630e0527d2b41cb7a70ae17ec4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga76e6f6630e0527d2b41cb7a70ae17ec4">setzero</a> (<a class="el" href="../../d4/dd0/classblaze_1_1sse__double__t.html">sse_double_t</a> &amp;value)</td></tr>
<tr class="memdesc:ga76e6f6630e0527d2b41cb7a70ae17ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting a floating point intrinsic type with 4 32-bit double precision data values to zero.  <a href="../../df/daa/group__intrinsics.html#ga76e6f6630e0527d2b41cb7a70ae17ec4"></a><br/></td></tr>
<tr class="separator:ga76e6f6630e0527d2b41cb7a70ae17ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e89079b572a9ca4ac80b9e28f8d2006"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5e89079b572a9ca4ac80b9e28f8d2006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga5e89079b572a9ca4ac80b9e28f8d2006">store</a> (T *address, const typename Store&lt; T, sizeof(T)&gt;::Type &amp;value)</td></tr>
<tr class="memdesc:ga5e89079b572a9ca4ac80b9e28f8d2006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of integral values.  <a href="../../df/daa/group__intrinsics.html#ga5e89079b572a9ca4ac80b9e28f8d2006"></a><br/></td></tr>
<tr class="separator:ga5e89079b572a9ca4ac80b9e28f8d2006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3863a99608788f9ccbfe35eec6ad05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga0a3863a99608788f9ccbfe35eec6ad05">store</a> (float *address, const <a class="el" href="../../df/d42/classblaze_1_1sse__float__t.html">sse_float_t</a> &amp;value)</td></tr>
<tr class="memdesc:ga0a3863a99608788f9ccbfe35eec6ad05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 'float' values.  <a href="../../df/daa/group__intrinsics.html#ga0a3863a99608788f9ccbfe35eec6ad05"></a><br/></td></tr>
<tr class="separator:ga0a3863a99608788f9ccbfe35eec6ad05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0fa3507c370c1270f1b4ea0528d88b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gad0fa3507c370c1270f1b4ea0528d88b7">store</a> (double *address, const <a class="el" href="../../d4/dd0/classblaze_1_1sse__double__t.html">sse_double_t</a> &amp;value)</td></tr>
<tr class="memdesc:gad0fa3507c370c1270f1b4ea0528d88b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of a vector of 'double' values.  <a href="../../df/daa/group__intrinsics.html#gad0fa3507c370c1270f1b4ea0528d88b7"></a><br/></td></tr>
<tr class="separator:gad0fa3507c370c1270f1b4ea0528d88b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e49b0d49517d3a5b4c321a49ee56934"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5e49b0d49517d3a5b4c321a49ee56934"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">IsIntegral</a>&lt; T &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#ga5e49b0d49517d3a5b4c321a49ee56934">stream</a> (T *address, const typename Stream&lt; T, sizeof(T)&gt;::Type &amp;value)</td></tr>
<tr class="memdesc:ga5e49b0d49517d3a5b4c321a49ee56934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of integral values.  <a href="../../df/daa/group__intrinsics.html#ga5e49b0d49517d3a5b4c321a49ee56934"></a><br/></td></tr>
<tr class="separator:ga5e49b0d49517d3a5b4c321a49ee56934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ff59f5f0c5c4448fc9e7ac0aef4729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gae3ff59f5f0c5c4448fc9e7ac0aef4729">stream</a> (float *address, const <a class="el" href="../../df/d42/classblaze_1_1sse__float__t.html">sse_float_t</a> &amp;value)</td></tr>
<tr class="memdesc:gae3ff59f5f0c5c4448fc9e7ac0aef4729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 'float' values.  <a href="../../df/daa/group__intrinsics.html#gae3ff59f5f0c5c4448fc9e7ac0aef4729"></a><br/></td></tr>
<tr class="separator:gae3ff59f5f0c5c4448fc9e7ac0aef4729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d7b42f5d3b9e5272758e3f9900e2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html#gad0d7b42f5d3b9e5272758e3f9900e2f0">stream</a> (double *address, const <a class="el" href="../../d4/dd0/classblaze_1_1sse__double__t.html">sse_double_t</a> &amp;value)</td></tr>
<tr class="memdesc:gad0d7b42f5d3b9e5272758e3f9900e2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of a vector of 'double' values.  <a href="../../df/daa/group__intrinsics.html#gad0d7b42f5d3b9e5272758e3f9900e2f0"></a><br/></td></tr>
<tr class="separator:gad0d7b42f5d3b9e5272758e3f9900e2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab40e2a09a33ee0ece9a154e77556a22b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gab40e2a09a33ee0ece9a154e77556a22b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gab40e2a09a33ee0ece9a154e77556a22b">clear</a> (Type &amp;clearable)</td></tr>
<tr class="memdesc:gab40e2a09a33ee0ece9a154e77556a22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given value/object to the default state.  <a href="../../da/d5b/group__math__shims.html#gab40e2a09a33ee0ece9a154e77556a22b"></a><br/></td></tr>
<tr class="separator:gab40e2a09a33ee0ece9a154e77556a22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db93817fdbd984c9b4025dfd3b0f8d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7db93817fdbd984c9b4025dfd3b0f8d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga7db93817fdbd984c9b4025dfd3b0f8d6">equal</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ga7db93817fdbd984c9b4025dfd3b0f8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic equality check.  <a href="../../da/d5b/group__math__shims.html#ga7db93817fdbd984c9b4025dfd3b0f8d6"></a><br/></td></tr>
<tr class="separator:ga7db93817fdbd984c9b4025dfd3b0f8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18bced4c160db10dda95deef39401b0f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga18bced4c160db10dda95deef39401b0f">inv</a> (float a)</td></tr>
<tr class="memdesc:ga18bced4c160db10dda95deef39401b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given single precision value.  <a href="../../da/d5b/group__math__shims.html#ga18bced4c160db10dda95deef39401b0f"></a><br/></td></tr>
<tr class="separator:ga18bced4c160db10dda95deef39401b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b5f05e758a85f52c4717aec684696e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gac3b5f05e758a85f52c4717aec684696e">inv</a> (double a)</td></tr>
<tr class="memdesc:gac3b5f05e758a85f52c4717aec684696e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given double precision value.  <a href="../../da/d5b/group__math__shims.html#gac3b5f05e758a85f52c4717aec684696e"></a><br/></td></tr>
<tr class="separator:gac3b5f05e758a85f52c4717aec684696e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga811cdf3f5fbfe7c53403cfb9c15f6666"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga811cdf3f5fbfe7c53403cfb9c15f6666">inv</a> (long double a)</td></tr>
<tr class="memdesc:ga811cdf3f5fbfe7c53403cfb9c15f6666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given long double value.  <a href="../../da/d5b/group__math__shims.html#ga811cdf3f5fbfe7c53403cfb9c15f6666"></a><br/></td></tr>
<tr class="separator:ga811cdf3f5fbfe7c53403cfb9c15f6666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a415191ccb2efaa42bf864bc6a3ce0"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gaf2a415191ccb2efaa42bf864bc6a3ce0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#gaf2a415191ccb2efaa42bf864bc6a3ce0">isDefault</a> (const Type &amp;v)</td></tr>
<tr class="memdesc:gaf2a415191ccb2efaa42bf864bc6a3ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given value/object is in default state.  <a href="../../da/d5b/group__math__shims.html#gaf2a415191ccb2efaa42bf864bc6a3ce0"></a><br/></td></tr>
<tr class="separator:gaf2a415191ccb2efaa42bf864bc6a3ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eee839fc434a2158546c1d933f70ead"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2eee839fc434a2158546c1d933f70ead"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga2eee839fc434a2158546c1d933f70ead">isnan</a> (T a)</td></tr>
<tr class="memdesc:ga2eee839fc434a2158546c1d933f70ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform independent implementation of the C99 <em>isnan</em> function.  <a href="../../da/d5b/group__math__shims.html#ga2eee839fc434a2158546c1d933f70ead"></a><br/></td></tr>
<tr class="separator:ga2eee839fc434a2158546c1d933f70ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6220284cdc4a734bf43dfe6d2f69bf"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga2a6220284cdc4a734bf43dfe6d2f69bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga2a6220284cdc4a734bf43dfe6d2f69bf">reset</a> (Type &amp;resettable)</td></tr>
<tr class="memdesc:ga2a6220284cdc4a734bf43dfe6d2f69bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given value/object to the default value.  <a href="../../da/d5b/group__math__shims.html#ga2a6220284cdc4a734bf43dfe6d2f69bf"></a><br/></td></tr>
<tr class="separator:ga2a6220284cdc4a734bf43dfe6d2f69bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582f6aa4f0d4d16ebad05902a3acaceb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga582f6aa4f0d4d16ebad05902a3acaceb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d2/da3/structblaze_1_1MultExprTrait.html">MultExprTrait</a>&lt; T, T &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html#ga582f6aa4f0d4d16ebad05902a3acaceb">sq</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ga582f6aa4f0d4d16ebad05902a3acaceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squaring the given value/object.  <a href="../../da/d5b/group__math__shims.html#ga582f6aa4f0d4d16ebad05902a3acaceb"></a><br/></td></tr>
<tr class="separator:ga582f6aa4f0d4d16ebad05902a3acaceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5be271299bf9d21d79adbc98fefc7c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two row-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73"></a><br/></td></tr>
<tr class="separator:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fe418ba6e1d414a1915677cd42a034"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad8fe418ba6e1d414a1915677cd42a034"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gad8fe418ba6e1d414a1915677cd42a034">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad8fe418ba6e1d414a1915677cd42a034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#gad8fe418ba6e1d414a1915677cd42a034"></a><br/></td></tr>
<tr class="separator:gad8fe418ba6e1d414a1915677cd42a034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300de20d22689dc8157697e1d2026f10"><td class="memTemplParams" colspan="2">template&lt;typename D , typename S &gt; </td></tr>
<tr class="memitem:a300de20d22689dc8157697e1d2026f10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a300de20d22689dc8157697e1d2026f10">polymorphicCount</a> (S *const *first, S *const *last)</td></tr>
<tr class="memdesc:a300de20d22689dc8157697e1d2026f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the pointer to objects with dynamic type <em>D</em>.  <a href="#a300de20d22689dc8157697e1d2026f10"></a><br/></td></tr>
<tr class="separator:a300de20d22689dc8157697e1d2026f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e1bd58f6ea4e93e56d5fd71a0168d"><td class="memTemplParams" colspan="2">template&lt;typename D , typename S &gt; </td></tr>
<tr class="memitem:a526e1bd58f6ea4e93e56d5fd71a0168d"><td class="memTemplItemLeft" align="right" valign="top">S *const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a526e1bd58f6ea4e93e56d5fd71a0168d">polymorphicFind</a> (S *const *first, S *const *last)</td></tr>
<tr class="memdesc:a526e1bd58f6ea4e93e56d5fd71a0168d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next pointer to an object with dynamic type <em>D</em>.  <a href="#a526e1bd58f6ea4e93e56d5fd71a0168d"></a><br/></td></tr>
<tr class="separator:a526e1bd58f6ea4e93e56d5fd71a0168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae15f397e6434f2c811d86a3428c6c089"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d55/group__runtime__assert.html#gae15f397e6434f2c811d86a3428c6c089">ASSERT_MESSAGE</a> (const char *)</td></tr>
<tr class="memdesc:gae15f397e6434f2c811d86a3428c6c089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertion helper function.The ASSERT_MESSAGE function is a small helper function to assist in printing an informative message in case an assert fires. This function builds on the ideas of Matthew Wilson, who directly combines a C-string error message with the run time expression (Imperfect C++, ISBN: 0321228774):  <a href="../../d5/d55/group__runtime__assert.html#gae15f397e6434f2c811d86a3428c6c089"></a><br/></td></tr>
<tr class="separator:gae15f397e6434f2c811d86a3428c6c089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49baf1c557f47c3c776efc675d2fc9f5"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a49baf1c557f47c3c776efc675d2fc9f5"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a49baf1c557f47c3c776efc675d2fc9f5">convert</a> (const From &amp;from)</td></tr>
<tr class="memdesc:a49baf1c557f47c3c776efc675d2fc9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from type <em>From</em> to type <em>To</em>.  <a href="#a49baf1c557f47c3c776efc675d2fc9f5"></a><br/></td></tr>
<tr class="separator:a49baf1c557f47c3c776efc675d2fc9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">dimensionof</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static evaluation of array dimensions.  <a href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4"></a><br/></td></tr>
<tr class="separator:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a981a1908b189351a35e8285d50a8db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a981a1908b189351a35e8285d50a8db"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7a981a1908b189351a35e8285d50a8db">allocate</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> size)</td></tr>
<tr class="memdesc:a7a981a1908b189351a35e8285d50a8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned array allocation.  <a href="#a7a981a1908b189351a35e8285d50a8db"></a><br/></td></tr>
<tr class="separator:a7a981a1908b189351a35e8285d50a8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71ae9c3bdbe361debf5c37df7f4327c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac71ae9c3bdbe361debf5c37df7f4327c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ac71ae9c3bdbe361debf5c37df7f4327c">deallocate</a> (T *address)</td></tr>
<tr class="memdesc:ac71ae9c3bdbe361debf5c37df7f4327c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocation of memory.  <a href="#ac71ae9c3bdbe361debf5c37df7f4327c"></a><br/></td></tr>
<tr class="separator:ac71ae9c3bdbe361debf5c37df7f4327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accuracy operators</div></td></tr>
<tr class="memitem:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2eebfaf6382f255164a9cefa6ab8eb27">operator==</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga2eebfaf6382f255164a9cefa6ab8eb27"></a><br/></td></tr>
<tr class="separator:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf42a6c23efe1880899f5b89b265286"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga3cf42a6c23efe1880899f5b89b265286"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3cf42a6c23efe1880899f5b89b265286">operator==</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga3cf42a6c23efe1880899f5b89b265286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga3cf42a6c23efe1880899f5b89b265286"></a><br/></td></tr>
<tr class="separator:ga3cf42a6c23efe1880899f5b89b265286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6ac5831d994de1617100e79b409f78"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga5f6ac5831d994de1617100e79b409f78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5f6ac5831d994de1617100e79b409f78">operator!=</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga5f6ac5831d994de1617100e79b409f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga5f6ac5831d994de1617100e79b409f78"></a><br/></td></tr>
<tr class="separator:ga5f6ac5831d994de1617100e79b409f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga22db42744b1d782e174dbcf6f2bf37e2">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga22db42744b1d782e174dbcf6f2bf37e2"></a><br/></td></tr>
<tr class="separator:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab0f6e6c059c34b31b67dfe6e6420398d">operator&lt;</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gab0f6e6c059c34b31b67dfe6e6420398d"></a><br/></td></tr>
<tr class="separator:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f80a558803f060623e0ac21763e989a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga9f80a558803f060623e0ac21763e989a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9f80a558803f060623e0ac21763e989a">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga9f80a558803f060623e0ac21763e989a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#ga9f80a558803f060623e0ac21763e989a"></a><br/></td></tr>
<tr class="separator:ga9f80a558803f060623e0ac21763e989a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0c3a3aa80c4823700946bfbcbf0e15a7">operator&gt;</a> (const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga0c3a3aa80c4823700946bfbcbf0e15a7"></a><br/></td></tr>
<tr class="separator:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad1147bca7c8d61c5705dd67a7bb37b72">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="../../de/df1/group__math.html#gad1147bca7c8d61c5705dd67a7bb37b72"></a><br/></td></tr>
<tr class="separator:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42be9e710c330d928604c4fe730661d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga42be9e710c330d928604c4fe730661d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga42be9e710c330d928604c4fe730661d5">operator==</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga42be9e710c330d928604c4fe730661d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga42be9e710c330d928604c4fe730661d5"></a><br/></td></tr>
<tr class="separator:ga42be9e710c330d928604c4fe730661d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5362cd08bf302cd8f8272be634a5b435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5362cd08bf302cd8f8272be634a5b435"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5362cd08bf302cd8f8272be634a5b435">operator==</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:ga5362cd08bf302cd8f8272be634a5b435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#ga5362cd08bf302cd8f8272be634a5b435"></a><br/></td></tr>
<tr class="separator:ga5362cd08bf302cd8f8272be634a5b435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81389b775ddd91717cc708fd4815b6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac81389b775ddd91717cc708fd4815b6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac81389b775ddd91717cc708fd4815b6a">operator!=</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac81389b775ddd91717cc708fd4815b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gac81389b775ddd91717cc708fd4815b6a"></a><br/></td></tr>
<tr class="separator:gac81389b775ddd91717cc708fd4815b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae116a92a519bc1a7faa511e50ebd3b90">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:gae116a92a519bc1a7faa511e50ebd3b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#gae116a92a519bc1a7faa511e50ebd3b90"></a><br/></td></tr>
<tr class="separator:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaecb0cc5d9dcf5ed3c3a244b072b838ba">operator&lt;</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gaecb0cc5d9dcf5ed3c3a244b072b838ba"></a><br/></td></tr>
<tr class="separator:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafdbb1c3cbb179e0e86ef79b4ffa11dc4">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#gafdbb1c3cbb179e0e86ef79b4ffa11dc4"></a><br/></td></tr>
<tr class="separator:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga84f7eea431aca4b1b3741d765cfe300e">operator&gt;</a> (const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga84f7eea431aca4b1b3741d765cfe300e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga84f7eea431aca4b1b3741d765cfe300e"></a><br/></td></tr>
<tr class="separator:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaab2ec2c16b016e3ba86a076cee12001d">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;)</td></tr>
<tr class="memdesc:gaab2ec2c16b016e3ba86a076cee12001d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="../../de/df1/group__math.html#gaab2ec2c16b016e3ba86a076cee12001d"></a><br/></td></tr>
<tr class="separator:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DynamicMatrix operators</div></td></tr>
<tr class="memitem:gaa54415384b69f52ee6073d139ad084b3"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:gaa54415384b69f52ee6073d139ad084b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#gaa54415384b69f52ee6073d139ad084b3">isnan</a> (const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gaa54415384b69f52ee6073d139ad084b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given matrix for not-a-number elements.  <a href="../../dd/dfc/group__dynamic__matrix.html#gaa54415384b69f52ee6073d139ad084b3"></a><br/></td></tr>
<tr class="separator:gaa54415384b69f52ee6073d139ad084b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0b6bd39504d1c632cb5a77658f3c66"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:gaab0b6bd39504d1c632cb5a77658f3c66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#gaab0b6bd39504d1c632cb5a77658f3c66">reset</a> (<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gaab0b6bd39504d1c632cb5a77658f3c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given dense matrix.  <a href="../../dd/dfc/group__dynamic__matrix.html#gaab0b6bd39504d1c632cb5a77658f3c66"></a><br/></td></tr>
<tr class="separator:gaab0b6bd39504d1c632cb5a77658f3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27bd64e4886d3ea017d6624d634a5145"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga27bd64e4886d3ea017d6624d634a5145"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#ga27bd64e4886d3ea017d6624d634a5145">clear</a> (<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga27bd64e4886d3ea017d6624d634a5145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given dense matrix.  <a href="../../dd/dfc/group__dynamic__matrix.html#ga27bd64e4886d3ea017d6624d634a5145"></a><br/></td></tr>
<tr class="separator:ga27bd64e4886d3ea017d6624d634a5145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21449e9057f62feff3d74ef13064366"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:gad21449e9057f62feff3d74ef13064366"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#gad21449e9057f62feff3d74ef13064366">isDefault</a> (const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gad21449e9057f62feff3d74ef13064366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given dense matrix is in default state.  <a href="../../dd/dfc/group__dynamic__matrix.html#gad21449e9057f62feff3d74ef13064366"></a><br/></td></tr>
<tr class="separator:gad21449e9057f62feff3d74ef13064366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa260b971baf75fe0287f344d90b065bd"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:gaa260b971baf75fe0287f344d90b065bd"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#gaa260b971baf75fe0287f344d90b065bd">inv</a> (const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gaa260b971baf75fe0287f344d90b065bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given dense matrix.  <a href="../../dd/dfc/group__dynamic__matrix.html#gaa260b971baf75fe0287f344d90b065bd"></a><br/></td></tr>
<tr class="separator:gaa260b971baf75fe0287f344d90b065bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acf72d63a219160a9f11cec3a091d66"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga3acf72d63a219160a9f11cec3a091d66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/dfc/group__dynamic__matrix.html#ga3acf72d63a219160a9f11cec3a091d66">swap</a> (<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;a, <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;b)</td></tr>
<tr class="memdesc:ga3acf72d63a219160a9f11cec3a091d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="../../dd/dfc/group__dynamic__matrix.html#ga3acf72d63a219160a9f11cec3a091d66"></a><br/></td></tr>
<tr class="separator:ga3acf72d63a219160a9f11cec3a091d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DynamicVector operators</div></td></tr>
<tr class="memitem:a2fec0c1b60eb0357323c125b538a4192"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:a2fec0c1b60eb0357323c125b538a4192"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a2fec0c1b60eb0357323c125b538a4192">reset</a> (<a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:a2fec0c1b60eb0357323c125b538a4192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given dynamic vector.  <a href="#a2fec0c1b60eb0357323c125b538a4192"></a><br/></td></tr>
<tr class="separator:a2fec0c1b60eb0357323c125b538a4192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5f8ac862261819dde5428784642893"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:abb5f8ac862261819dde5428784642893"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#abb5f8ac862261819dde5428784642893">clear</a> (<a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:abb5f8ac862261819dde5428784642893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given dynamic vector.  <a href="#abb5f8ac862261819dde5428784642893"></a><br/></td></tr>
<tr class="separator:abb5f8ac862261819dde5428784642893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7390e875bf1db2385207fe64e230e7"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:a4a7390e875bf1db2385207fe64e230e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a4a7390e875bf1db2385207fe64e230e7">isnan</a> (const <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:a4a7390e875bf1db2385207fe64e230e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given dynamic vector for not-a-number elements.  <a href="#a4a7390e875bf1db2385207fe64e230e7"></a><br/></td></tr>
<tr class="separator:a4a7390e875bf1db2385207fe64e230e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef79474bdecfb65923e504b5fe40843"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:aeef79474bdecfb65923e504b5fe40843"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aeef79474bdecfb65923e504b5fe40843">isDefault</a> (const <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:aeef79474bdecfb65923e504b5fe40843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given dynamic vector is in default state.  <a href="#aeef79474bdecfb65923e504b5fe40843"></a><br/></td></tr>
<tr class="separator:aeef79474bdecfb65923e504b5fe40843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d4cd69110729a64a3717e0d628f011"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:a13d4cd69110729a64a3717e0d628f011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a13d4cd69110729a64a3717e0d628f011">swap</a> (<a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;a, <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html">DynamicVector</a>&lt; Type, TF &gt; &amp;b)</td></tr>
<tr class="memdesc:a13d4cd69110729a64a3717e0d628f011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two vectors.  <a href="#a13d4cd69110729a64a3717e0d628f011"></a><br/></td></tr>
<tr class="separator:a13d4cd69110729a64a3717e0d628f011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">StaticMatrix operators</div></td></tr>
<tr class="memitem:gac699a75335f12e81c3e78616a921cff4"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gac699a75335f12e81c3e78616a921cff4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#gac699a75335f12e81c3e78616a921cff4">isnan</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gac699a75335f12e81c3e78616a921cff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given matrix for not-a-number elements.  <a href="../../d5/def/group__static__matrix.html#gac699a75335f12e81c3e78616a921cff4"></a><br/></td></tr>
<tr class="separator:gac699a75335f12e81c3e78616a921cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac31655524a82392af7af7aba42acc9b6"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gac31655524a82392af7af7aba42acc9b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#gac31655524a82392af7af7aba42acc9b6">reset</a> (<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gac31655524a82392af7af7aba42acc9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given static matrix.  <a href="../../d5/def/group__static__matrix.html#gac31655524a82392af7af7aba42acc9b6"></a><br/></td></tr>
<tr class="separator:gac31655524a82392af7af7aba42acc9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4baae3cffff62571955e3d90a182fe8"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gaf4baae3cffff62571955e3d90a182fe8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#gaf4baae3cffff62571955e3d90a182fe8">clear</a> (<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gaf4baae3cffff62571955e3d90a182fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given static matrix.  <a href="../../d5/def/group__static__matrix.html#gaf4baae3cffff62571955e3d90a182fe8"></a><br/></td></tr>
<tr class="separator:gaf4baae3cffff62571955e3d90a182fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8abc10190d774951de58b6a4efde8f27"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:ga8abc10190d774951de58b6a4efde8f27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#ga8abc10190d774951de58b6a4efde8f27">isDefault</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8abc10190d774951de58b6a4efde8f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given static matrix is in default state.  <a href="../../d5/def/group__static__matrix.html#ga8abc10190d774951de58b6a4efde8f27"></a><br/></td></tr>
<tr class="separator:ga8abc10190d774951de58b6a4efde8f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb598d8f220fc53a6fa9639d22d1e0a2"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t M, size_t N, bool SO&gt; </td></tr>
<tr class="memitem:gafb598d8f220fc53a6fa9639d22d1e0a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/def/group__static__matrix.html#gafb598d8f220fc53a6fa9639d22d1e0a2">swap</a> (<a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;a, <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, M, N, SO &gt; &amp;b)</td></tr>
<tr class="memdesc:gafb598d8f220fc53a6fa9639d22d1e0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two static matrices.  <a href="../../d5/def/group__static__matrix.html#gafb598d8f220fc53a6fa9639d22d1e0a2"></a><br/></td></tr>
<tr class="separator:gafb598d8f220fc53a6fa9639d22d1e0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">StaticVector operators</div></td></tr>
<tr class="memitem:gaf45141ccd921b051044a99737b82a22c"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:gaf45141ccd921b051044a99737b82a22c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#gaf45141ccd921b051044a99737b82a22c">isnan</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gaf45141ccd921b051044a99737b82a22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given vector for not-a-number elements.  <a href="../../d4/d95/group__static__vector.html#gaf45141ccd921b051044a99737b82a22c"></a><br/></td></tr>
<tr class="separator:gaf45141ccd921b051044a99737b82a22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae163f13f07c819a1893b6f808eaa5413"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:gae163f13f07c819a1893b6f808eaa5413"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#gae163f13f07c819a1893b6f808eaa5413">reset</a> (<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gae163f13f07c819a1893b6f808eaa5413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given static vector.  <a href="../../d4/d95/group__static__vector.html#gae163f13f07c819a1893b6f808eaa5413"></a><br/></td></tr>
<tr class="separator:gae163f13f07c819a1893b6f808eaa5413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f74183430418c81f47e4546da92212"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga25f74183430418c81f47e4546da92212"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#ga25f74183430418c81f47e4546da92212">clear</a> (<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga25f74183430418c81f47e4546da92212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given static vector.  <a href="../../d4/d95/group__static__vector.html#ga25f74183430418c81f47e4546da92212"></a><br/></td></tr>
<tr class="separator:ga25f74183430418c81f47e4546da92212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0cf22f8633faf616d031d64a08cb9ee"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:gae0cf22f8633faf616d031d64a08cb9ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#gae0cf22f8633faf616d031d64a08cb9ee">isDefault</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gae0cf22f8633faf616d031d64a08cb9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given static vector is in default state.  <a href="../../d4/d95/group__static__vector.html#gae0cf22f8633faf616d031d64a08cb9ee"></a><br/></td></tr>
<tr class="separator:gae0cf22f8633faf616d031d64a08cb9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057a8e52f5bc1681c44e4830b1102a7b"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga057a8e52f5bc1681c44e4830b1102a7b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, 2UL, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#ga057a8e52f5bc1681c44e4830b1102a7b">perp</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, 2UL, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga057a8e52f5bc1681c44e4830b1102a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary perp dot product operator for the calculation of a perpendicular vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}^\perp $" src="../../form_81.png"/>).  <a href="../../d4/d95/group__static__vector.html#ga057a8e52f5bc1681c44e4830b1102a7b"></a><br/></td></tr>
<tr class="separator:ga057a8e52f5bc1681c44e4830b1102a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a4bc9026cfbb388c00c39328f627430"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga6a4bc9026cfbb388c00c39328f627430"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, 3UL, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#ga6a4bc9026cfbb388c00c39328f627430">perp</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, 3UL, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga6a4bc9026cfbb388c00c39328f627430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perpendicular vector b which satisfies <img class="formulaInl" alt="$ \vec{a} \cdot \vec{b} = 0 $" src="../../form_85.png"/>.  <a href="../../d4/d95/group__static__vector.html#ga6a4bc9026cfbb388c00c39328f627430"></a><br/></td></tr>
<tr class="separator:ga6a4bc9026cfbb388c00c39328f627430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e003e0e8d5c6b0e87f4c41c5e439f1"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t N, bool TF&gt; </td></tr>
<tr class="memitem:ga41e003e0e8d5c6b0e87f4c41c5e439f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html#ga41e003e0e8d5c6b0e87f4c41c5e439f1">swap</a> (<a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;a, <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; Type, N, TF &gt; &amp;b)</td></tr>
<tr class="memdesc:ga41e003e0e8d5c6b0e87f4c41c5e439f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two 2D vectors.  <a href="../../d4/d95/group__static__vector.html#ga41e003e0e8d5c6b0e87f4c41c5e439f1"></a><br/></td></tr>
<tr class="separator:ga41e003e0e8d5c6b0e87f4c41c5e439f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseMatrix operators</div></td></tr>
<tr class="memitem:ga7120542028164e84f57b2bd0daf1ed07"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7120542028164e84f57b2bd0daf1ed07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7120542028164e84f57b2bd0daf1ed07">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7120542028164e84f57b2bd0daf1ed07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two rwo-major dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga7120542028164e84f57b2bd0daf1ed07"></a><br/></td></tr>
<tr class="separator:ga7120542028164e84f57b2bd0daf1ed07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga3e85fa1492d985e034b7ca152d69dac2">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3e85fa1492d985e034b7ca152d69dac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga3e85fa1492d985e034b7ca152d69dac2"></a><br/></td></tr>
<tr class="separator:ga3e85fa1492d985e034b7ca152d69dac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gacff1ea4c8128a09b47db0c324da5c2f0">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense matrices with different storage order.  <a href="../../db/df0/group__dense__matrix.html#gacff1ea4c8128a09b47db0c324da5c2f0"></a><br/></td></tr>
<tr class="separator:gacff1ea4c8128a09b47db0c324da5c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga192685ae7dfdfa74ee94a9d6c51d1809">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense matrix and a row-major sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga192685ae7dfdfa74ee94a9d6c51d1809"></a><br/></td></tr>
<tr class="separator:ga192685ae7dfdfa74ee94a9d6c51d1809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga8212c8f46b5a2e31e355922f8fc2e3fc">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense matrix and a column-major sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga8212c8f46b5a2e31e355922f8fc2e3fc"></a><br/></td></tr>
<tr class="separator:ga8212c8f46b5a2e31e355922f8fc2e3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga242470c706af7ba3a96eb35a1816b4cf">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga242470c706af7ba3a96eb35a1816b4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse matrix and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga242470c706af7ba3a96eb35a1816b4cf"></a><br/></td></tr>
<tr class="separator:ga242470c706af7ba3a96eb35a1816b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374ed59697f34c5f51222954dece0ae9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga374ed59697f34c5f51222954dece0ae9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga374ed59697f34c5f51222954dece0ae9">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga374ed59697f34c5f51222954dece0ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a row-major dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga374ed59697f34c5f51222954dece0ae9"></a><br/></td></tr>
<tr class="separator:ga374ed59697f34c5f51222954dece0ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a80c742dd4e3bfb5e88b45da24a3f5a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7a80c742dd4e3bfb5e88b45da24a3f5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga7a80c742dd4e3bfb5e88b45da24a3f5a">operator==</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga7a80c742dd4e3bfb5e88b45da24a3f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a column-major dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga7a80c742dd4e3bfb5e88b45da24a3f5a"></a><br/></td></tr>
<tr class="separator:ga7a80c742dd4e3bfb5e88b45da24a3f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb3f2498dfde72863f8cbc74da31151"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gafeb3f2498dfde72863f8cbc74da31151"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gafeb3f2498dfde72863f8cbc74da31151">operator==</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gafeb3f2498dfde72863f8cbc74da31151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gafeb3f2498dfde72863f8cbc74da31151"></a><br/></td></tr>
<tr class="separator:gafeb3f2498dfde72863f8cbc74da31151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga52848b40fa0e5a7f72bdcdd92d68f032">operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense matrices.  <a href="../../db/df0/group__dense__matrix.html#ga52848b40fa0e5a7f72bdcdd92d68f032"></a><br/></td></tr>
<tr class="separator:ga52848b40fa0e5a7f72bdcdd92d68f032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174d0a369968b438ed23725b3361283c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga174d0a369968b438ed23725b3361283c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga174d0a369968b438ed23725b3361283c">operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga174d0a369968b438ed23725b3361283c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense matrix and a sparse matrix.  <a href="../../db/df0/group__dense__matrix.html#ga174d0a369968b438ed23725b3361283c"></a><br/></td></tr>
<tr class="separator:ga174d0a369968b438ed23725b3361283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#gaa83dce66f3d82b99bb0dd83aa3efb7a4">operator!=</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse matrix and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#gaa83dce66f3d82b99bb0dd83aa3efb7a4"></a><br/></td></tr>
<tr class="separator:gaa83dce66f3d82b99bb0dd83aa3efb7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac367236edb3d35930c6b4db03f7bf7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga0ac367236edb3d35930c6b4db03f7bf7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga0ac367236edb3d35930c6b4db03f7bf7">operator!=</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;mat, T2 scalar)</td></tr>
<tr class="memdesc:ga0ac367236edb3d35930c6b4db03f7bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense matrix and a scalar value.  <a href="../../db/df0/group__dense__matrix.html#ga0ac367236edb3d35930c6b4db03f7bf7"></a><br/></td></tr>
<tr class="separator:ga0ac367236edb3d35930c6b4db03f7bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d92511a049e9850455725d5a58bf45"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga21d92511a049e9850455725d5a58bf45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/df0/group__dense__matrix.html#ga21d92511a049e9850455725d5a58bf45">operator!=</a> (T1 scalar, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga21d92511a049e9850455725d5a58bf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense matrix.  <a href="../../db/df0/group__dense__matrix.html#ga21d92511a049e9850455725d5a58bf45"></a><br/></td></tr>
<tr class="separator:ga21d92511a049e9850455725d5a58bf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseVector operators</div></td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7718438f21d78c1c5cd61e11b620f3ac">operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense vectors.  <a href="../../de/d90/group__dense__vector.html#ga7718438f21d78c1c5cd61e11b620f3ac"></a><br/></td></tr>
<tr class="separator:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga521be975d8edae170b5f159468392be7">operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga521be975d8edae170b5f159468392be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a sparse vector.  <a href="../../de/d90/group__dense__vector.html#ga521be975d8edae170b5f159468392be7"></a><br/></td></tr>
<tr class="separator:ga521be975d8edae170b5f159468392be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga90afa4cbe670f292f01e0a8c0989bcb4">operator==</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse vector and a dense vector.  <a href="../../de/d90/group__dense__vector.html#ga90afa4cbe670f292f01e0a8c0989bcb4"></a><br/></td></tr>
<tr class="separator:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6253dd234e9b48e75e0ec02050b959"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gacb6253dd234e9b48e75e0ec02050b959"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacb6253dd234e9b48e75e0ec02050b959">operator==</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:gacb6253dd234e9b48e75e0ec02050b959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a scalar value.  <a href="../../de/d90/group__dense__vector.html#gacb6253dd234e9b48e75e0ec02050b959"></a><br/></td></tr>
<tr class="separator:gacb6253dd234e9b48e75e0ec02050b959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab20536da4445fc400927e431fbdf331"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaab20536da4445fc400927e431fbdf331"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaab20536da4445fc400927e431fbdf331">operator==</a> (T1 scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gaab20536da4445fc400927e431fbdf331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense vector.  <a href="../../de/d90/group__dense__vector.html#gaab20536da4445fc400927e431fbdf331"></a><br/></td></tr>
<tr class="separator:gaab20536da4445fc400927e431fbdf331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1d006cc08bc800f749d0cffb9ddbb9a7">operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense vectors.  <a href="../../de/d90/group__dense__vector.html#ga1d006cc08bc800f749d0cffb9ddbb9a7"></a><br/></td></tr>
<tr class="separator:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a sparse vector.  <a href="../../de/d90/group__dense__vector.html#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"></a><br/></td></tr>
<tr class="separator:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabde27bb0ee7f998bef03dceca10cdce3">operator!=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabde27bb0ee7f998bef03dceca10cdce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse vector and a dense vector.  <a href="../../de/d90/group__dense__vector.html#gabde27bb0ee7f998bef03dceca10cdce3"></a><br/></td></tr>
<tr class="separator:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga2c595fd68d81ec3c4fd30eb74bbcee95">operator!=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a scalar value.  <a href="../../de/d90/group__dense__vector.html#ga2c595fd68d81ec3c4fd30eb74bbcee95"></a><br/></td></tr>
<tr class="separator:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; T1 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd6f670282d5c2e8ee9f118f71f894a3">operator!=</a> (T1 scalar, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense vector.  <a href="../../de/d90/group__dense__vector.html#gafd6f670282d5c2e8ee9f118f71f894a3"></a><br/></td></tr>
<tr class="separator:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DenseVector functions</div></td></tr>
<tr class="memitem:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4da64f9a5a93b1db2af56e66ade1cd9d">min</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the dense vector.  <a href="../../de/d90/group__dense__vector.html#ga4da64f9a5a93b1db2af56e66ade1cd9d"></a><br/></td></tr>
<tr class="separator:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89281c892b6ca297f5450ed0e3948c81"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga89281c892b6ca297f5450ed0e3948c81"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga89281c892b6ca297f5450ed0e3948c81">max</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga89281c892b6ca297f5450ed0e3948c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the dense vector.  <a href="../../de/d90/group__dense__vector.html#ga89281c892b6ca297f5450ed0e3948c81"></a><br/></td></tr>
<tr class="separator:ga89281c892b6ca297f5450ed0e3948c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NegativeEpsilon operators</div></td></tr>
<tr class="memitem:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7b8b533b8e6a1bbcc85cbd8de67a07bd">operator==</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga7b8b533b8e6a1bbcc85cbd8de67a07bd"></a><br/></td></tr>
<tr class="separator:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3cfe831bb614ba1d4a67eaea42c82998">operator==</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga3cfe831bb614ba1d4a67eaea42c82998"></a><br/></td></tr>
<tr class="separator:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafc02f01b7d880ce7e0f5413746872b3d">operator!=</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gafc02f01b7d880ce7e0f5413746872b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gafc02f01b7d880ce7e0f5413746872b3d"></a><br/></td></tr>
<tr class="separator:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d93714b380cec87ee26da168f4a0e5"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga46d93714b380cec87ee26da168f4a0e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga46d93714b380cec87ee26da168f4a0e5">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga46d93714b380cec87ee26da168f4a0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga46d93714b380cec87ee26da168f4a0e5"></a><br/></td></tr>
<tr class="separator:ga46d93714b380cec87ee26da168f4a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac1d14e4e7b3ef42af647b7d92db0f6cc">operator&lt;</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gac1d14e4e7b3ef42af647b7d92db0f6cc"></a><br/></td></tr>
<tr class="separator:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b86a750765429e61761ff7baee2b9d5"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga9b86a750765429e61761ff7baee2b9d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b86a750765429e61761ff7baee2b9d5">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga9b86a750765429e61761ff7baee2b9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#ga9b86a750765429e61761ff7baee2b9d5"></a><br/></td></tr>
<tr class="separator:ga9b86a750765429e61761ff7baee2b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga22864fea6db8d1ca553b327194d0b9aa">operator&gt;</a> (const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga22864fea6db8d1ca553b327194d0b9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga22864fea6db8d1ca553b327194d0b9aa"></a><br/></td></tr>
<tr class="separator:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaedd63616a647a5c54dd3fc4d8061010b">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:gaedd63616a647a5c54dd3fc4d8061010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="../../de/df1/group__math.html#gaedd63616a647a5c54dd3fc4d8061010b"></a><br/></td></tr>
<tr class="separator:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Epsilon operators</div></td></tr>
<tr class="memitem:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac3ec406b1801fa25c3f9ffa9144cee0b">operator==</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gac3ec406b1801fa25c3f9ffa9144cee0b"></a><br/></td></tr>
<tr class="separator:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8e7b4cf5af885cb431eb37281691fe4d">operator==</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga8e7b4cf5af885cb431eb37281691fe4d"></a><br/></td></tr>
<tr class="separator:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a50f57ff770309ebb61142b2a425d27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7a50f57ff770309ebb61142b2a425d27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7a50f57ff770309ebb61142b2a425d27">operator!=</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga7a50f57ff770309ebb61142b2a425d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga7a50f57ff770309ebb61142b2a425d27"></a><br/></td></tr>
<tr class="separator:ga7a50f57ff770309ebb61142b2a425d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927507337b7b6cdbe244112194218275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga927507337b7b6cdbe244112194218275"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga927507337b7b6cdbe244112194218275">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga927507337b7b6cdbe244112194218275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga927507337b7b6cdbe244112194218275"></a><br/></td></tr>
<tr class="separator:ga927507337b7b6cdbe244112194218275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73847d144e9f3c172f5630175c05e28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad73847d144e9f3c172f5630175c05e28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad73847d144e9f3c172f5630175c05e28">operator&lt;</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gad73847d144e9f3c172f5630175c05e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#gad73847d144e9f3c172f5630175c05e28"></a><br/></td></tr>
<tr class="separator:gad73847d144e9f3c172f5630175c05e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b5ff3c3bb106998735574abd5a081b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga25b5ff3c3bb106998735574abd5a081b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga25b5ff3c3bb106998735574abd5a081b">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:ga25b5ff3c3bb106998735574abd5a081b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#ga25b5ff3c3bb106998735574abd5a081b"></a><br/></td></tr>
<tr class="separator:ga25b5ff3c3bb106998735574abd5a081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga19f217c7d16c2691b15c61bd5aef9cee">operator&gt;</a> (const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="../../de/df1/group__math.html#ga19f217c7d16c2691b15c61bd5aef9cee"></a><br/></td></tr>
<tr class="separator:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf0cbca3f85e459a6b20902cb55daad67">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;)</td></tr>
<tr class="memdesc:gaf0cbca3f85e459a6b20902cb55daad67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="../../de/df1/group__math.html#gaf0cbca3f85e459a6b20902cb55daad67"></a><br/></td></tr>
<tr class="separator:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix global functions</div></td></tr>
<tr class="memitem:gabc7519d1f97a36dc012fc17aa35e1d4c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:gabc7519d1f97a36dc012fc17aa35e1d4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#gabc7519d1f97a36dc012fc17aa35e1d4c">rows</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:gabc7519d1f97a36dc012fc17aa35e1d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the matrix.  <a href="../../dd/d7a/group__matrix.html#gabc7519d1f97a36dc012fc17aa35e1d4c"></a><br/></td></tr>
<tr class="separator:gabc7519d1f97a36dc012fc17aa35e1d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83144b579d18b190434a90389e03f092"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga83144b579d18b190434a90389e03f092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga83144b579d18b190434a90389e03f092">columns</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga83144b579d18b190434a90389e03f092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the matrix.  <a href="../../dd/d7a/group__matrix.html#ga83144b579d18b190434a90389e03f092"></a><br/></td></tr>
<tr class="separator:ga83144b579d18b190434a90389e03f092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623130151fcd419dbfdf9cf18f013e32"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga623130151fcd419dbfdf9cf18f013e32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga623130151fcd419dbfdf9cf18f013e32">assign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga623130151fcd419dbfdf9cf18f013e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a matrix to a matrix.  <a href="../../dd/d7a/group__matrix.html#ga623130151fcd419dbfdf9cf18f013e32"></a><br/></td></tr>
<tr class="separator:ga623130151fcd419dbfdf9cf18f013e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac25bae6b8faf44077aed65aead5f20b5"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gac25bae6b8faf44077aed65aead5f20b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#gac25bae6b8faf44077aed65aead5f20b5">addAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac25bae6b8faf44077aed65aead5f20b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a matrix to a matrix.  <a href="../../dd/d7a/group__matrix.html#gac25bae6b8faf44077aed65aead5f20b5"></a><br/></td></tr>
<tr class="separator:gac25bae6b8faf44077aed65aead5f20b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafce1cd9ba381a232369fbe76fd76ebe2"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:gafce1cd9ba381a232369fbe76fd76ebe2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#gafce1cd9ba381a232369fbe76fd76ebe2">subAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafce1cd9ba381a232369fbe76fd76ebe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a matrix to matrix.  <a href="../../dd/d7a/group__matrix.html#gafce1cd9ba381a232369fbe76fd76ebe2"></a><br/></td></tr>
<tr class="separator:gafce1cd9ba381a232369fbe76fd76ebe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f8f567afc4a709b25202e3de79697e1"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , bool SO1, typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga9f8f567afc4a709b25202e3de79697e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga9f8f567afc4a709b25202e3de79697e1">multAssign</a> (<a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9f8f567afc4a709b25202e3de79697e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a matrix to a matrix.  <a href="../../dd/d7a/group__matrix.html#ga9f8f567afc4a709b25202e3de79697e1"></a><br/></td></tr>
<tr class="separator:ga9f8f567afc4a709b25202e3de79697e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector global functions</div></td></tr>
<tr class="memitem:abef4b65382dc714194effd67a6496f9d"><td class="memTemplParams" colspan="2"><a class="anchor" id="abef4b65382dc714194effd67a6496f9d"></a>
template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:abef4b65382dc714194effd67a6496f9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>size</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;v)</td></tr>
<tr class="separator:abef4b65382dc714194effd67a6496f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0a5d0c23ec5b0225ce822da16e5fe6"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga1b0a5d0c23ec5b0225ce822da16e5fe6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga1b0a5d0c23ec5b0225ce822da16e5fe6">assign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1b0a5d0c23ec5b0225ce822da16e5fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a vector to a vector.  <a href="../../dc/dcf/group__vector.html#ga1b0a5d0c23ec5b0225ce822da16e5fe6"></a><br/></td></tr>
<tr class="separator:ga1b0a5d0c23ec5b0225ce822da16e5fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2233b3b90e9567344b864a732c17bef1"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga2233b3b90e9567344b864a732c17bef1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga2233b3b90e9567344b864a732c17bef1">addAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2233b3b90e9567344b864a732c17bef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a vector to a vector.  <a href="../../dc/dcf/group__vector.html#ga2233b3b90e9567344b864a732c17bef1"></a><br/></td></tr>
<tr class="separator:ga2233b3b90e9567344b864a732c17bef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ef8c094702e7582c1863dd7f564bfa"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga93ef8c094702e7582c1863dd7f564bfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga93ef8c094702e7582c1863dd7f564bfa">subAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga93ef8c094702e7582c1863dd7f564bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a vector to a vector.  <a href="../../dc/dcf/group__vector.html#ga93ef8c094702e7582c1863dd7f564bfa"></a><br/></td></tr>
<tr class="separator:ga93ef8c094702e7582c1863dd7f564bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775ba62f359ed0f82a3b082649a6b771"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , bool TF1, typename VT2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga775ba62f359ed0f82a3b082649a6b771"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga775ba62f359ed0f82a3b082649a6b771">multAssign</a> (<a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT1, TF1 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga775ba62f359ed0f82a3b082649a6b771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a vector to a vector.  <a href="../../dc/dcf/group__vector.html#ga775ba62f359ed0f82a3b082649a6b771"></a><br/></td></tr>
<tr class="separator:ga775ba62f359ed0f82a3b082649a6b771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical utility functions</div></td></tr>
<tr class="memitem:ga7fa1fa59c0750d7100d4186258c9494f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7fa1fa59c0750d7100d4186258c9494f"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7fa1fa59c0750d7100d4186258c9494f">sign</a> (T a)</td></tr>
<tr class="memdesc:ga7fa1fa59c0750d7100d4186258c9494f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign function.  <a href="../../de/df1/group__math.html#ga7fa1fa59c0750d7100d4186258c9494f"></a><br/></td></tr>
<tr class="separator:ga7fa1fa59c0750d7100d4186258c9494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd55880375d550adbae4dd61aebea75d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabd55880375d550adbae4dd61aebea75d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d">digits</a> (T a)</td></tr>
<tr class="memdesc:gabd55880375d550adbae4dd61aebea75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of valid digits of an integral value.  <a href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d"></a><br/></td></tr>
<tr class="separator:gabd55880375d550adbae4dd61aebea75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f9e4a8f0ebfe145ebcdc392722947fa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2f9e4a8f0ebfe145ebcdc392722947fa"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">MathTrait</a>&lt; T1, T2 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2f9e4a8f0ebfe145ebcdc392722947fa">min</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ga2f9e4a8f0ebfe145ebcdc392722947fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function for two arguments.  <a href="../../de/df1/group__math.html#ga2f9e4a8f0ebfe145ebcdc392722947fa"></a><br/></td></tr>
<tr class="separator:ga2f9e4a8f0ebfe145ebcdc392722947fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a68749f87c9d78862a6ef990198b94d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ga4a68749f87c9d78862a6ef990198b94d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">MathTrait</a>&lt; typename <br class="typebreak"/>
<a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">MathTrait</a>&lt; T1, T2 &gt;::HighType, <br class="typebreak"/>
T3 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4a68749f87c9d78862a6ef990198b94d">min</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)</td></tr>
<tr class="memdesc:ga4a68749f87c9d78862a6ef990198b94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function for three arguments.  <a href="../../de/df1/group__math.html#ga4a68749f87c9d78862a6ef990198b94d"></a><br/></td></tr>
<tr class="separator:ga4a68749f87c9d78862a6ef990198b94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa529d2a056457bb5718bc9674b5d0769"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa529d2a056457bb5718bc9674b5d0769"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">MathTrait</a>&lt; T1, T2 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa529d2a056457bb5718bc9674b5d0769">max</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:gaa529d2a056457bb5718bc9674b5d0769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function for two arguments.  <a href="../../de/df1/group__math.html#gaa529d2a056457bb5718bc9674b5d0769"></a><br/></td></tr>
<tr class="separator:gaa529d2a056457bb5718bc9674b5d0769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13834d431b63318ee3a2e78293b16cb3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ga13834d431b63318ee3a2e78293b16cb3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">MathTrait</a>&lt; typename <br class="typebreak"/>
<a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">MathTrait</a>&lt; T1, T2 &gt;::HighType, <br class="typebreak"/>
T3 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga13834d431b63318ee3a2e78293b16cb3">max</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)</td></tr>
<tr class="memdesc:ga13834d431b63318ee3a2e78293b16cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function for three arguments.  <a href="../../de/df1/group__math.html#ga13834d431b63318ee3a2e78293b16cb3"></a><br/></td></tr>
<tr class="separator:ga13834d431b63318ee3a2e78293b16cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad24cbd848d0cfe4c28db2f49817182da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad24cbd848d0cfe4c28db2f49817182da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad24cbd848d0cfe4c28db2f49817182da">round</a> (T a)</td></tr>
<tr class="memdesc:gad24cbd848d0cfe4c28db2f49817182da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the given input value.  <a href="../../de/df1/group__math.html#gad24cbd848d0cfe4c28db2f49817182da"></a><br/></td></tr>
<tr class="separator:gad24cbd848d0cfe4c28db2f49817182da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ccf7fb44308f52badb6b0a914be832"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga13ccf7fb44308f52badb6b0a914be832"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga13ccf7fb44308f52badb6b0a914be832">lessThan</a> (T1 a, T2 b)</td></tr>
<tr class="memdesc:ga13ccf7fb44308f52badb6b0a914be832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic less-than comparison.  <a href="../../de/df1/group__math.html#ga13ccf7fb44308f52badb6b0a914be832"></a><br/></td></tr>
<tr class="separator:ga13ccf7fb44308f52badb6b0a914be832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">NegativeInfinity operators</div></td></tr>
<tr class="memitem:gaa89e010144eab077e9d596e74bab15b2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gaa89e010144eab077e9d596e74bab15b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa89e010144eab077e9d596e74bab15b2">operator==</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaa89e010144eab077e9d596e74bab15b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#gaa89e010144eab077e9d596e74bab15b2"></a><br/></td></tr>
<tr class="separator:gaa89e010144eab077e9d596e74bab15b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga52ce1ea57d9c7fd4be3ab4d75310032c">operator==</a> (const T &amp;lhs, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#ga52ce1ea57d9c7fd4be3ab4d75310032c"></a><br/></td></tr>
<tr class="separator:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313c450e022ce76f66888b2b6be23e70"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga313c450e022ce76f66888b2b6be23e70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga313c450e022ce76f66888b2b6be23e70">operator!=</a> (const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga313c450e022ce76f66888b2b6be23e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#ga313c450e022ce76f66888b2b6be23e70"></a><br/></td></tr>
<tr class="separator:ga313c450e022ce76f66888b2b6be23e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabc9e7c387680b76ecf9056a3354c4f82">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabc9e7c387680b76ecf9056a3354c4f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="../../de/df1/group__math.html#gabc9e7c387680b76ecf9056a3354c4f82"></a><br/></td></tr>
<tr class="separator:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Infinity operators</div></td></tr>
<tr class="memitem:ga051a2e303820cb2fde125c7516f75ce9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga051a2e303820cb2fde125c7516f75ce9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga051a2e303820cb2fde125c7516f75ce9">operator==</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga051a2e303820cb2fde125c7516f75ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#ga051a2e303820cb2fde125c7516f75ce9"></a><br/></td></tr>
<tr class="separator:ga051a2e303820cb2fde125c7516f75ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef53b8be129fa00b953bb0f160413b80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef53b8be129fa00b953bb0f160413b80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaef53b8be129fa00b953bb0f160413b80">operator==</a> (const T &amp;lhs, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;rhs)</td></tr>
<tr class="memdesc:gaef53b8be129fa00b953bb0f160413b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#gaef53b8be129fa00b953bb0f160413b80"></a><br/></td></tr>
<tr class="separator:gaef53b8be129fa00b953bb0f160413b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0b8c22e5fcef35073910201a7e0ae05a">operator!=</a> (const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="../../de/df1/group__math.html#ga0b8c22e5fcef35073910201a7e0ae05a"></a><br/></td></tr>
<tr class="separator:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1d28fd67d95a6015c5b5b6fd62762e22">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="../../de/df1/group__math.html#ga1d28fd67d95a6015c5b5b6fd62762e22"></a><br/></td></tr>
<tr class="separator:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix operators</div></td></tr>
<tr class="memitem:ga5f051fa9685c313199d2f2e38067b8ff"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO&gt; </td></tr>
<tr class="memitem:ga5f051fa9685c313199d2f2e38067b8ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html#ga5f051fa9685c313199d2f2e38067b8ff">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga5f051fa9685c313199d2f2e38067b8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for dense and sparse matrices.  <a href="../../dd/d7a/group__matrix.html#ga5f051fa9685c313199d2f2e38067b8ff"></a><br/></td></tr>
<tr class="separator:ga5f051fa9685c313199d2f2e38067b8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Quaternion operators</div></td></tr>
<tr class="memitem:ga7f58053a71d248fa55ae5391e62f6c43"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7f58053a71d248fa55ae5391e62f6c43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga7f58053a71d248fa55ae5391e62f6c43">operator==</a> (const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7f58053a71d248fa55ae5391e62f6c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two quaternions.  <a href="../../d3/d5e/group__quaternion.html#ga7f58053a71d248fa55ae5391e62f6c43"></a><br/></td></tr>
<tr class="separator:ga7f58053a71d248fa55ae5391e62f6c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6334ce7004e203210e40c868e735c1f9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6334ce7004e203210e40c868e735c1f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga6334ce7004e203210e40c868e735c1f9">operator!=</a> (const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6334ce7004e203210e40c868e735c1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two quaternions.  <a href="../../d3/d5e/group__quaternion.html#ga6334ce7004e203210e40c868e735c1f9"></a><br/></td></tr>
<tr class="separator:ga6334ce7004e203210e40c868e735c1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6175f09f1d5b71c782be4efee18187e2"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga6175f09f1d5b71c782be4efee18187e2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga6175f09f1d5b71c782be4efee18187e2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;q)</td></tr>
<tr class="memdesc:ga6175f09f1d5b71c782be4efee18187e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for quaternions.  <a href="../../d3/d5e/group__quaternion.html#ga6175f09f1d5b71c782be4efee18187e2"></a><br/></td></tr>
<tr class="separator:ga6175f09f1d5b71c782be4efee18187e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f01d80143ef987c8a357e0585ad850"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga05f01d80143ef987c8a357e0585ad850"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga05f01d80143ef987c8a357e0585ad850">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;q)</td></tr>
<tr class="memdesc:ga05f01d80143ef987c8a357e0585ad850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global input operator for quaternions.  <a href="../../d3/d5e/group__quaternion.html#ga05f01d80143ef987c8a357e0585ad850"></a><br/></td></tr>
<tr class="separator:ga05f01d80143ef987c8a357e0585ad850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf353d4614c645361db7b92784f3405"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gadcf353d4614c645361db7b92784f3405"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#gadcf353d4614c645361db7b92784f3405">isnan</a> (const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;q)</td></tr>
<tr class="memdesc:gadcf353d4614c645361db7b92784f3405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given quaternion for not-a-number elements.  <a href="../../d3/d5e/group__quaternion.html#gadcf353d4614c645361db7b92784f3405"></a><br/></td></tr>
<tr class="separator:gadcf353d4614c645361db7b92784f3405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d1f7a3f89b9f31627abbd79e90e000"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gac4d1f7a3f89b9f31627abbd79e90e000"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#gac4d1f7a3f89b9f31627abbd79e90e000">reset</a> (<a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;q)</td></tr>
<tr class="memdesc:gac4d1f7a3f89b9f31627abbd79e90e000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given quaternion.  <a href="../../d3/d5e/group__quaternion.html#gac4d1f7a3f89b9f31627abbd79e90e000"></a><br/></td></tr>
<tr class="separator:gac4d1f7a3f89b9f31627abbd79e90e000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0783ef1049b915913c5fb64e40da61a4"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga0783ef1049b915913c5fb64e40da61a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga0783ef1049b915913c5fb64e40da61a4">clear</a> (<a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;q)</td></tr>
<tr class="memdesc:ga0783ef1049b915913c5fb64e40da61a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given quaternion.  <a href="../../d3/d5e/group__quaternion.html#ga0783ef1049b915913c5fb64e40da61a4"></a><br/></td></tr>
<tr class="separator:ga0783ef1049b915913c5fb64e40da61a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f844dd3f9bc1d7fdbf739ff75d1d52d"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga7f844dd3f9bc1d7fdbf739ff75d1d52d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga7f844dd3f9bc1d7fdbf739ff75d1d52d">isDefault</a> (const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;q)</td></tr>
<tr class="memdesc:ga7f844dd3f9bc1d7fdbf739ff75d1d52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given quaternion is in default state.  <a href="../../d3/d5e/group__quaternion.html#ga7f844dd3f9bc1d7fdbf739ff75d1d52d"></a><br/></td></tr>
<tr class="separator:ga7f844dd3f9bc1d7fdbf739ff75d1d52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5594b34c15e8e49f989b0611d41ae4"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga2a5594b34c15e8e49f989b0611d41ae4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga2a5594b34c15e8e49f989b0611d41ae4">inv</a> (const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;q)</td></tr>
<tr class="memdesc:ga2a5594b34c15e8e49f989b0611d41ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given quaternion ( <img class="formulaInl" alt="$ \hat{q} = \hat{p}^{-1} $" src="../../form_145.png"/>).  <a href="../../d3/d5e/group__quaternion.html#ga2a5594b34c15e8e49f989b0611d41ae4"></a><br/></td></tr>
<tr class="separator:ga2a5594b34c15e8e49f989b0611d41ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0cc0551a3ac216d6f8c5cd78b589e7"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga9f0cc0551a3ac216d6f8c5cd78b589e7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga9f0cc0551a3ac216d6f8c5cd78b589e7">sq</a> (const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;q)</td></tr>
<tr class="memdesc:ga9f0cc0551a3ac216d6f8c5cd78b589e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squaring the given quaternion.  <a href="../../d3/d5e/group__quaternion.html#ga9f0cc0551a3ac216d6f8c5cd78b589e7"></a><br/></td></tr>
<tr class="separator:ga9f0cc0551a3ac216d6f8c5cd78b589e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf96e26dbdffecea3521952429c3373a9"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gaf96e26dbdffecea3521952429c3373a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#gaf96e26dbdffecea3521952429c3373a9">swap</a> (<a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;a, <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; Type &gt; &amp;b)</td></tr>
<tr class="memdesc:gaf96e26dbdffecea3521952429c3373a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two quaternions.  <a href="../../d3/d5e/group__quaternion.html#gaf96e26dbdffecea3521952429c3373a9"></a><br/></td></tr>
<tr class="separator:gaf96e26dbdffecea3521952429c3373a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Quaternion arithmetic operators</div></td></tr>
<tr class="memitem:ga89266d47cb1d61482c5b35cb9ab21689"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga89266d47cb1d61482c5b35cb9ab21689"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; typename <br class="typebreak"/>
<a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; T1, T2 &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html#ga89266d47cb1d61482c5b35cb9ab21689">operator*</a> (const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d5/d29/classblaze_1_1Quaternion.html">Quaternion</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga89266d47cb1d61482c5b35cb9ab21689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two quaternions ( <img class="formulaInl" alt="$ \hat{q}=\hat{p}*\hat{r} $" src="../../form_147.png"/>).  <a href="../../d3/d5e/group__quaternion.html#ga89266d47cb1d61482c5b35cb9ab21689"></a><br/></td></tr>
<tr class="separator:ga89266d47cb1d61482c5b35cb9ab21689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">RotationMatrix operators</div></td></tr>
<tr class="memitem:gac877b22625174dc83fdfa4e539fa48fa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac877b22625174dc83fdfa4e539fa48fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gac877b22625174dc83fdfa4e539fa48fa">operator==</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac877b22625174dc83fdfa4e539fa48fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two rotation matrices.  <a href="../../da/d8d/group__dense__rotation__matrix.html#gac877b22625174dc83fdfa4e539fa48fa"></a><br/></td></tr>
<tr class="separator:gac877b22625174dc83fdfa4e539fa48fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a4b712e20a38c2e8f3bd6e06a833dd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga62a4b712e20a38c2e8f3bd6e06a833dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga62a4b712e20a38c2e8f3bd6e06a833dd">operator!=</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga62a4b712e20a38c2e8f3bd6e06a833dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two rotation matrices.  <a href="../../da/d8d/group__dense__rotation__matrix.html#ga62a4b712e20a38c2e8f3bd6e06a833dd"></a><br/></td></tr>
<tr class="separator:ga62a4b712e20a38c2e8f3bd6e06a833dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92152b5754c266307a7cca524d95cb4"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gab92152b5754c266307a7cca524d95cb4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gab92152b5754c266307a7cca524d95cb4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:gab92152b5754c266307a7cca524d95cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for 3x3 rotation matrices.  <a href="../../da/d8d/group__dense__rotation__matrix.html#gab92152b5754c266307a7cca524d95cb4"></a><br/></td></tr>
<tr class="separator:gab92152b5754c266307a7cca524d95cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaaa99da9b10923b292153581f3d6fdb"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gabaaa99da9b10923b292153581f3d6fdb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gabaaa99da9b10923b292153581f3d6fdb">isnan</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:gabaaa99da9b10923b292153581f3d6fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given rotation matrix for not-a-number elements.  <a href="../../da/d8d/group__dense__rotation__matrix.html#gabaaa99da9b10923b292153581f3d6fdb"></a><br/></td></tr>
<tr class="separator:gabaaa99da9b10923b292153581f3d6fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23df6b6e7bcbf11f3d1e12cf011a3a4"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gac23df6b6e7bcbf11f3d1e12cf011a3a4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, 3UL, 3UL, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gac23df6b6e7bcbf11f3d1e12cf011a3a4">abs</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:gac23df6b6e7bcbf11f3d1e12cf011a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the absolute values of each single element of <em>m</em>.  <a href="../../da/d8d/group__dense__rotation__matrix.html#gac23df6b6e7bcbf11f3d1e12cf011a3a4"></a><br/></td></tr>
<tr class="separator:gac23df6b6e7bcbf11f3d1e12cf011a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5016a6213476c427e1f16c8f057283b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gaa5016a6213476c427e1f16c8f057283b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; Type, 3UL, 3UL, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gaa5016a6213476c427e1f16c8f057283b">fabs</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:gaa5016a6213476c427e1f16c8f057283b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix containing the absolute values of each single element of <em>m</em>.  <a href="../../da/d8d/group__dense__rotation__matrix.html#gaa5016a6213476c427e1f16c8f057283b"></a><br/></td></tr>
<tr class="separator:gaa5016a6213476c427e1f16c8f057283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5015ba1858b75f35fd844c7464daf6b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gaa5015ba1858b75f35fd844c7464daf6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gaa5015ba1858b75f35fd844c7464daf6b">reset</a> (<a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:gaa5015ba1858b75f35fd844c7464daf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given rotation matrix.  <a href="../../da/d8d/group__dense__rotation__matrix.html#gaa5015ba1858b75f35fd844c7464daf6b"></a><br/></td></tr>
<tr class="separator:gaa5015ba1858b75f35fd844c7464daf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403ff009926c046158d675175d11e61e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga403ff009926c046158d675175d11e61e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga403ff009926c046158d675175d11e61e">clear</a> (<a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:ga403ff009926c046158d675175d11e61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given rotation matrix.  <a href="../../da/d8d/group__dense__rotation__matrix.html#ga403ff009926c046158d675175d11e61e"></a><br/></td></tr>
<tr class="separator:ga403ff009926c046158d675175d11e61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2973f9b52c5d8c3e6dde603cf4cc7628"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga2973f9b52c5d8c3e6dde603cf4cc7628"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga2973f9b52c5d8c3e6dde603cf4cc7628">isDefault</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:ga2973f9b52c5d8c3e6dde603cf4cc7628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given rotation matrix is in default state.  <a href="../../da/d8d/group__dense__rotation__matrix.html#ga2973f9b52c5d8c3e6dde603cf4cc7628"></a><br/></td></tr>
<tr class="separator:ga2973f9b52c5d8c3e6dde603cf4cc7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ba6581e9d712178dd2e2a999220ded"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga37ba6581e9d712178dd2e2a999220ded"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga37ba6581e9d712178dd2e2a999220ded">trans</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:ga37ba6581e9d712178dd2e2a999220ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the rotation matrix.  <a href="../../da/d8d/group__dense__rotation__matrix.html#ga37ba6581e9d712178dd2e2a999220ded"></a><br/></td></tr>
<tr class="separator:ga37ba6581e9d712178dd2e2a999220ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f7d4da3c77614a8d10ed6edaf8c7be"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gaf2f7d4da3c77614a8d10ed6edaf8c7be"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gaf2f7d4da3c77614a8d10ed6edaf8c7be">inv</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:gaf2f7d4da3c77614a8d10ed6edaf8c7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given rotation matrix.  <a href="../../da/d8d/group__dense__rotation__matrix.html#gaf2f7d4da3c77614a8d10ed6edaf8c7be"></a><br/></td></tr>
<tr class="separator:gaf2f7d4da3c77614a8d10ed6edaf8c7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c3b52a237ac9fd87c1e65fa5dadd4c"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gab5c3b52a237ac9fd87c1e65fa5dadd4c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gab5c3b52a237ac9fd87c1e65fa5dadd4c">sq</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;m)</td></tr>
<tr class="memdesc:gab5c3b52a237ac9fd87c1e65fa5dadd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squaring the given rotation matrix.  <a href="../../da/d8d/group__dense__rotation__matrix.html#gab5c3b52a237ac9fd87c1e65fa5dadd4c"></a><br/></td></tr>
<tr class="separator:gab5c3b52a237ac9fd87c1e65fa5dadd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238061389eaa1d2a9c99ac59d6222867"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga238061389eaa1d2a9c99ac59d6222867"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga238061389eaa1d2a9c99ac59d6222867">swap</a> (<a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;a, <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; Type &gt; &amp;b)</td></tr>
<tr class="memdesc:ga238061389eaa1d2a9c99ac59d6222867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two rotation matrices.  <a href="../../da/d8d/group__dense__rotation__matrix.html#ga238061389eaa1d2a9c99ac59d6222867"></a><br/></td></tr>
<tr class="separator:ga238061389eaa1d2a9c99ac59d6222867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">RotationMatrix arithmetic operators</div></td></tr>
<tr class="memitem:ga3887661adc2b809efb2a034c57b2507f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3887661adc2b809efb2a034c57b2507f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; T1, T2 &gt;::Type, 3UL, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga3887661adc2b809efb2a034c57b2507f">operator*</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; T2, 3UL, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3887661adc2b809efb2a034c57b2507f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a rotation matrix and a vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_105.png"/>).  <a href="../../da/d8d/group__dense__rotation__matrix.html#ga3887661adc2b809efb2a034c57b2507f"></a><br/></td></tr>
<tr class="separator:ga3887661adc2b809efb2a034c57b2507f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd3b326d37315cd8f4a9feea862ddf9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3bd3b326d37315cd8f4a9feea862ddf9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; typename <br class="typebreak"/>
<a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; T1, T2 &gt;::Type, 3UL, true &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga3bd3b326d37315cd8f4a9feea862ddf9">operator*</a> (const <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html">StaticVector</a>&lt; T1, 3UL, true &gt; &amp;lhs, const RotationMatrix&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3bd3b326d37315cd8f4a9feea862ddf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a vector and a rotation matrix ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}^T*B $" src="../../form_156.png"/>).  <a href="../../da/d8d/group__dense__rotation__matrix.html#ga3bd3b326d37315cd8f4a9feea862ddf9"></a><br/></td></tr>
<tr class="separator:ga3bd3b326d37315cd8f4a9feea862ddf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d44e2335a7bf9dcb504211b48c303a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaf6d44e2335a7bf9dcb504211b48c303a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; typename <br class="typebreak"/>
<a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; T1, T2 &gt;::Type, 3UL, 3UL, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gaf6d44e2335a7bf9dcb504211b48c303a">operator*</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; T2, 3UL, 3UL, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf6d44e2335a7bf9dcb504211b48c303a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a rotation matrix and a standard matrix ( <img class="formulaInl" alt="$ A=R*B $" src="../../form_157.png"/>).  <a href="../../da/d8d/group__dense__rotation__matrix.html#gaf6d44e2335a7bf9dcb504211b48c303a"></a><br/></td></tr>
<tr class="separator:gaf6d44e2335a7bf9dcb504211b48c303a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e0c138736ed29e0b2f02afddf1dd028"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga1e0c138736ed29e0b2f02afddf1dd028"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; typename <br class="typebreak"/>
<a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; T1, T2 &gt;::Type, 3UL, 3UL, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#ga1e0c138736ed29e0b2f02afddf1dd028">operator*</a> (const <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">StaticMatrix</a>&lt; T1, 3UL, 3UL, false &gt; &amp;lhs, const RotationMatrix&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1e0c138736ed29e0b2f02afddf1dd028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a standard matrix and a rotation matrix ( <img class="formulaInl" alt="$ A=B*R $" src="../../form_158.png"/>).  <a href="../../da/d8d/group__dense__rotation__matrix.html#ga1e0c138736ed29e0b2f02afddf1dd028"></a><br/></td></tr>
<tr class="separator:ga1e0c138736ed29e0b2f02afddf1dd028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabd4a9f0ccead05f45e7ec08ba182ffa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaabd4a9f0ccead05f45e7ec08ba182ffa"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; typename <br class="typebreak"/>
<a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; T1, T2 &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d8d/group__dense__rotation__matrix.html#gaabd4a9f0ccead05f45e7ec08ba182ffa">operator*</a> (const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d11/classblaze_1_1RotationMatrix.html">RotationMatrix</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaabd4a9f0ccead05f45e7ec08ba182ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of two rotation matrices ( <img class="formulaInl" alt="$ A=B*C $" src="../../form_87.png"/>).  <a href="../../da/d8d/group__dense__rotation__matrix.html#gaabd4a9f0ccead05f45e7ec08ba182ffa"></a><br/></td></tr>
<tr class="separator:gaabd4a9f0ccead05f45e7ec08ba182ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CompressedMatrix operators</div></td></tr>
<tr class="memitem:ga629bf78114f6d95417a84ddd9af7c7ad"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga629bf78114f6d95417a84ddd9af7c7ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga629bf78114f6d95417a84ddd9af7c7ad">isnan</a> (const <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga629bf78114f6d95417a84ddd9af7c7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given sparse matrix for not-a-number elements.  <a href="../../d0/d6e/group__compressed__matrix.html#ga629bf78114f6d95417a84ddd9af7c7ad"></a><br/></td></tr>
<tr class="separator:ga629bf78114f6d95417a84ddd9af7c7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465b573a2d66a27b4da1631925aa5e38"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga465b573a2d66a27b4da1631925aa5e38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga465b573a2d66a27b4da1631925aa5e38">reset</a> (<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga465b573a2d66a27b4da1631925aa5e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given sparse matrix.  <a href="../../d0/d6e/group__compressed__matrix.html#ga465b573a2d66a27b4da1631925aa5e38"></a><br/></td></tr>
<tr class="separator:ga465b573a2d66a27b4da1631925aa5e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84bdf0c0c16cf44b87b7fccf7195d058"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga84bdf0c0c16cf44b87b7fccf7195d058"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga84bdf0c0c16cf44b87b7fccf7195d058">clear</a> (<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga84bdf0c0c16cf44b87b7fccf7195d058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given sparse matrix.  <a href="../../d0/d6e/group__compressed__matrix.html#ga84bdf0c0c16cf44b87b7fccf7195d058"></a><br/></td></tr>
<tr class="separator:ga84bdf0c0c16cf44b87b7fccf7195d058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833152f7cb061c7c6d7da2a14b6227b3"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga833152f7cb061c7c6d7da2a14b6227b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga833152f7cb061c7c6d7da2a14b6227b3">isDefault</a> (const <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga833152f7cb061c7c6d7da2a14b6227b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given sparse matrix is in default state.  <a href="../../d0/d6e/group__compressed__matrix.html#ga833152f7cb061c7c6d7da2a14b6227b3"></a><br/></td></tr>
<tr class="separator:ga833152f7cb061c7c6d7da2a14b6227b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299e9e7bae4ce361de6e1253117c52d4"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:ga299e9e7bae4ce361de6e1253117c52d4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, SO &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#ga299e9e7bae4ce361de6e1253117c52d4">inv</a> (const <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, SO &gt; &amp;m)</td></tr>
<tr class="memdesc:ga299e9e7bae4ce361de6e1253117c52d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverting the given sparse matrix.  <a href="../../d0/d6e/group__compressed__matrix.html#ga299e9e7bae4ce361de6e1253117c52d4"></a><br/></td></tr>
<tr class="separator:ga299e9e7bae4ce361de6e1253117c52d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00a06e52c3944426aa626731d3fe365"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool SO&gt; </td></tr>
<tr class="memitem:gae00a06e52c3944426aa626731d3fe365"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d6e/group__compressed__matrix.html#gae00a06e52c3944426aa626731d3fe365">swap</a> (<a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, SO &gt; &amp;a, <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">CompressedMatrix</a>&lt; Type, SO &gt; &amp;b)</td></tr>
<tr class="memdesc:gae00a06e52c3944426aa626731d3fe365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two sparse matrices.  <a href="../../d0/d6e/group__compressed__matrix.html#gae00a06e52c3944426aa626731d3fe365"></a><br/></td></tr>
<tr class="separator:gae00a06e52c3944426aa626731d3fe365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CompressedVector operators</div></td></tr>
<tr class="memitem:gac0ed24aa47bf231ae7bc5794ed3b8ff6"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:gac0ed24aa47bf231ae7bc5794ed3b8ff6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gac0ed24aa47bf231ae7bc5794ed3b8ff6">reset</a> (<a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gac0ed24aa47bf231ae7bc5794ed3b8ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given compressed vector.  <a href="../../d1/da9/group__compressed__vector.html#gac0ed24aa47bf231ae7bc5794ed3b8ff6"></a><br/></td></tr>
<tr class="separator:gac0ed24aa47bf231ae7bc5794ed3b8ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95dc88c6e4048e3de85ba165c57f89d"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:gaf95dc88c6e4048e3de85ba165c57f89d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gaf95dc88c6e4048e3de85ba165c57f89d">clear</a> (<a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gaf95dc88c6e4048e3de85ba165c57f89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given compressed vector.  <a href="../../d1/da9/group__compressed__vector.html#gaf95dc88c6e4048e3de85ba165c57f89d"></a><br/></td></tr>
<tr class="separator:gaf95dc88c6e4048e3de85ba165c57f89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77b34c1d9ae93fb946295d6d72d6580"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:gac77b34c1d9ae93fb946295d6d72d6580"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gac77b34c1d9ae93fb946295d6d72d6580">isnan</a> (const <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:gac77b34c1d9ae93fb946295d6d72d6580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given compressed vector for not-a-number elements.  <a href="../../d1/da9/group__compressed__vector.html#gac77b34c1d9ae93fb946295d6d72d6580"></a><br/></td></tr>
<tr class="separator:gac77b34c1d9ae93fb946295d6d72d6580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7822f2645f85dc043311b92711e45cfd"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:ga7822f2645f85dc043311b92711e45cfd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#ga7822f2645f85dc043311b92711e45cfd">isDefault</a> (const <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga7822f2645f85dc043311b92711e45cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given compressed vector is in default state.  <a href="../../d1/da9/group__compressed__vector.html#ga7822f2645f85dc043311b92711e45cfd"></a><br/></td></tr>
<tr class="separator:ga7822f2645f85dc043311b92711e45cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0ab138da6671dc1dabdcc04dcefac8"><td class="memTemplParams" colspan="2">template&lt;typename Type , bool TF&gt; </td></tr>
<tr class="memitem:gafd0ab138da6671dc1dabdcc04dcefac8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html#gafd0ab138da6671dc1dabdcc04dcefac8">swap</a> (<a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;a, <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html">CompressedVector</a>&lt; Type, TF &gt; &amp;b)</td></tr>
<tr class="memdesc:gafd0ab138da6671dc1dabdcc04dcefac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two compressed vectors.  <a href="../../d1/da9/group__compressed__vector.html#gafd0ab138da6671dc1dabdcc04dcefac8"></a><br/></td></tr>
<tr class="separator:gafd0ab138da6671dc1dabdcc04dcefac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseMatrix operators</div></td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5be271299bf9d21d79adbc98fefc7c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two row-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga5be271299bf9d21d79adbc98fefc7c73"></a><br/></td></tr>
<tr class="separator:ga5be271299bf9d21d79adbc98fefc7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3f69b34e146551053564a5ddba4469c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gac3f69b34e146551053564a5ddba4469c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#gac3f69b34e146551053564a5ddba4469c">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac3f69b34e146551053564a5ddba4469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two column-major sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#gac3f69b34e146551053564a5ddba4469c"></a><br/></td></tr>
<tr class="separator:gac3f69b34e146551053564a5ddba4469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga52adc17fd1c3cf58857e4bbe59d5215a">operator==</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse matrices with different storage order.  <a href="../../d0/d45/group__sparse__matrix.html#ga52adc17fd1c3cf58857e4bbe59d5215a"></a><br/></td></tr>
<tr class="separator:ga52adc17fd1c3cf58857e4bbe59d5215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23358313c28966ce20d3e636914c151f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO1, typename T2 , bool SO2&gt; </td></tr>
<tr class="memitem:ga23358313c28966ce20d3e636914c151f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d45/group__sparse__matrix.html#ga23358313c28966ce20d3e636914c151f">operator!=</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO1 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga23358313c28966ce20d3e636914c151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse matrices.  <a href="../../d0/d45/group__sparse__matrix.html#ga23358313c28966ce20d3e636914c151f"></a><br/></td></tr>
<tr class="separator:ga23358313c28966ce20d3e636914c151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseVector operators</div></td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">operator==</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse vectors.  <a href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246"></a><br/></td></tr>
<tr class="separator:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">operator!=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse vectors.  <a href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a"></a><br/></td></tr>
<tr class="separator:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SparseVector functions</div></td></tr>
<tr class="memitem:a4dfece09c8894df8c71845d072c5ef01"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:a4dfece09c8894df8c71845d072c5ef01"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a4dfece09c8894df8c71845d072c5ef01">min</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:a4dfece09c8894df8c71845d072c5ef01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the sparse vector.  <a href="#a4dfece09c8894df8c71845d072c5ef01"></a><br/></td></tr>
<tr class="separator:a4dfece09c8894df8c71845d072c5ef01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5abd27e95a034535519cb8d7cf77b96"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:af5abd27e95a034535519cb8d7cf77b96"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#af5abd27e95a034535519cb8d7cf77b96">max</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:af5abd27e95a034535519cb8d7cf77b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the sparse vector.  <a href="#af5abd27e95a034535519cb8d7cf77b96"></a><br/></td></tr>
<tr class="separator:af5abd27e95a034535519cb8d7cf77b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector operators</div></td></tr>
<tr class="memitem:ga02eed53e687af8b9ca0a7f422e14251d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga02eed53e687af8b9ca0a7f422e14251d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga02eed53e687af8b9ca0a7f422e14251d">operator,</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga02eed53e687af8b9ca0a7f422e14251d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_163.png"/>).  <a href="../../dc/dcf/group__vector.html#ga02eed53e687af8b9ca0a7f422e14251d"></a><br/></td></tr>
<tr class="separator:ga02eed53e687af8b9ca0a7f422e14251d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac25a7ec004d75dcd6f35c9d7c4038d2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaac25a7ec004d75dcd6f35c9d7c4038d2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#gaac25a7ec004d75dcd6f35c9d7c4038d2">operator,</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaac25a7ec004d75dcd6f35c9d7c4038d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_163.png"/>).  <a href="../../dc/dcf/group__vector.html#gaac25a7ec004d75dcd6f35c9d7c4038d2"></a><br/></td></tr>
<tr class="separator:gaac25a7ec004d75dcd6f35c9d7c4038d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd49ce92ac0399834b5cb38d7d7fea5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4cd49ce92ac0399834b5cb38d7d7fea5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga4cd49ce92ac0399834b5cb38d7d7fea5">operator,</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4cd49ce92ac0399834b5cb38d7d7fea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_163.png"/>).  <a href="../../dc/dcf/group__vector.html#ga4cd49ce92ac0399834b5cb38d7d7fea5"></a><br/></td></tr>
<tr class="separator:ga4cd49ce92ac0399834b5cb38d7d7fea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256b989ad961bb5f67ccdaf5ce02ba80"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga256b989ad961bb5f67ccdaf5ce02ba80"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">MultTrait</a>&lt; typename <br class="typebreak"/>
T1::ElementType, typename <br class="typebreak"/>
T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga256b989ad961bb5f67ccdaf5ce02ba80">operator,</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T1, true &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; T2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga256b989ad961bb5f67ccdaf5ce02ba80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two vectors ( <img class="formulaInl" alt="$ s=(\vec{a},\vec{b}) $" src="../../form_163.png"/>).  <a href="../../dc/dcf/group__vector.html#ga256b989ad961bb5f67ccdaf5ce02ba80"></a><br/></td></tr>
<tr class="separator:ga256b989ad961bb5f67ccdaf5ce02ba80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459ba08d52dd8ace7955cd1be814da30"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga459ba08d52dd8ace7955cd1be814da30"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html#ga459ba08d52dd8ace7955cd1be814da30">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:ga459ba08d52dd8ace7955cd1be814da30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for dense and sparse vectors.  <a href="../../dc/dcf/group__vector.html#ga459ba08d52dd8ace7955cd1be814da30"></a><br/></td></tr>
<tr class="separator:ga459ba08d52dd8ace7955cd1be814da30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">InputString operators</div></td></tr>
<tr class="memitem:ga942b82bb3e222d3e7651094a372cabd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga942b82bb3e222d3e7651094a372cabd6">IsFileName</a> (const <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;s)</td></tr>
<tr class="memdesc:ga942b82bb3e222d3e7651094a372cabd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for a valid file name.  <a href="../../d4/d3a/group__util.html#ga942b82bb3e222d3e7651094a372cabd6"></a><br/></td></tr>
<tr class="separator:ga942b82bb3e222d3e7651094a372cabd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaa1ba7ee1b13541bf5bef5cb2eaf66207">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;str)</td></tr>
<tr class="memdesc:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class.  <a href="../../d4/d3a/group__util.html#gaa1ba7ee1b13541bf5bef5cb2eaf66207"></a><br/></td></tr>
<tr class="separator:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga80a4395873ec4d104b68f12f5e9dc29f">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../da/dfc/classblaze_1_1InputString.html">InputString</a> &amp;str)</td></tr>
<tr class="memdesc:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global input operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class.  <a href="../../d4/d3a/group__util.html#ga80a4395873ec4d104b68f12f5e9dc29f"></a><br/></td></tr>
<tr class="separator:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Null operators</div></td></tr>
<tr class="memitem:ae4e1826114c844141dbae5b4c0b7cdd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4e1826114c844141dbae5b4c0b7cdd3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ae4e1826114c844141dbae5b4c0b7cdd3">operator==</a> (const <a class="el" href="../../dd/d82/classblaze_1_1Null.html">Null</a> &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ae4e1826114c844141dbae5b4c0b7cdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a> and a pointer or pointer-to-member.  <a href="#ae4e1826114c844141dbae5b4c0b7cdd3"></a><br/></td></tr>
<tr class="separator:ae4e1826114c844141dbae5b4c0b7cdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239cf16a0f5fdbc42bfefe5641681fb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a239cf16a0f5fdbc42bfefe5641681fb6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a239cf16a0f5fdbc42bfefe5641681fb6">operator==</a> (const T &amp;lhs, const <a class="el" href="../../dd/d82/classblaze_1_1Null.html">Null</a> &amp;rhs)</td></tr>
<tr class="memdesc:a239cf16a0f5fdbc42bfefe5641681fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a pointer or pointer-to-member and <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a>.  <a href="#a239cf16a0f5fdbc42bfefe5641681fb6"></a><br/></td></tr>
<tr class="separator:a239cf16a0f5fdbc42bfefe5641681fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b4bc2f9d06fe63f94e6cb86944625e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84b4bc2f9d06fe63f94e6cb86944625e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a84b4bc2f9d06fe63f94e6cb86944625e">operator!=</a> (const <a class="el" href="../../dd/d82/classblaze_1_1Null.html">Null</a> &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:a84b4bc2f9d06fe63f94e6cb86944625e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a> and a pointer or pointer-to-member.  <a href="#a84b4bc2f9d06fe63f94e6cb86944625e"></a><br/></td></tr>
<tr class="separator:a84b4bc2f9d06fe63f94e6cb86944625e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9ed8d5afaf89d17a59c687d3babf8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a9ed8d5afaf89d17a59c687d3babf8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a6a9ed8d5afaf89d17a59c687d3babf8a">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../dd/d82/classblaze_1_1Null.html">Null</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6a9ed8d5afaf89d17a59c687d3babf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a pointer or pointer-to-member and <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a>.  <a href="#a6a9ed8d5afaf89d17a59c687d3babf8a"></a><br/></td></tr>
<tr class="separator:a6a9ed8d5afaf89d17a59c687d3babf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pointer cast operators</div></td></tr>
<tr class="memitem:ga297b8d4addf0242658e5b89e9204460f"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga297b8d4addf0242658e5b89e9204460f"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f">static_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga297b8d4addf0242658e5b89e9204460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f"></a><br/></td></tr>
<tr class="separator:ga297b8d4addf0242658e5b89e9204460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5e788ec214cce869014db4e8d5366e"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga6f5e788ec214cce869014db4e8d5366e"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e">dynamic_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga6f5e788ec214cce869014db4e8d5366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e"></a><br/></td></tr>
<tr class="separator:ga6f5e788ec214cce869014db4e8d5366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28219d814bac7718746d5042aef9de09"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga28219d814bac7718746d5042aef9de09"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09">const_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga28219d814bac7718746d5042aef9de09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09"></a><br/></td></tr>
<tr class="separator:ga28219d814bac7718746d5042aef9de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4">reinterpret_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret cast for pointer types.  <a href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4"></a><br/></td></tr>
<tr class="separator:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Smart pointer cast operators</div></td></tr>
<tr class="memitem:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga70575290b13daca96bd7bcdf1ea2ae65">static_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga70575290b13daca96bd7bcdf1ea2ae65"></a><br/></td></tr>
<tr class="separator:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga29989fd5881d9e3d3204be7cc9c7c3db">dynamic_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga29989fd5881d9e3d3204be7cc9c7c3db"></a><br/></td></tr>
<tr class="separator:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618bf0481250b859a7d953d54a31fffa"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga618bf0481250b859a7d953d54a31fffa"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga618bf0481250b859a7d953d54a31fffa">const_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga618bf0481250b859a7d953d54a31fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga618bf0481250b859a7d953d54a31fffa"></a><br/></td></tr>
<tr class="separator:ga618bf0481250b859a7d953d54a31fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e5a317853deb66bcd03883873f20ee"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga29e5a317853deb66bcd03883873f20ee"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga29e5a317853deb66bcd03883873f20ee">reinterpret_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga29e5a317853deb66bcd03883873f20ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret cast for smart pointers.  <a href="../../d4/d3a/group__util.html#ga29e5a317853deb66bcd03883873f20ee"></a><br/></td></tr>
<tr class="separator:ga29e5a317853deb66bcd03883873f20ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PtrIterator operators</div></td></tr>
<tr class="memitem:a83125315ff1fc56974b1525cd6d9c4cf"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:a83125315ff1fc56974b1525cd6d9c4cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a83125315ff1fc56974b1525cd6d9c4cf">operator==</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a83125315ff1fc56974b1525cd6d9c4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#a83125315ff1fc56974b1525cd6d9c4cf"></a><br/></td></tr>
<tr class="separator:a83125315ff1fc56974b1525cd6d9c4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8a3e3b7fb672689907927512c04839"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:aac8a3e3b7fb672689907927512c04839"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aac8a3e3b7fb672689907927512c04839">operator!=</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aac8a3e3b7fb672689907927512c04839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#aac8a3e3b7fb672689907927512c04839"></a><br/></td></tr>
<tr class="separator:aac8a3e3b7fb672689907927512c04839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf608ae97f0284e56745139e110ea699"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:aaf608ae97f0284e56745139e110ea699"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#aaf608ae97f0284e56745139e110ea699">operator&lt;</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaf608ae97f0284e56745139e110ea699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#aaf608ae97f0284e56745139e110ea699"></a><br/></td></tr>
<tr class="separator:aaf608ae97f0284e56745139e110ea699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378bc920e7d0cfddbe90600e14f358c4"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:a378bc920e7d0cfddbe90600e14f358c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a378bc920e7d0cfddbe90600e14f358c4">operator&gt;</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a378bc920e7d0cfddbe90600e14f358c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#a378bc920e7d0cfddbe90600e14f358c4"></a><br/></td></tr>
<tr class="separator:a378bc920e7d0cfddbe90600e14f358c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7399c56304153ea6b9068cbe00d41085"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:a7399c56304153ea6b9068cbe00d41085"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a7399c56304153ea6b9068cbe00d41085">operator&lt;=</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7399c56304153ea6b9068cbe00d41085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#a7399c56304153ea6b9068cbe00d41085"></a><br/></td></tr>
<tr class="separator:a7399c56304153ea6b9068cbe00d41085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c6bd436ad385878f4c70a9b9ee5dd5"><td class="memTemplParams" colspan="2">template&lt;typename TypeL , typename TypeR &gt; </td></tr>
<tr class="memitem:ad4c6bd436ad385878f4c70a9b9ee5dd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad4c6bd436ad385878f4c70a9b9ee5dd5">operator&gt;=</a> (const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeL &gt; &amp;lhs, const <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">PtrIterator</a>&lt; TypeR &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad4c6bd436ad385878f4c70a9b9ee5dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects.  <a href="#ad4c6bd436ad385878f4c70a9b9ee5dd5"></a><br/></td></tr>
<tr class="separator:ad4c6bd436ad385878f4c70a9b9ee5dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PtrVector operators</div></td></tr>
<tr class="memitem:a4bd2908dd4b8aae738fcb0aa21d494af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename D , typename G &gt; </td></tr>
<tr class="memitem:a4bd2908dd4b8aae738fcb0aa21d494af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a4bd2908dd4b8aae738fcb0aa21d494af">operator==</a> (const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;lhs, const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4bd2908dd4b8aae738fcb0aa21d494af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two pointer vectors.  <a href="#a4bd2908dd4b8aae738fcb0aa21d494af"></a><br/></td></tr>
<tr class="separator:a4bd2908dd4b8aae738fcb0aa21d494af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c24212630a6f1d6597740647e3413eb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename D , typename G &gt; </td></tr>
<tr class="memitem:a9c24212630a6f1d6597740647e3413eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a9c24212630a6f1d6597740647e3413eb">operator!=</a> (const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;lhs, const <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9c24212630a6f1d6597740647e3413eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two pointer vectors.  <a href="#a9c24212630a6f1d6597740647e3413eb"></a><br/></td></tr>
<tr class="separator:a9c24212630a6f1d6597740647e3413eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5dc51e7401cfb7b7f62e2a08faf2b4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename D , typename G &gt; </td></tr>
<tr class="memitem:a1b5dc51e7401cfb7b7f62e2a08faf2b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a1b5dc51e7401cfb7b7f62e2a08faf2b4">swap</a> (<a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;a, <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; T, D, G &gt; &amp;b)</td></tr>
<tr class="memdesc:a1b5dc51e7401cfb7b7f62e2a08faf2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two pointer vectors.  <a href="#a1b5dc51e7401cfb7b7f62e2a08faf2b4"></a><br/></td></tr>
<tr class="separator:a1b5dc51e7401cfb7b7f62e2a08faf2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random number functions</div></td></tr>
<tr class="memitem:ga0d06d962406a7a4a2414899bea18f3e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0d06d962406a7a4a2414899bea18f3e4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#ga0d06d962406a7a4a2414899bea18f3e4">rand</a> ()</td></tr>
<tr class="memdesc:ga0d06d962406a7a4a2414899bea18f3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number function.  <a href="../../dd/d10/group__random.html#ga0d06d962406a7a4a2414899bea18f3e4"></a><br/></td></tr>
<tr class="separator:ga0d06d962406a7a4a2414899bea18f3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga417de203b222069c1a54f9a30ed38e59"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A1 &gt; </td></tr>
<tr class="memitem:ga417de203b222069c1a54f9a30ed38e59"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#ga417de203b222069c1a54f9a30ed38e59">rand</a> (const A1 &amp;a1)</td></tr>
<tr class="memdesc:ga417de203b222069c1a54f9a30ed38e59"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number function.  <a href="../../dd/d10/group__random.html#ga417de203b222069c1a54f9a30ed38e59"></a><br/></td></tr>
<tr class="separator:ga417de203b222069c1a54f9a30ed38e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38a51571b7b83c350e86ed1b12f857ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga38a51571b7b83c350e86ed1b12f857ce"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#ga38a51571b7b83c350e86ed1b12f857ce">rand</a> (const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr class="memdesc:ga38a51571b7b83c350e86ed1b12f857ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number function.  <a href="../../dd/d10/group__random.html#ga38a51571b7b83c350e86ed1b12f857ce"></a><br/></td></tr>
<tr class="separator:ga38a51571b7b83c350e86ed1b12f857ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0617384a95ec153901c7c87c943032"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gaef0617384a95ec153901c7c87c943032"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#gaef0617384a95ec153901c7c87c943032">rand</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr class="memdesc:gaef0617384a95ec153901c7c87c943032"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number function.  <a href="../../dd/d10/group__random.html#gaef0617384a95ec153901c7c87c943032"></a><br/></td></tr>
<tr class="separator:gaef0617384a95ec153901c7c87c943032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71d8a368fb0762a3de6bcaf8f87b15a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:gad71d8a368fb0762a3de6bcaf8f87b15a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#gad71d8a368fb0762a3de6bcaf8f87b15a">rand</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr class="memdesc:gad71d8a368fb0762a3de6bcaf8f87b15a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number function.  <a href="../../dd/d10/group__random.html#gad71d8a368fb0762a3de6bcaf8f87b15a"></a><br/></td></tr>
<tr class="separator:gad71d8a368fb0762a3de6bcaf8f87b15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa62dad148267b178aaecdb9ed4583c4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 &gt; </td></tr>
<tr class="memitem:gafa62dad148267b178aaecdb9ed4583c4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#gafa62dad148267b178aaecdb9ed4583c4">rand</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr class="memdesc:gafa62dad148267b178aaecdb9ed4583c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/dc4/classblaze_1_1Random.html" title="Random number generator.The Random class encapsulates the initialization of the given random number g...">Random</a> number function.  <a href="../../dd/d10/group__random.html#gafa62dad148267b178aaecdb9ed4583c4"></a><br/></td></tr>
<tr class="separator:gafa62dad148267b178aaecdb9ed4583c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75f5d7517c2c6367e7432fe42e888c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#gab75f5d7517c2c6367e7432fe42e888c6">getSeed</a> ()</td></tr>
<tr class="memdesc:gab75f5d7517c2c6367e7432fe42e888c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current seed of the random number generator.  <a href="../../dd/d10/group__random.html#gab75f5d7517c2c6367e7432fe42e888c6"></a><br/></td></tr>
<tr class="separator:gab75f5d7517c2c6367e7432fe42e888c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab75d4f60ec07ee3a9681a437395afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html#ga2ab75d4f60ec07ee3a9681a437395afc">setSeed</a> (<a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">uint32_t</a> seed)</td></tr>
<tr class="memdesc:ga2ab75d4f60ec07ee3a9681a437395afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the seed of the random number generator.  <a href="../../dd/d10/group__random.html#ga2ab75d4f60ec07ee3a9681a437395afc"></a><br/></td></tr>
<tr class="separator:ga2ab75d4f60ec07ee3a9681a437395afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">System clock setup functions</div></td></tr>
<tr class="memitem:ga0547f7041f58ea87ba920e520236bd12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d3a/group__util.html#ga5f70ec9de722c70928b8b85cb3613a9d">SystemClockID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga0547f7041f58ea87ba920e520236bd12">theSystemClock</a> ()</td></tr>
<tr class="memdesc:ga0547f7041f58ea87ba920e520236bd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the Blaze system clock.  <a href="../../d4/d3a/group__util.html#ga0547f7041f58ea87ba920e520236bd12"></a><br/></td></tr>
<tr class="separator:ga0547f7041f58ea87ba920e520236bd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Time functions</div></td></tr>
<tr class="memitem:ga4fb888631070076eac5ab46d3caddbd5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga4fb888631070076eac5ab46d3caddbd5">getDate</a> ()</td></tr>
<tr class="memdesc:ga4fb888631070076eac5ab46d3caddbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a formated date string in the form YYYY-MM-DD.  <a href="../../d4/d3a/group__util.html#ga4fb888631070076eac5ab46d3caddbd5"></a><br/></td></tr>
<tr class="separator:ga4fb888631070076eac5ab46d3caddbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3829412570c98a06a4bc95c550da95d8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3829412570c98a06a4bc95c550da95d8">getTime</a> ()</td></tr>
<tr class="memdesc:ga3829412570c98a06a4bc95c550da95d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a formated time and date string.  <a href="../../d4/d3a/group__util.html#ga3829412570c98a06a4bc95c550da95d8"></a><br/></td></tr>
<tr class="separator:ga3829412570c98a06a4bc95c550da95d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d046bc597081ad84f727946f245a800"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2d046bc597081ad84f727946f245a800">getWcTime</a> ()</td></tr>
<tr class="memdesc:ga2d046bc597081ad84f727946f245a800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current wall clock time in seconds.  <a href="../../d4/d3a/group__util.html#ga2d046bc597081ad84f727946f245a800"></a><br/></td></tr>
<tr class="separator:ga2d046bc597081ad84f727946f245a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2ff2b8c34d2384faa6b3e97954b98e78">getCpuTime</a> ()</td></tr>
<tr class="memdesc:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current CPU time in seconds.  <a href="../../d4/d3a/group__util.html#ga2ff2b8c34d2384faa6b3e97954b98e78"></a><br/></td></tr>
<tr class="separator:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UnsignedValue operators</div></td></tr>
<tr class="memitem:af275fc8373d91ea8aff2b0b8e8dd3e89"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af275fc8373d91ea8aff2b0b8e8dd3e89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#af275fc8373d91ea8aff2b0b8e8dd3e89">operator==</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af275fc8373d91ea8aff2b0b8e8dd3e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#af275fc8373d91ea8aff2b0b8e8dd3e89"></a><br/></td></tr>
<tr class="separator:af275fc8373d91ea8aff2b0b8e8dd3e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b94802b1621abe72010aa92b1c323a3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0b94802b1621abe72010aa92b1c323a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a0b94802b1621abe72010aa92b1c323a3">operator!=</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0b94802b1621abe72010aa92b1c323a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#a0b94802b1621abe72010aa92b1c323a3"></a><br/></td></tr>
<tr class="separator:a0b94802b1621abe72010aa92b1c323a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b6ccf3e72a2176b217b977c8e0981"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad17b6ccf3e72a2176b217b977c8e0981"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#ad17b6ccf3e72a2176b217b977c8e0981">operator&lt;</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad17b6ccf3e72a2176b217b977c8e0981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#ad17b6ccf3e72a2176b217b977c8e0981"></a><br/></td></tr>
<tr class="separator:ad17b6ccf3e72a2176b217b977c8e0981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4918d3c24509bf7651948a10524dbdb9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a4918d3c24509bf7651948a10524dbdb9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a4918d3c24509bf7651948a10524dbdb9">operator&gt;</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4918d3c24509bf7651948a10524dbdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#a4918d3c24509bf7651948a10524dbdb9"></a><br/></td></tr>
<tr class="separator:a4918d3c24509bf7651948a10524dbdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602483ca8c570c315b235511663102eb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a602483ca8c570c315b235511663102eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a602483ca8c570c315b235511663102eb">operator&lt;=</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a602483ca8c570c315b235511663102eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#a602483ca8c570c315b235511663102eb"></a><br/></td></tr>
<tr class="separator:a602483ca8c570c315b235511663102eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73335dc2737714119ab3747f7d4d48b0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a73335dc2737714119ab3747f7d4d48b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a73335dc2737714119ab3747f7d4d48b0">operator&gt;=</a> (const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a73335dc2737714119ab3747f7d4d48b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects.  <a href="#a73335dc2737714119ab3747f7d4d48b0"></a><br/></td></tr>
<tr class="separator:a73335dc2737714119ab3747f7d4d48b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d629135d4db89e1fcdcfd4b8f7c347e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d629135d4db89e1fcdcfd4b8f7c347e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a8d629135d4db89e1fcdcfd4b8f7c347e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T &gt; &amp;uv)</td></tr>
<tr class="memdesc:a8d629135d4db89e1fcdcfd4b8f7c347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper.  <a href="#a8d629135d4db89e1fcdcfd4b8f7c347e"></a><br/></td></tr>
<tr class="separator:a8d629135d4db89e1fcdcfd4b8f7c347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc275ea3ab616899091b50d46fc6e1a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc275ea3ab616899091b50d46fc6e1a3"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#afc275ea3ab616899091b50d46fc6e1a3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">UnsignedValue</a>&lt; T &gt; &amp;uv)</td></tr>
<tr class="memdesc:afc275ea3ab616899091b50d46fc6e1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global input operator for the <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper.  <a href="#afc275ea3ab616899091b50d46fc6e1a3"></a><br/></td></tr>
<tr class="separator:afc275ea3ab616899091b50d46fc6e1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga16a10f2e90248f3cfc8ecc4b131a304f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga16a10f2e90248f3cfc8ecc4b131a304f">cacheSize</a> = 6291456UL</td></tr>
<tr class="memdesc:ga16a10f2e90248f3cfc8ecc4b131a304f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache size of the target architecture.This setting specifies the available cache size in Byte of the used target architecture. Several algorithms use this setting for an optimized evaluation.  <a href="../../d1/d44/group__config.html#ga16a10f2e90248f3cfc8ecc4b131a304f"></a><br/></td></tr>
<tr class="separator:ga16a10f2e90248f3cfc8ecc4b131a304f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c5b7330d511e76f9c20327f3279483"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gab4c5b7330d511e76f9c20327f3279483">defaultStorageOrder</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a></td></tr>
<tr class="memdesc:gab4c5b7330d511e76f9c20327f3279483"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default storage order for all matrices of the Blaze library.This value specifies the default storage order for all matrices of the Blaze library. In case no explicit storage order is specified with the according matrix type, this setting is used.  <a href="../../d1/d44/group__config.html#gab4c5b7330d511e76f9c20327f3279483"></a><br/></td></tr>
<tr class="separator:gab4c5b7330d511e76f9c20327f3279483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34deeb69f8938cd5512d0bd957b57387"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga34deeb69f8938cd5512d0bd957b57387">DMATDVECMULT_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:ga34deeb69f8938cd5512d0bd957b57387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/dense vector multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/dense vector multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are prefered over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#ga34deeb69f8938cd5512d0bd957b57387"></a><br/></td></tr>
<tr class="separator:ga34deeb69f8938cd5512d0bd957b57387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78c3f886bc03af4064a137c92be7ef3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gac78c3f886bc03af4064a137c92be7ef3">TDMATDVECMULT_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:gac78c3f886bc03af4064a137c92be7ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/dense vector multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/dense vector multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are prefered over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#gac78c3f886bc03af4064a137c92be7ef3"></a><br/></td></tr>
<tr class="separator:gac78c3f886bc03af4064a137c92be7ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd20b299f51fb2fe605e077cc81d1128"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gacd20b299f51fb2fe605e077cc81d1128">TDVECDMATMULT_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:gacd20b299f51fb2fe605e077cc81d1128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense Vector/row-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the dense vector/row-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are prefered over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#gacd20b299f51fb2fe605e077cc81d1128"></a><br/></td></tr>
<tr class="separator:gacd20b299f51fb2fe605e077cc81d1128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ceb843ac8627379630489483a89f41"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaf6ceb843ac8627379630489483a89f41">TDVECTDMATMULT_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:gaf6ceb843ac8627379630489483a89f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense Vector/column-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the dense vector/column-major dense matrix multiplication. In case the number of elements in the dense matrix is equal or higher than this value, the BLAS kernels are prefered over the custom Blaze kernels. In case the number of elements in the dense matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#gaf6ceb843ac8627379630489483a89f41"></a><br/></td></tr>
<tr class="separator:gaf6ceb843ac8627379630489483a89f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c057dfdd2e4ed7b2d1bb8bb1fab3f67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga9c057dfdd2e4ed7b2d1bb8bb1fab3f67">DMATDMATMULT_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:ga9c057dfdd2e4ed7b2d1bb8bb1fab3f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/row-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/row-major dense matrix multiplication. In case the number of elements of the target matrix is equal or higher than this value, the BLAS kernels are prefered over the custom Blaze kernels. In case the number of elements in the target matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#ga9c057dfdd2e4ed7b2d1bb8bb1fab3f67"></a><br/></td></tr>
<tr class="separator:ga9c057dfdd2e4ed7b2d1bb8bb1fab3f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4f6709c0385a808a44b911084873b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga1d4f6709c0385a808a44b911084873b2">DMATTDMATMULT_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:ga1d4f6709c0385a808a44b911084873b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major dense matrix/column-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the row-major dense matrix/column-major dense matrix multiplication. In case the number of elements of the target matrix is equal or higher than this value, the BLAS kernels are prefered over the custom Blaze kernels. In case the number of elements in the target matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#ga1d4f6709c0385a808a44b911084873b2"></a><br/></td></tr>
<tr class="separator:ga1d4f6709c0385a808a44b911084873b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee15bd03c6f968e4f12f8ef303b3924f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gaee15bd03c6f968e4f12f8ef303b3924f">TDMATDMATMULT_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:gaee15bd03c6f968e4f12f8ef303b3924f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/row-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/row-major dense matrix multiplication. In case the number of elements of the target matrix is equal or higher than this value, the BLAS kernels are prefered over the custom Blaze kernels. In case the number of elements in the target matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#gaee15bd03c6f968e4f12f8ef303b3924f"></a><br/></td></tr>
<tr class="separator:gaee15bd03c6f968e4f12f8ef303b3924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da823a2e974ab500fd5b485cd3c7734"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#ga6da823a2e974ab500fd5b485cd3c7734">TDMATTDMATMULT_THRESHOLD</a> = 10000UL</td></tr>
<tr class="memdesc:ga6da823a2e974ab500fd5b485cd3c7734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column-major dense matrix/column-major dense matrix multiplication threshold.This setting specifies the threshold between the application of the custom Blaze kernels and the BLAS kernels for the column-major dense matrix/column-major dense matrix multiplication. In case the number of elements of the target matrix is equal or higher than this value, the BLAS kernels are prefered over the custom Blaze kernels. In case the number of elements in the target matrix is smaller, the Blaze kernels are used.  <a href="../../d1/d44/group__config.html#ga6da823a2e974ab500fd5b485cd3c7734"></a><br/></td></tr>
<tr class="separator:ga6da823a2e974ab500fd5b485cd3c7734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc21778299e5c18d8e93e0d9254300e"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d44/group__config.html#gafcc21778299e5c18d8e93e0d9254300e">defaultTransposeFlag</a> = <a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">columnVector</a></td></tr>
<tr class="memdesc:gafcc21778299e5c18d8e93e0d9254300e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default transpose flag for all vectors of the Blaze library.This value specifies the default transpose flag for all vector of the Blaze library. In case no explicit transpose flag is specified with the according vector type, this setting is used.  <a href="../../d1/d44/group__config.html#gafcc21778299e5c18d8e93e0d9254300e"></a><br/></td></tr>
<tr class="separator:gafcc21778299e5c18d8e93e0d9254300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga625b0b7ac3b908bc3266c6d834630806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga625b0b7ac3b908bc3266c6d834630806"></a>
const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806">accuracy</a></td></tr>
<tr class="memdesc:ga625b0b7ac3b908bc3266c6d834630806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the computation accuracy of the Blaze library for the according data type. <br/></td></tr>
<tr class="separator:ga625b0b7ac3b908bc3266c6d834630806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2f6a797255a44b04f704ff548385d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec2f6a797255a44b04f704ff548385d4"></a>
const <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaec2f6a797255a44b04f704ff548385d4">M_E</a> = 2.7182818284590452353602874713526625</td></tr>
<tr class="memdesc:gaec2f6a797255a44b04f704ff548385d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ e $" src="../../form_10.png"/>. <br/></td></tr>
<tr class="separator:gaec2f6a797255a44b04f704ff548385d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf858edb18cdfb5695345c47879be3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bf858edb18cdfb5695345c47879be3f"></a>
const <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6bf858edb18cdfb5695345c47879be3f">M_LOG2E</a> = 1.4426950408889634073599246810018921</td></tr>
<tr class="memdesc:ga6bf858edb18cdfb5695345c47879be3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \log_2 e $" src="../../form_11.png"/>. <br/></td></tr>
<tr class="separator:ga6bf858edb18cdfb5695345c47879be3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0ee7da2d612ffe0d0837a63ed9f4bff"></a>
const <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf0ee7da2d612ffe0d0837a63ed9f4bff">M_LOG10E</a> = 0.4342944819032518276511289189166051</td></tr>
<tr class="memdesc:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \log_{10} e $" src="../../form_12.png"/>. <br/></td></tr>
<tr class="separator:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1502d2dcd380b1eb5e56ffd898ceb5ca"></a>
const <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1502d2dcd380b1eb5e56ffd898ceb5ca">M_LN2</a> = 0.6931471805599453094172321214581766</td></tr>
<tr class="memdesc:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \ln 2 $" src="../../form_13.png"/>. <br/></td></tr>
<tr class="separator:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b89d4af29804852eb0830a1481e9801"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9b89d4af29804852eb0830a1481e9801"></a>
const <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b89d4af29804852eb0830a1481e9801">M_LN10</a> = 2.3025850929940456840179914546843642</td></tr>
<tr class="memdesc:ga9b89d4af29804852eb0830a1481e9801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \ln 10 $" src="../../form_14.png"/>. <br/></td></tr>
<tr class="separator:ga9b89d4af29804852eb0830a1481e9801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2600098236fe85a4d5e79e4d9de26318"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2600098236fe85a4d5e79e4d9de26318"></a>
const <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2600098236fe85a4d5e79e4d9de26318">M_PI</a> = 3.1415926535897932384626433832795029</td></tr>
<tr class="memdesc:ga2600098236fe85a4d5e79e4d9de26318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \pi $" src="../../form_15.png"/>. <br/></td></tr>
<tr class="separator:ga2600098236fe85a4d5e79e4d9de26318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56db875675fe79ee8b7685673eb5c02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad56db875675fe79ee8b7685673eb5c02"></a>
const <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad56db875675fe79ee8b7685673eb5c02">M_SQRT2</a> = 1.4142135623730950488016887242096981</td></tr>
<tr class="memdesc:gad56db875675fe79ee8b7685673eb5c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \sqrt{2} $" src="../../form_16.png"/>. <br/></td></tr>
<tr class="separator:gad56db875675fe79ee8b7685673eb5c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b83fd428d08d322190fb8d09fb72eaf"></a>
const <a class="el" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6b83fd428d08d322190fb8d09fb72eaf">M_SQRT3</a> = 1.7320508075688772935274463415058724</td></tr>
<tr class="memdesc:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \sqrt{3} $" src="../../form_17.png"/>. <br/></td></tr>
<tr class="separator:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a02d7d60cd864ce158adb1cdf17989c"></a>
const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c">epsilon</a></td></tr>
<tr class="memdesc:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the smallest possible difference between two values of the according data type. <br/></td></tr>
<tr class="separator:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97926ed3b4199bea5635290031cfe38f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97926ed3b4199bea5635290031cfe38f"></a>
const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga97926ed3b4199bea5635290031cfe38f">inf</a></td></tr>
<tr class="memdesc:ga97926ed3b4199bea5635290031cfe38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga97926ed3b4199bea5635290031cfe38f" title="Global Infinity instance.The blaze::inf instance can be used wherever a built-in data type is expecte...">blaze::inf</a> instance can be used wherever a built-in data type is expected. It is implicitly converted to the corresponding built-in data type and represents its largest possible data value. <br/></td></tr>
<tr class="separator:ga97926ed3b4199bea5635290031cfe38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511878ce70095271b6d0dd5b855a9eaa"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">rowMajor</a> = false</td></tr>
<tr class="memdesc:a511878ce70095271b6d0dd5b855a9eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage order flag for row-major matrices.  <a href="#a511878ce70095271b6d0dd5b855a9eaa"></a><br/></td></tr>
<tr class="separator:a511878ce70095271b6d0dd5b855a9eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e42e1508f7d4d364fe7c64eef78a583"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">columnMajor</a> = true</td></tr>
<tr class="memdesc:a5e42e1508f7d4d364fe7c64eef78a583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage order flag for column-major matrices.  <a href="#a5e42e1508f7d4d364fe7c64eef78a583"></a><br/></td></tr>
<tr class="separator:a5e42e1508f7d4d364fe7c64eef78a583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee466faebcaba59afde0fbfe22041aa"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">columnVector</a> = false</td></tr>
<tr class="memdesc:acee466faebcaba59afde0fbfe22041aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose flag for column vectors.  <a href="#acee466faebcaba59afde0fbfe22041aa"></a><br/></td></tr>
<tr class="separator:acee466faebcaba59afde0fbfe22041aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006b6328815f2632d2c5ab8b869c5cf0"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">rowVector</a> = true</td></tr>
<tr class="memdesc:a006b6328815f2632d2c5ab8b869c5cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose flag for row vectors.  <a href="#a006b6328815f2632d2c5ab8b869c5cf0"></a><br/></td></tr>
<tr class="separator:a006b6328815f2632d2c5ab8b869c5cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace of the Blaze C++ math library. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7a981a1908b189351a35e8285d50a8db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* blaze::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned array allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements of the given type to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of the aligned array.</dd></dl>
<p>The allocate function provides the functionality to allocate memory based on the alignment restrictions of the given data type. In case the given type is a fundamental, built-in data type and in case SSE vectorization is possible, the returned memory is guaranteed to be at least 16-byte aligned. In case AVX in active, the memory is even guaranteed to be 32-byte aligned. For all other, non-builtin data types, the system-specific alignment strategy is used.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><span class="comment">// Guaranteed to be 16-byte aligned (32-byte aligned in case AVX is used)</span></div>
<div class="line"><span class="keywordtype">double</span>* dp = allocate&lt;double&gt;( 10UL );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abb5f8ac862261819dde5428784642893"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">DynamicVector&lt; Type, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the given dynamic vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The dynamic vector to be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a49baf1c557f47c3c776efc675d2fc9f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To blaze::convert </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion from type <em>From</em> to type <em>To</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The data value to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted data value.</dd></dl>
<p>The <em>convert</em> function transforms the data value <em>from</em> of type <em>From</em> to the data type <em>To</em>. The syntax for this operation is similar to the C++ cast operators. For example, in order to convert a built-in integer value <code>integer</code> to a <em>std::string</em>, use</p>
<div class="fragment"><div class="line">convert&lt;std::string&gt;( integer ) </div>
</div><!-- fragment --><p>The <em>convert</em> function supports any possible type conversion in the most efficient way. </p>

</div>
</div>
<a class="anchor" id="ac71ae9c3bdbe361debf5c37df7f4327c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void blaze::deallocate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocation of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the first element of the array to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aeef79474bdecfb65923e504b5fe40843"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const DynamicVector&lt; Type, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given dynamic vector is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The dynamic vector to be tested for its default state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the given vector is component-wise zero, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the N-dimensional vector is in default state. For instance, in case the vector is instantiated for a built-in integral or floating point data type, the function returns <em>true</em> in case all vector elements are 0 and <em>false</em> in case any vector element is not 0. The following example demonstrates the use of the <em>isDefault</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;int&gt;</a> a;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../dd/dfc/group__dynamic__matrix.html#gad21449e9057f62feff3d74ef13064366" title="Returns whether the given dense matrix is in default state.">isDefault</a>( a ) ) { ... }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4a7390e875bf1db2385207fe64e230e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const DynamicVector&lt; Type, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the given dynamic vector for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the N-dimensional dynamic vector for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> at least one element of the vector is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::VecN</a> a;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../dd/dfc/group__dynamic__matrix.html#gaa54415384b69f52ee6073d139ad084b3" title="Checks the given matrix for not-a-number elements.">isnan</a>( a ) ) { ... }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af5abd27e95a034535519cb8d7cf77b96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest element of the sparse vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The largest sparse vector element.</dd></dl>
<p>This function returns the largest element of the given sparse vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types).</p>
<p><b>Note:</b> In case the compressed vector is not completely filled, the zero elements are also taken into account. Example: the following compressed vector has only 2 non-zero elements. However, the maximum of this vector is 0:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} -1 &amp; 0 &amp; -3 &amp; 0 \\ \end{array}\right) \]" src="../../form_162.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a4dfece09c8894df8c71845d072c5ef01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest element of the sparse vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The smallest sparse vector element.</dd></dl>
<p>This function returns the smallest element of the given sparse vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types).</p>
<p><b>Note:</b> In case the sparse vector is not completely filled, the zero elements are also taken into account. Example: the following compressed vector has only 2 non-zero elements. However, the minimum of this vector is 0:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} 1 &amp; 0 &amp; 3 &amp; 0 \\ \end{array}\right) \]" src="../../form_161.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a84b4bc2f9d06fe63f94e6cb86944625e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Null &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a> and a pointer or pointer-to-member. </p>
<p>This operator takes a reference to an object of type T instead of a pointer of a pointer- to-member to avoid the ambiguity with the built-in pointer comparison operators. However, only pointers and pointers-to-member can be compared to <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a>. </p>

</div>
</div>
<a class="anchor" id="a6a9ed8d5afaf89d17a59c687d3babf8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Null &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a pointer or pointer-to-member and <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a>. </p>
<p>This operator takes a reference to an object of type T instead of a pointer of a pointer- to-member to avoid the ambiguity with the built-in pointer comparison operators. However, only pointers and pointers-to-member can be compared to <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a>. </p>

</div>
</div>
<a class="anchor" id="a0b94802b1621abe72010aa92b1c323a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const UnsignedValue&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedValue&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two values are not equal, <em>true</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="aac8a3e3b7fb672689907927512c04839"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PtrIterator&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrIterator&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators don't point to the same element, <em>false</em> if they do. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c24212630a6f1d6597740647e3413eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PtrVector&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrVector&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two pointer vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side pointer vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side pointer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two pointer vectors are inequal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="ad17b6ccf3e72a2176b217b977c8e0981"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const UnsignedValue&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedValue&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left value is less than the right value, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf608ae97f0284e56745139e110ea699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const PtrIterator&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrIterator&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator points to a lower element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d629135d4db89e1fcdcfd4b8f7c347e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; blaze::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedValue&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global output operator for the <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Reference to the output stream. </td></tr>
    <tr><td class="paramname">uv</td><td>Reference to a <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a602483ca8c570c315b235511663102eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const UnsignedValue&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedValue&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left value is less or equal than the right value, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a781ebe21d450f8210a6d3faff39aaf3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ae3c328fc213609bb1ca7950c114a6cd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a1d8e0741c8241a36753d0cc87df99461"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a0752b785a47c338222a9eee3d9221799"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a7399c56304153ea6b9068cbe00d41085"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const PtrIterator&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrIterator&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator points to a lower or the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a078fff484ed6fc2a78db73d2e3f19ff1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a17abc6a6b11aecfc787e01c600e0546b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a7fa9b68879cea6b50867c5018151bee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a00734ffb630fb7fbb9864ae0845629e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ae4e1826114c844141dbae5b4c0b7cdd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const Null &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a> and a pointer or pointer-to-member. </p>
<p>This operator takes a reference to an object of type T instead of a pointer of a pointer- to-member to avoid the ambiguity with the built-in pointer comparison operators. However, only pointers and pointers-to-member can be compared to <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a>. </p>

</div>
</div>
<a class="anchor" id="a239cf16a0f5fdbc42bfefe5641681fb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Null &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a pointer or pointer-to-member and <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a>. </p>
<p>This operator takes a reference to an object of type T instead of a pointer of a pointer- to-member to avoid the ambiguity with the built-in pointer comparison operators. However, only pointers and pointers-to-member can be compared to <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a>. </p>

</div>
</div>
<a class="anchor" id="af275fc8373d91ea8aff2b0b8e8dd3e89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const UnsignedValue&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedValue&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two values are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a83125315ff1fc56974b1525cd6d9c4cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const PtrIterator&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrIterator&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the iterators point to the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bd2908dd4b8aae738fcb0aa21d494af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const PtrVector&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrVector&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two pointer vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side pointer vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side pointer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two pointer vectors are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="a4918d3c24509bf7651948a10524dbdb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const UnsignedValue&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedValue&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left value if greater than the right value, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a378bc920e7d0cfddbe90600e14f358c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const PtrIterator&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrIterator&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator points to a higher element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a73335dc2737714119ab3747f7d4d48b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const UnsignedValue&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedValue&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left value is greater or equal than the right value, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a188f3a0469d483574d9890cfff75595d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ad4bff1ddbeb77e5c4fcf10092802ed0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a7ae9de028e10fdadac0f290e069a1a14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a64738f0618d70a2975c7bbfc876cc84a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ad4c6bd436ad385878f4c70a9b9ee5dd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeL , typename TypeR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const PtrIterator&lt; TypeL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PtrIterator&lt; TypeR &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side pointer iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side pointer iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side iterator points to a higher or the same element, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="aa46c931e3c38d084981c9ebe8611a3b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a19a9ea78dadddb5de9278854251cc8f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="add532f78625cbf286b84fa5d4d8b32ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a858866c9c17929b12f6970c90128c932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="afc275ea3ab616899091b50d46fc6e1a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; blaze::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnsignedValue&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global input operator for the <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Reference to the input stream. </td></tr>
    <tr><td class="paramname">uv</td><td>Reference to a <a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html" title="Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-i...">UnsignedValue</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream.</dd></dl>
<p>The input operator guarantees that this object is not changed in the case of an input error. Only values suitable for the according built-in unsigned integral data type <em>T</em> are allowed. Otherwise, the input stream's position is returned to its previous position and the <em>std::istream::failbit</em> is set. </p>

</div>
</div>
<a class="anchor" id="a300de20d22689dc8157697e1d2026f10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> blaze::polymorphicCount </td>
          <td>(</td>
          <td class="paramtype">S *const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *const *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the pointer to objects with dynamic type <em>D</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first pointer of the pointer range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the pointer one past the last pointer of the pointer range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects with dynamic type <em>D</em>.</dd></dl>
<p>This function traverses the range <img class="formulaInl" alt="$ [first,last) $" src="../../form_164.png"/> of pointers to objects with static type <em>S</em> and counts all polymorphic pointers to objects of dynamic type <em>D</em>. Note that in case <em>D</em> is not a type derived from <em>S</em>, a compile time error is created! </p>

</div>
</div>
<a class="anchor" id="a526e1bd58f6ea4e93e56d5fd71a0168d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S* const* blaze::polymorphicFind </td>
          <td>(</td>
          <td class="paramtype">S *const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *const *&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next pointer to an object with dynamic type <em>D</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first pointer of the pointer range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the pointer one past the last pointer of the pointer range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next pointer to an object with dynamic type <em>D</em>.</dd></dl>
<p>This function traverses the range <img class="formulaInl" alt="$ [first,last) $" src="../../form_164.png"/> of pointers to objects with static type <em>S</em> until it finds the next polymorphic pointer to an object of dynamic type <em>D</em>. Note that in case <em>D</em> is not a type derived from <em>S</em>, a compile time error is created! </p>

</div>
</div>
<a class="anchor" id="a2fec0c1b60eb0357323c125b538a4192"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">DynamicVector&lt; Type, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resetting the given dynamic vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The dynamic vector to be resetted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a1b5dc51e7401cfb7b7f62e2a08faf2b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename D , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">PtrVector&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PtrVector&lt; T, D, G &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two pointer vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first pointer vector to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second pointer vector to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13d4cd69110729a64a3717e0d628f011"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">DynamicVector&lt; Type, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicVector&lt; Type, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first vector to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second vector to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a5e42e1508f7d4d364fe7c64eef78a583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool blaze::columnMajor = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage order flag for column-major matrices. </p>
<p>Via this flag it is possible to specify the storage order of matrices as column-major. For instance, given the following matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right)\]" src="../../form_19.png"/>
</p>
<p><br/>
</p>
<p>in case of column-major order the elements are stored in the order</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{6}{c}} 1 &amp; 4 &amp; 2 &amp; 5 &amp; 3 &amp; 6. \\ \end{array}\right)\]" src="../../form_21.png"/>
</p>
<p>The following example demonstrates the setup of this <img class="formulaInl" alt="$ 2 \times 3 $" src="../../form_62.png"/> matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices.">blaze::columnMajor</a>;</div>
<div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,2UL,3UL,columnMajor&gt;</a> A( 1, 2, 3, 4, 5, 6 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acee466faebcaba59afde0fbfe22041aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool blaze::columnVector = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose flag for column vectors. </p>
<p>Via this flag it is possible to specify vectors as column vectors. The following example demonstrates the setup of a 3-dimensional column vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;int,3UL,columnVector&gt;</a> v( 1, 2, 3 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a511878ce70095271b6d0dd5b855a9eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool blaze::rowMajor = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage order flag for row-major matrices. </p>
<p>Via this flag it is possible to specify the storage order of matrices as row-major. For instance, given the following matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right)\]" src="../../form_19.png"/>
</p>
<p><br/>
</p>
<p>in case of row-major order the elements are stored in the order</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{6}{c}} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6. \\ \end{array}\right)\]" src="../../form_20.png"/>
</p>
<p>The following example demonstrates the setup of this <img class="formulaInl" alt="$ 2 \times 3 $" src="../../form_62.png"/> matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>;</div>
<div class="line"><a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">blaze::StaticMatrix&lt;int,2UL,3UL,rowMajor&gt;</a> A( 1, 2, 3, 4, 5, 6 );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a006b6328815f2632d2c5ab8b869c5cf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool blaze::rowVector = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose flag for row vectors. </p>
<p>Via this flag it is possible to specify vectors as row vectors. The following example demonstrates the setup of a 3-dimensional row vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a>;</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;int,3UL,rowVector&gt;</a> v( 1, 2, 3 );</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:41 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
