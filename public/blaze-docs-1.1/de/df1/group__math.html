<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Math module</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Math module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:de/d95/group__math__constraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html">Compile time constraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d7a/group__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/dcf/group__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/daa/group__intrinsics"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html">Intrinsics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d5e/group__quaternion"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d5e/group__quaternion.html">Quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d5b/group__math__shims"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html">Shims</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/dac/group__solvers"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dac/group__solvers.html">Solvers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d92/group__math__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html">Expression traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/d7b/group__math__type__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html">Type traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">blaze::NegativeAccuracy&lt; A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative computation accuracy for floating point data types.The <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative computation accuracy of the Blaze library for any floating point data type. In order to assign a negative accuracy value, the <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../da/d32/classblaze_1_1NegativeAccuracy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">blaze::Accuracy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> accuracy for floating point data types.The <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the computation accuracy of the Blaze library for any floating point data type. In order to assign an accuracy value, the <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br/>
 In order to handle accuracy values conveniently, the global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance <a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> is provided, which can be used wherever a floating point data value is required.  <a href="../../d6/d75/classblaze_1_1Accuracy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">blaze::NegativeEpsilon&lt; E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative epsilon value for floating point data types.The <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative smallest difference between two values of any floating point data type. In order to assign a negative epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../d9/d70/classblaze_1_1NegativeEpsilon.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">blaze::Epsilon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical epsilon value for floating point data types.The <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the smallest difference between two values of any floating point data type. In order to assign an epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br/>
 In order to handle epsilon values conveniently, the global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance <a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> is provided, which can be used wherever a floating point data type is required.  <a href="../../dd/d28/classblaze_1_1Epsilon.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html">blaze::Computation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all compute expression templates.The <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> class serves as a tag for all computational expression templates. All classes, that represent a mathematical computation (addition, subtraction, multiplication, division, absolute value calculation, ...) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as computational expression template. Only in case a class is derived from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class, the <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html" title="Compile time check whether the given type is a computational expression template.This type trait clas...">IsComputation</a> type trait recognizes the class as valid computational expression template.  <a href="../../de/dd5/structblaze_1_1Computation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html">blaze::Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all expression templates.The <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> class is the base class for all expression templates. All classes, that represent a mathematical operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as expression template. Only in case a class is derived from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class, the <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html" title="Compile time check whether the given type is an expression template.This type trait class tests wheth...">IsExpression</a> type trait recognizes the class as valid expression template.  <a href="../../d5/d2e/structblaze_1_1Expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">blaze::NegativeInfinity&lt; I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity for built-in data types.The <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possibility to assign negative infinity values to built-in data types. As negative infinity value, the largest possible negative value of the corresponding data type is used. In order to assign the negative infinity value, the <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class can be implicitly converted to all signed integral and floating point data types:  <a href="../../db/da3/classblaze_1_1NegativeInfinity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dff/classblaze_1_1Infinity.html">blaze::Infinity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity for built-in data types.The <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possiblity to assign a positive infinity value to built-in data types. As positive infinity value, the largest possible positive value of the corresponding data type is used. In order to assign the positive infinity value, the <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class can be implicitly converted to the following 13 built-in integral and floating point data types:  <a href="../../da/dff/classblaze_1_1Infinity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de7/structblaze_1_1BoxLCP.html">blaze::BoxLCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A box linear complementarity problem (BLCP) data structure.The <a class="el" href="../../d8/de7/structblaze_1_1BoxLCP.html" title="A box linear complementarity problem (BLCP) data structure.The BoxLCP class represent a box linear co...">BoxLCP</a> class represent a box linear complementarity problem (BLCP) of the form <img class="formulaInl" alt="$ A \cdot x + b \leq 0 \quad\perp\quad \underline{x} \leq x \leq \bar{x} $" src="../../form_111.png"/>.  <a href="../../d8/de7/structblaze_1_1BoxLCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d46/structblaze_1_1ContactLCP.html">blaze::ContactLCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure for linear complementarity problems (LCPs) for contact mechanics.TODO.  <a href="../../d8/d46/structblaze_1_1ContactLCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/structblaze_1_1LCP.html">blaze::LCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear complementarity problem (<a class="el" href="../../db/d3a/structblaze_1_1LCP.html" title="A linear complementarity problem (LCP) data structure.The LCP class represent a linear complementarit...">LCP</a>) data structure.The <a class="el" href="../../db/d3a/structblaze_1_1LCP.html" title="A linear complementarity problem (LCP) data structure.The LCP class represent a linear complementarit...">LCP</a> class represent a linear complementarity problem of the form <img class="formulaInl" alt="$ A \cdot x + b \leq 0 \quad\perp\quad x \geq 0 $" src="../../form_116.png"/>.  <a href="../../db/d3a/structblaze_1_1LCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de6/structblaze_1_1LSE.html">blaze::LSE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear system of equations (<a class="el" href="../../dd/de6/structblaze_1_1LSE.html" title="A linear system of equations (LSE) data structure.The LSE class represent a linear system of equation...">LSE</a>) data structure.The <a class="el" href="../../dd/de6/structblaze_1_1LSE.html" title="A linear system of equations (LSE) data structure.The LSE class represent a linear system of equation...">LSE</a> class represent a linear system of equations of the form <img class="formulaInl" alt="$ A \cdot x + b = 0 $" src="../../form_117.png"/>.  <a href="../../dd/de6/structblaze_1_1LSE.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/daf/structblaze_1_1MixedLCP.html">blaze::MixedLCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mixed linear complementarity problem (MLCP) data structure.The <a class="el" href="../../db/d3a/structblaze_1_1LCP.html" title="A linear complementarity problem (LCP) data structure.The LCP class represent a linear complementarit...">LCP</a> class represent a mixed linear complementarity problem of the form.  <a href="../../d5/daf/structblaze_1_1MixedLCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df0/structblaze_1_1ModifiedBoxLCP.html">blaze::ModifiedBoxLCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified box linear complementarity problem (MBLCP) data structure.The <a class="el" href="../../df/df0/structblaze_1_1ModifiedBoxLCP.html" title="A modified box linear complementarity problem (MBLCP) data structure.The ModifiedBoxLCP class represe...">ModifiedBoxLCP</a> class represent a modified box linear complementarity problem (MBLCP) of the form.  <a href="../../df/df0/structblaze_1_1ModifiedBoxLCP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">blaze::MatrixAccessProxy&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, <img class="formulaInl" alt="$ M \times N $" src="../../form_18.png"/> matrices.The <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> provides safe access to the elements of a non-const sparse matrices.<br/>
 The proxied access to the elements of a sparse matrix is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> class:  <a href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d71/classblaze_1_1SparseElement.html">blaze::SparseElement&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-value-pair for the sparse vectors and matrices.The <a class="el" href="../../d2/d71/classblaze_1_1SparseElement.html" title="Index-value-pair for the sparse vectors and matrices.The SparseElement class represents a single inde...">SparseElement</a> class represents a single index-value-pair of a sparse vector or sparse matrix.  <a href="../../d2/d71/classblaze_1_1SparseElement.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">blaze::VectorAccessProxy&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, N-dimensional vectors.The <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> provides safe access to the elements of a non-const sparse vector.<br/>
 The proxied access to the elements of a sparse vector is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">CompressedVector</a> class:  <a href="../../df/de3/classblaze_1_1VectorAccessProxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d18/structblaze_1_1AddTrait.html">blaze::AddTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class.">AddTrait</a> class.  <a href="../../db/d18/structblaze_1_1AddTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html">blaze::CMathTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html" title="Base template for the CMathTrait class.The CMathTrait template evaluates the return type of the mathe...">CMathTrait</a> class.The <a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html" title="Base template for the CMathTrait class.The CMathTrait template evaluates the return type of the mathe...">CMathTrait</a> template evaluates the return type of the mathematical functions defined in the C++ header &lt;cmath&gt; depending on the type of the template argument. In case of an integral data type or double precision argument, the return value of the functions is double, whereas the return type is float for single precision arguments and long double for long double precision arguments.  <a href="../../de/d19/structblaze_1_1CMathTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html">blaze::CrossTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class.">CrossTrait</a> class.  <a href="../../d4/d9c/structblaze_1_1CrossTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html">blaze::DivTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class.">DivTrait</a> class.  <a href="../../d2/d67/structblaze_1_1DivTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">blaze::MathTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class.">MathTrait</a> class.  <a href="../../d3/d6a/structblaze_1_1MathTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">blaze::MultTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class.  <a href="../../df/daf/structblaze_1_1MultTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html">blaze::SubTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class.">SubTrait</a> class.  <a href="../../dd/d27/structblaze_1_1SubTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabb8e75edc779325153b83682719245ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabb8e75edc779325153b83682719245ad">blaze::EulerRotation</a> { <br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada118e24268bcf97b44eec6df1a07e18a8">blaze::XYZs</a> = 0, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adab20056066766b8e028bfd748cc2e8b38">blaze::ZYXr</a> = 1, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adaf30a23352c5321a1f764e8ac8c6eba54">blaze::XYXs</a> = 2, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada46a059abef1f46af288cae9692e561be">blaze::XYXr</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adab2e079e6efc89f78d11fdc8284de24bd">blaze::XZYs</a> = 4, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adac13c774667287e4cc5f4f1e4e334edeb">blaze::YZXr</a> = 5, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adab8b9789db84f69432b11846ac6731aed">blaze::XZXs</a> = 6, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada766f40a51c48eb40b39510cd04fddf99">blaze::XZXr</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada8bfb50618a15f695dcff16a3c4bca732">blaze::YZXs</a> = 8, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada2b05988456cbed5b823eb9ab3a210dae">blaze::XZYr</a> = 9, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada3e4e02d0fd147e52a9f06803df312a7f">blaze::YZYs</a> = 10, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada4e21a6d803a2dcbbee5ad9f2b1432396">blaze::YZYr</a> = 11, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada1f93c75f60f4723a914e5b0455510417">blaze::YXZs</a> = 12, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adaa30cc7c9cbe77e371e6f5a7d8eb07e35">blaze::ZXYr</a> = 13, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adacce1d91a90c6890ddcd734d0995ac6c6">blaze::YXYs</a> = 14, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada0995487f6da326a3417b528267a687d8">blaze::YXYr</a> = 15, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada625d83e6ba3d600e127237f9a95388be">blaze::ZXYs</a> = 16, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada0b1676c74a1276f43d5c98609e4ecee2">blaze::YXZr</a> = 17, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245adaa10fea420d4a43929fb869abeb33450d">blaze::ZXZs</a> = 18, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada62dcb377d9ba6127d1b04d1296eda7a0">blaze::ZXZr</a> = 19, 
<br/>
&#160;&#160;<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada4287618f6f42cedea058a13eebe445b0">blaze::ZYXs</a> = 20, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada49f76665b83c6931debef5f1c10b29fa">blaze::XYZr</a> = 21, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada18f50b0b2f770fed42f7056d00992d00">blaze::ZYZs</a> = 22, 
<a class="el" href="../../de/df1/group__math.html#ggabb8e75edc779325153b83682719245ada2d12ca7957fb70a17bcc525be5a13cc8">blaze::ZYZr</a> = 23
<br/>
 }</td></tr>
<tr class="memdesc:gabb8e75edc779325153b83682719245ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of the Euler rotationThis codes are needed for the EulerAngles function in order to calculate the Euler angles for a specific combination of rotations.  <a href="../../de/df1/group__math.html#gabb8e75edc779325153b83682719245ad">More...</a><br/></td></tr>
<tr class="separator:gabb8e75edc779325153b83682719245ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga625b0b7ac3b908bc3266c6d834630806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga625b0b7ac3b908bc3266c6d834630806"></a>
const Accuracy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806">blaze::accuracy</a></td></tr>
<tr class="memdesc:ga625b0b7ac3b908bc3266c6d834630806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the computation accuracy of the Blaze library for the according data type. <br/></td></tr>
<tr class="separator:ga625b0b7ac3b908bc3266c6d834630806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2f6a797255a44b04f704ff548385d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec2f6a797255a44b04f704ff548385d4"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaec2f6a797255a44b04f704ff548385d4">blaze::M_E</a> = 2.7182818284590452353602874713526625</td></tr>
<tr class="memdesc:gaec2f6a797255a44b04f704ff548385d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ e $" src="../../form_10.png"/>. <br/></td></tr>
<tr class="separator:gaec2f6a797255a44b04f704ff548385d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf858edb18cdfb5695345c47879be3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bf858edb18cdfb5695345c47879be3f"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6bf858edb18cdfb5695345c47879be3f">blaze::M_LOG2E</a> = 1.4426950408889634073599246810018921</td></tr>
<tr class="memdesc:ga6bf858edb18cdfb5695345c47879be3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \log_2 e $" src="../../form_11.png"/>. <br/></td></tr>
<tr class="separator:ga6bf858edb18cdfb5695345c47879be3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0ee7da2d612ffe0d0837a63ed9f4bff"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf0ee7da2d612ffe0d0837a63ed9f4bff">blaze::M_LOG10E</a> = 0.4342944819032518276511289189166051</td></tr>
<tr class="memdesc:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \log_{10} e $" src="../../form_12.png"/>. <br/></td></tr>
<tr class="separator:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1502d2dcd380b1eb5e56ffd898ceb5ca"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1502d2dcd380b1eb5e56ffd898ceb5ca">blaze::M_LN2</a> = 0.6931471805599453094172321214581766</td></tr>
<tr class="memdesc:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \ln 2 $" src="../../form_13.png"/>. <br/></td></tr>
<tr class="separator:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b89d4af29804852eb0830a1481e9801"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9b89d4af29804852eb0830a1481e9801"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b89d4af29804852eb0830a1481e9801">blaze::M_LN10</a> = 2.3025850929940456840179914546843642</td></tr>
<tr class="memdesc:ga9b89d4af29804852eb0830a1481e9801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \ln 10 $" src="../../form_14.png"/>. <br/></td></tr>
<tr class="separator:ga9b89d4af29804852eb0830a1481e9801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2600098236fe85a4d5e79e4d9de26318"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2600098236fe85a4d5e79e4d9de26318"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2600098236fe85a4d5e79e4d9de26318">blaze::M_PI</a> = 3.1415926535897932384626433832795029</td></tr>
<tr class="memdesc:ga2600098236fe85a4d5e79e4d9de26318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \pi $" src="../../form_15.png"/>. <br/></td></tr>
<tr class="separator:ga2600098236fe85a4d5e79e4d9de26318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56db875675fe79ee8b7685673eb5c02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad56db875675fe79ee8b7685673eb5c02"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad56db875675fe79ee8b7685673eb5c02">blaze::M_SQRT2</a> = 1.4142135623730950488016887242096981</td></tr>
<tr class="memdesc:gad56db875675fe79ee8b7685673eb5c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \sqrt{2} $" src="../../form_16.png"/>. <br/></td></tr>
<tr class="separator:gad56db875675fe79ee8b7685673eb5c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b83fd428d08d322190fb8d09fb72eaf"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6b83fd428d08d322190fb8d09fb72eaf">blaze::M_SQRT3</a> = 1.7320508075688772935274463415058724</td></tr>
<tr class="memdesc:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \sqrt{3} $" src="../../form_17.png"/>. <br/></td></tr>
<tr class="separator:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a02d7d60cd864ce158adb1cdf17989c"></a>
const Epsilon&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c">blaze::epsilon</a></td></tr>
<tr class="memdesc:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the smallest possible difference between two values of the according data type. <br/></td></tr>
<tr class="separator:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97926ed3b4199bea5635290031cfe38f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97926ed3b4199bea5635290031cfe38f"></a>
const Infinity&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga97926ed3b4199bea5635290031cfe38f">blaze::inf</a></td></tr>
<tr class="memdesc:ga97926ed3b4199bea5635290031cfe38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga97926ed3b4199bea5635290031cfe38f" title="Global Infinity instance.The blaze::inf instance can be used wherever a built-in data type is expecte...">blaze::inf</a> instance can be used wherever a built-in data type is expected. It is implicitly converted to the corresponding built-in data type and represents its largest possible data value. <br/></td></tr>
<tr class="separator:ga97926ed3b4199bea5635290031cfe38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accuracy operators</h2></td></tr>
<tr class="memitem:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2eebfaf6382f255164a9cefa6ab8eb27">blaze::operator==</a> (const NegativeAccuracy&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#ga2eebfaf6382f255164a9cefa6ab8eb27"></a><br/></td></tr>
<tr class="separator:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf42a6c23efe1880899f5b89b265286"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga3cf42a6c23efe1880899f5b89b265286"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3cf42a6c23efe1880899f5b89b265286">blaze::operator==</a> (const T &amp;lhs, const NegativeAccuracy&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga3cf42a6c23efe1880899f5b89b265286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#ga3cf42a6c23efe1880899f5b89b265286"></a><br/></td></tr>
<tr class="separator:ga3cf42a6c23efe1880899f5b89b265286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6ac5831d994de1617100e79b409f78"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga5f6ac5831d994de1617100e79b409f78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5f6ac5831d994de1617100e79b409f78">blaze::operator!=</a> (const NegativeAccuracy&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga5f6ac5831d994de1617100e79b409f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#ga5f6ac5831d994de1617100e79b409f78"></a><br/></td></tr>
<tr class="separator:ga5f6ac5831d994de1617100e79b409f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga22db42744b1d782e174dbcf6f2bf37e2">blaze::operator!=</a> (const T &amp;lhs, const NegativeAccuracy&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#ga22db42744b1d782e174dbcf6f2bf37e2"></a><br/></td></tr>
<tr class="separator:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42be9e710c330d928604c4fe730661d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga42be9e710c330d928604c4fe730661d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga42be9e710c330d928604c4fe730661d5">blaze::operator==</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga42be9e710c330d928604c4fe730661d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#ga42be9e710c330d928604c4fe730661d5"></a><br/></td></tr>
<tr class="separator:ga42be9e710c330d928604c4fe730661d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5362cd08bf302cd8f8272be634a5b435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5362cd08bf302cd8f8272be634a5b435"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5362cd08bf302cd8f8272be634a5b435">blaze::operator==</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:ga5362cd08bf302cd8f8272be634a5b435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#ga5362cd08bf302cd8f8272be634a5b435"></a><br/></td></tr>
<tr class="separator:ga5362cd08bf302cd8f8272be634a5b435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81389b775ddd91717cc708fd4815b6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac81389b775ddd91717cc708fd4815b6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac81389b775ddd91717cc708fd4815b6a">blaze::operator!=</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac81389b775ddd91717cc708fd4815b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#gac81389b775ddd91717cc708fd4815b6a"></a><br/></td></tr>
<tr class="separator:gac81389b775ddd91717cc708fd4815b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae116a92a519bc1a7faa511e50ebd3b90">blaze::operator!=</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:gae116a92a519bc1a7faa511e50ebd3b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#gae116a92a519bc1a7faa511e50ebd3b90"></a><br/></td></tr>
<tr class="separator:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab0f6e6c059c34b31b67dfe6e6420398d">blaze::operator&lt;</a> (const NegativeAccuracy&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#gab0f6e6c059c34b31b67dfe6e6420398d"></a><br/></td></tr>
<tr class="separator:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f80a558803f060623e0ac21763e989a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga9f80a558803f060623e0ac21763e989a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9f80a558803f060623e0ac21763e989a">blaze::operator&lt;</a> (const T &amp;lhs, const NegativeAccuracy&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga9f80a558803f060623e0ac21763e989a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#ga9f80a558803f060623e0ac21763e989a"></a><br/></td></tr>
<tr class="separator:ga9f80a558803f060623e0ac21763e989a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0c3a3aa80c4823700946bfbcbf0e15a7">blaze::operator&gt;</a> (const NegativeAccuracy&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#ga0c3a3aa80c4823700946bfbcbf0e15a7"></a><br/></td></tr>
<tr class="separator:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad1147bca7c8d61c5705dd67a7bb37b72">blaze::operator&gt;</a> (const T &amp;lhs, const NegativeAccuracy&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#gad1147bca7c8d61c5705dd67a7bb37b72"></a><br/></td></tr>
<tr class="separator:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaecb0cc5d9dcf5ed3c3a244b072b838ba">blaze::operator&lt;</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#gaecb0cc5d9dcf5ed3c3a244b072b838ba"></a><br/></td></tr>
<tr class="separator:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafdbb1c3cbb179e0e86ef79b4ffa11dc4">blaze::operator&lt;</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#gafdbb1c3cbb179e0e86ef79b4ffa11dc4"></a><br/></td></tr>
<tr class="separator:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga84f7eea431aca4b1b3741d765cfe300e">blaze::operator&gt;</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga84f7eea431aca4b1b3741d765cfe300e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#ga84f7eea431aca4b1b3741d765cfe300e"></a><br/></td></tr>
<tr class="separator:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaab2ec2c16b016e3ba86a076cee12001d">blaze::operator&gt;</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:gaab2ec2c16b016e3ba86a076cee12001d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#gaab2ec2c16b016e3ba86a076cee12001d"></a><br/></td></tr>
<tr class="separator:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NegativeEpsilon operators</h2></td></tr>
<tr class="memitem:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7b8b533b8e6a1bbcc85cbd8de67a07bd">blaze::operator==</a> (const NegativeEpsilon&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#ga7b8b533b8e6a1bbcc85cbd8de67a07bd"></a><br/></td></tr>
<tr class="separator:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3cfe831bb614ba1d4a67eaea42c82998">blaze::operator==</a> (const T &amp;lhs, const NegativeEpsilon&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#ga3cfe831bb614ba1d4a67eaea42c82998"></a><br/></td></tr>
<tr class="separator:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafc02f01b7d880ce7e0f5413746872b3d">blaze::operator!=</a> (const NegativeEpsilon&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gafc02f01b7d880ce7e0f5413746872b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#gafc02f01b7d880ce7e0f5413746872b3d"></a><br/></td></tr>
<tr class="separator:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d93714b380cec87ee26da168f4a0e5"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga46d93714b380cec87ee26da168f4a0e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga46d93714b380cec87ee26da168f4a0e5">blaze::operator!=</a> (const T &amp;lhs, const NegativeEpsilon&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga46d93714b380cec87ee26da168f4a0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#ga46d93714b380cec87ee26da168f4a0e5"></a><br/></td></tr>
<tr class="separator:ga46d93714b380cec87ee26da168f4a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac1d14e4e7b3ef42af647b7d92db0f6cc">blaze::operator&lt;</a> (const NegativeEpsilon&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#gac1d14e4e7b3ef42af647b7d92db0f6cc"></a><br/></td></tr>
<tr class="separator:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b86a750765429e61761ff7baee2b9d5"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga9b86a750765429e61761ff7baee2b9d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b86a750765429e61761ff7baee2b9d5">blaze::operator&lt;</a> (const T &amp;lhs, const NegativeEpsilon&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga9b86a750765429e61761ff7baee2b9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#ga9b86a750765429e61761ff7baee2b9d5"></a><br/></td></tr>
<tr class="separator:ga9b86a750765429e61761ff7baee2b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga22864fea6db8d1ca553b327194d0b9aa">blaze::operator&gt;</a> (const NegativeEpsilon&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga22864fea6db8d1ca553b327194d0b9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#ga22864fea6db8d1ca553b327194d0b9aa"></a><br/></td></tr>
<tr class="separator:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaedd63616a647a5c54dd3fc4d8061010b">blaze::operator&gt;</a> (const T &amp;lhs, const NegativeEpsilon&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:gaedd63616a647a5c54dd3fc4d8061010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#gaedd63616a647a5c54dd3fc4d8061010b"></a><br/></td></tr>
<tr class="separator:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Epsilon operators</h2></td></tr>
<tr class="memitem:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac3ec406b1801fa25c3f9ffa9144cee0b">blaze::operator==</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#gac3ec406b1801fa25c3f9ffa9144cee0b"></a><br/></td></tr>
<tr class="separator:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8e7b4cf5af885cb431eb37281691fe4d">blaze::operator==</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#ga8e7b4cf5af885cb431eb37281691fe4d"></a><br/></td></tr>
<tr class="separator:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a50f57ff770309ebb61142b2a425d27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7a50f57ff770309ebb61142b2a425d27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7a50f57ff770309ebb61142b2a425d27">blaze::operator!=</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga7a50f57ff770309ebb61142b2a425d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#ga7a50f57ff770309ebb61142b2a425d27"></a><br/></td></tr>
<tr class="separator:ga7a50f57ff770309ebb61142b2a425d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927507337b7b6cdbe244112194218275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga927507337b7b6cdbe244112194218275"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga927507337b7b6cdbe244112194218275">blaze::operator!=</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:ga927507337b7b6cdbe244112194218275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#ga927507337b7b6cdbe244112194218275"></a><br/></td></tr>
<tr class="separator:ga927507337b7b6cdbe244112194218275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73847d144e9f3c172f5630175c05e28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad73847d144e9f3c172f5630175c05e28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad73847d144e9f3c172f5630175c05e28">blaze::operator&lt;</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gad73847d144e9f3c172f5630175c05e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#gad73847d144e9f3c172f5630175c05e28"></a><br/></td></tr>
<tr class="separator:gad73847d144e9f3c172f5630175c05e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b5ff3c3bb106998735574abd5a081b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga25b5ff3c3bb106998735574abd5a081b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga25b5ff3c3bb106998735574abd5a081b">blaze::operator&lt;</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:ga25b5ff3c3bb106998735574abd5a081b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#ga25b5ff3c3bb106998735574abd5a081b"></a><br/></td></tr>
<tr class="separator:ga25b5ff3c3bb106998735574abd5a081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga19f217c7d16c2691b15c61bd5aef9cee">blaze::operator&gt;</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#ga19f217c7d16c2691b15c61bd5aef9cee"></a><br/></td></tr>
<tr class="separator:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf0cbca3f85e459a6b20902cb55daad67">blaze::operator&gt;</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:gaf0cbca3f85e459a6b20902cb55daad67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#gaf0cbca3f85e459a6b20902cb55daad67"></a><br/></td></tr>
<tr class="separator:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mathematical utility functions</h2></td></tr>
<tr class="memitem:ga7fa1fa59c0750d7100d4186258c9494f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7fa1fa59c0750d7100d4186258c9494f"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7fa1fa59c0750d7100d4186258c9494f">blaze::sign</a> (T a)</td></tr>
<tr class="memdesc:ga7fa1fa59c0750d7100d4186258c9494f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign function.  <a href="#ga7fa1fa59c0750d7100d4186258c9494f"></a><br/></td></tr>
<tr class="separator:ga7fa1fa59c0750d7100d4186258c9494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd55880375d550adbae4dd61aebea75d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabd55880375d550adbae4dd61aebea75d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d">blaze::digits</a> (T a)</td></tr>
<tr class="memdesc:gabd55880375d550adbae4dd61aebea75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of valid digits of an integral value.  <a href="#gabd55880375d550adbae4dd61aebea75d"></a><br/></td></tr>
<tr class="separator:gabd55880375d550adbae4dd61aebea75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f9e4a8f0ebfe145ebcdc392722947fa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga2f9e4a8f0ebfe145ebcdc392722947fa"><td class="memTemplItemLeft" align="right" valign="top">const MathTrait&lt; T1, T2 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2f9e4a8f0ebfe145ebcdc392722947fa">blaze::min</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ga2f9e4a8f0ebfe145ebcdc392722947fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function for two arguments.  <a href="#ga2f9e4a8f0ebfe145ebcdc392722947fa"></a><br/></td></tr>
<tr class="separator:ga2f9e4a8f0ebfe145ebcdc392722947fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a68749f87c9d78862a6ef990198b94d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ga4a68749f87c9d78862a6ef990198b94d"><td class="memTemplItemLeft" align="right" valign="top">const MathTrait&lt; typename <br class="typebreak"/>
MathTrait&lt; T1, T2 &gt;::HighType, <br class="typebreak"/>
T3 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4a68749f87c9d78862a6ef990198b94d">blaze::min</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)</td></tr>
<tr class="memdesc:ga4a68749f87c9d78862a6ef990198b94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function for three arguments.  <a href="#ga4a68749f87c9d78862a6ef990198b94d"></a><br/></td></tr>
<tr class="separator:ga4a68749f87c9d78862a6ef990198b94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa529d2a056457bb5718bc9674b5d0769"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa529d2a056457bb5718bc9674b5d0769"><td class="memTemplItemLeft" align="right" valign="top">const MathTrait&lt; T1, T2 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa529d2a056457bb5718bc9674b5d0769">blaze::max</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:gaa529d2a056457bb5718bc9674b5d0769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function for two arguments.  <a href="#gaa529d2a056457bb5718bc9674b5d0769"></a><br/></td></tr>
<tr class="separator:gaa529d2a056457bb5718bc9674b5d0769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13834d431b63318ee3a2e78293b16cb3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ga13834d431b63318ee3a2e78293b16cb3"><td class="memTemplItemLeft" align="right" valign="top">const MathTrait&lt; typename <br class="typebreak"/>
MathTrait&lt; T1, T2 &gt;::HighType, <br class="typebreak"/>
T3 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga13834d431b63318ee3a2e78293b16cb3">blaze::max</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)</td></tr>
<tr class="memdesc:ga13834d431b63318ee3a2e78293b16cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function for three arguments.  <a href="#ga13834d431b63318ee3a2e78293b16cb3"></a><br/></td></tr>
<tr class="separator:ga13834d431b63318ee3a2e78293b16cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad24cbd848d0cfe4c28db2f49817182da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad24cbd848d0cfe4c28db2f49817182da"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad24cbd848d0cfe4c28db2f49817182da">blaze::round</a> (T a)</td></tr>
<tr class="memdesc:gad24cbd848d0cfe4c28db2f49817182da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the given input value.  <a href="#gad24cbd848d0cfe4c28db2f49817182da"></a><br/></td></tr>
<tr class="separator:gad24cbd848d0cfe4c28db2f49817182da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ccf7fb44308f52badb6b0a914be832"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga13ccf7fb44308f52badb6b0a914be832"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga13ccf7fb44308f52badb6b0a914be832">blaze::lessThan</a> (T1 a, T2 b)</td></tr>
<tr class="memdesc:ga13ccf7fb44308f52badb6b0a914be832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic less-than comparison.  <a href="#ga13ccf7fb44308f52badb6b0a914be832"></a><br/></td></tr>
<tr class="separator:ga13ccf7fb44308f52badb6b0a914be832"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NegativeInfinity operators</h2></td></tr>
<tr class="memitem:gaa89e010144eab077e9d596e74bab15b2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gaa89e010144eab077e9d596e74bab15b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa89e010144eab077e9d596e74bab15b2">blaze::operator==</a> (const NegativeInfinity&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaa89e010144eab077e9d596e74bab15b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="#gaa89e010144eab077e9d596e74bab15b2"></a><br/></td></tr>
<tr class="separator:gaa89e010144eab077e9d596e74bab15b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga52ce1ea57d9c7fd4be3ab4d75310032c">blaze::operator==</a> (const T &amp;lhs, const NegativeInfinity&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="#ga52ce1ea57d9c7fd4be3ab4d75310032c"></a><br/></td></tr>
<tr class="separator:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313c450e022ce76f66888b2b6be23e70"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga313c450e022ce76f66888b2b6be23e70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga313c450e022ce76f66888b2b6be23e70">blaze::operator!=</a> (const NegativeInfinity&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga313c450e022ce76f66888b2b6be23e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="#ga313c450e022ce76f66888b2b6be23e70"></a><br/></td></tr>
<tr class="separator:ga313c450e022ce76f66888b2b6be23e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabc9e7c387680b76ecf9056a3354c4f82">blaze::operator!=</a> (const T &amp;lhs, const NegativeInfinity&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabc9e7c387680b76ecf9056a3354c4f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="#gabc9e7c387680b76ecf9056a3354c4f82"></a><br/></td></tr>
<tr class="separator:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Infinity operators</h2></td></tr>
<tr class="memitem:ga051a2e303820cb2fde125c7516f75ce9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga051a2e303820cb2fde125c7516f75ce9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga051a2e303820cb2fde125c7516f75ce9">blaze::operator==</a> (const Infinity &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga051a2e303820cb2fde125c7516f75ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="#ga051a2e303820cb2fde125c7516f75ce9"></a><br/></td></tr>
<tr class="separator:ga051a2e303820cb2fde125c7516f75ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef53b8be129fa00b953bb0f160413b80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef53b8be129fa00b953bb0f160413b80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaef53b8be129fa00b953bb0f160413b80">blaze::operator==</a> (const T &amp;lhs, const Infinity &amp;rhs)</td></tr>
<tr class="memdesc:gaef53b8be129fa00b953bb0f160413b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="#gaef53b8be129fa00b953bb0f160413b80"></a><br/></td></tr>
<tr class="separator:gaef53b8be129fa00b953bb0f160413b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0b8c22e5fcef35073910201a7e0ae05a">blaze::operator!=</a> (const Infinity &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="#ga0b8c22e5fcef35073910201a7e0ae05a"></a><br/></td></tr>
<tr class="separator:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1d28fd67d95a6015c5b5b6fd62762e22">blaze::operator!=</a> (const T &amp;lhs, const Infinity &amp;rhs)</td></tr>
<tr class="memdesc:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="#ga1d28fd67d95a6015c5b5b6fd62762e22"></a><br/></td></tr>
<tr class="separator:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gabb8e75edc779325153b83682719245ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../de/df1/group__math.html#gabb8e75edc779325153b83682719245ad">blaze::EulerRotation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Order of the Euler rotationThis codes are needed for the EulerAngles function in order to calculate the Euler angles for a specific combination of rotations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada118e24268bcf97b44eec6df1a07e18a8"></a>XYZs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order x, y, z in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245adab20056066766b8e028bfd748cc2e8b38"></a>ZYXr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order z, y, x in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245adaf30a23352c5321a1f764e8ac8c6eba54"></a>XYXs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order x, y, x in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada46a059abef1f46af288cae9692e561be"></a>XYXr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order x, y, z in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245adab2e079e6efc89f78d11fdc8284de24bd"></a>XZYs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order x, z, y in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245adac13c774667287e4cc5f4f1e4e334edeb"></a>YZXr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order y, z, x in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245adab8b9789db84f69432b11846ac6731aed"></a>XZXs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order x, z, x in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada766f40a51c48eb40b39510cd04fddf99"></a>XZXr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order x, z, x in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada8bfb50618a15f695dcff16a3c4bca732"></a>YZXs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order y, z, x in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada2b05988456cbed5b823eb9ab3a210dae"></a>XZYr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order x, z, y in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada3e4e02d0fd147e52a9f06803df312a7f"></a>YZYs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order y, z, y in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada4e21a6d803a2dcbbee5ad9f2b1432396"></a>YZYr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order y, z, y in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada1f93c75f60f4723a914e5b0455510417"></a>YXZs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order y, x, z in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245adaa30cc7c9cbe77e371e6f5a7d8eb07e35"></a>ZXYr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order z, x, y in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245adacce1d91a90c6890ddcd734d0995ac6c6"></a>YXYs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order y, x, y in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada0995487f6da326a3417b528267a687d8"></a>YXYr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order y, x, y in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada625d83e6ba3d600e127237f9a95388be"></a>ZXYs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order z, x, y in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada0b1676c74a1276f43d5c98609e4ecee2"></a>YXZr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order y, x, z in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245adaa10fea420d4a43929fb869abeb33450d"></a>ZXZs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order z, x, z in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada62dcb377d9ba6127d1b04d1296eda7a0"></a>ZXZr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order z, x, z in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada4287618f6f42cedea058a13eebe445b0"></a>ZYXs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order z, y, x in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada49f76665b83c6931debef5f1c10b29fa"></a>XYZr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order x, y, z in a rotating frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada18f50b0b2f770fed42f7056d00992d00"></a>ZYZs</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order z, y, z in a static frame. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb8e75edc779325153b83682719245ada2d12ca7957fb70a17bcc525be5a13cc8"></a>ZYZr</em>&nbsp;</td><td class="fielddoc">
<p>Rotation order z, y, z in a rotating frame. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabd55880375d550adbae4dd61aebea75d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t blaze::digits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of valid digits of an integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The integral value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of valid digits.</dd></dl>
<p>This function counts the number of valid digits in the given integral value.</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d" title="Returns the number of valid digits of an integral value.">digits</a>( 100   );  <span class="comment">// Returns 3</span></div>
<div class="line"><a class="code" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d" title="Returns the number of valid digits of an integral value.">digits</a>( 12345 );  <span class="comment">// Returns 5</span></div>
<div class="line"><a class="code" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d" title="Returns the number of valid digits of an integral value.">digits</a>( 0     );  <span class="comment">// Returns 0</span></div>
</div><!-- fragment --><p>The digits function only works for integral built-in data types. The attempt to use any other type will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga13ccf7fb44308f52badb6b0a914be832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::lessThan </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic less-than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the first value is smaller than the second, <em>false</em> if not.</dd></dl>
<p>Generic less-than comparison between to numeric values. Depending on the types of the two arguments, a special comparison for floating point values is selected that takes the limited machine accuracy into account. </p>

</div>
</div>
<a class="anchor" id="gaa529d2a056457bb5718bc9674b5d0769"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MathTrait&lt; T1, T2 &gt;::HighType blaze::max </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum function for two arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum of the two values.</dd></dl>
<p>This function returns the maximum of the two given data values. The return type of the function is determined by the data types of the given arguments (for further detail see the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class.">MathTrait</a> class description). </p>

</div>
</div>
<a class="anchor" id="ga13834d431b63318ee3a2e78293b16cb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MathTrait&lt; typename MathTrait&lt; T1, T2 &gt;::HighType, T3 &gt;::HighType blaze::max </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum function for three arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
    <tr><td class="paramname">c</td><td>Third value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum of the three values.</dd></dl>
<p>This function returns the maximum of the three given data values. The return type of the function is determined by the data types of the given arguments (for further detail see the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class.">MathTrait</a> class description). </p>

</div>
</div>
<a class="anchor" id="ga2f9e4a8f0ebfe145ebcdc392722947fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MathTrait&lt; T1, T2 &gt;::HighType blaze::min </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum function for two arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum of the two values.</dd></dl>
<p>This function returns the minimum of the two given data values. The return type of the function is determined by the data types of the given arguments (for further detail see the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class.">MathTrait</a> class description). </p>

</div>
</div>
<a class="anchor" id="ga4a68749f87c9d78862a6ef990198b94d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MathTrait&lt; typename MathTrait&lt; T1, T2 &gt;::HighType, T3 &gt;::HighType blaze::min </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum function for three arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
    <tr><td class="paramname">c</td><td>Third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum of the three values.</dd></dl>
<p>This function returns the minimum of the three given data values. The return type of the function is determined by the data types of the given arguments (for further detail see the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class.">MathTrait</a> class description). </p>

</div>
</div>
<a class="anchor" id="ga5f6ac5831d994de1617100e79b409f78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gafc02f01b7d880ce7e0f5413746872b3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga22db42744b1d782e174dbcf6f2bf37e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga46d93714b380cec87ee26da168f4a0e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga313c450e022ce76f66888b2b6be23e70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const NegativeInfinity&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not negative infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gabc9e7c387680b76ecf9056a3354c4f82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeInfinity&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not negative infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gac81389b775ddd91717cc708fd4815b6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga7a50f57ff770309ebb61142b2a425d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga927507337b7b6cdbe244112194218275"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gae116a92a519bc1a7faa511e50ebd3b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga0b8c22e5fcef35073910201a7e0ae05a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Infinity &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga1d28fd67d95a6015c5b5b6fd62762e22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Infinity &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gab0f6e6c059c34b31b67dfe6e6420398d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gac1d14e4e7b3ef42af647b7d92db0f6cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga9f80a558803f060623e0ac21763e989a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga9b86a750765429e61761ff7baee2b9d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaecb0cc5d9dcf5ed3c3a244b072b838ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floatin point value is greater than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gad73847d144e9f3c172f5630175c05e28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gafdbb1c3cbb179e0e86ef79b4ffa11dc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga25b5ff3c3bb106998735574abd5a081b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga7b8b533b8e6a1bbcc85cbd8de67a07bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga2eebfaf6382f255164a9cefa6ab8eb27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga3cf42a6c23efe1880899f5b89b265286"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga3cfe831bb614ba1d4a67eaea42c82998"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaa89e010144eab077e9d596e74bab15b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const NegativeInfinity&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is negative infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga52ce1ea57d9c7fd4be3ab4d75310032c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeInfinity&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is negative infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gac3ec406b1801fa25c3f9ffa9144cee0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga42be9e710c330d928604c4fe730661d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga5362cd08bf302cd8f8272be634a5b435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga8e7b4cf5af885cb431eb37281691fe4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga051a2e303820cb2fde125c7516f75ce9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const Infinity &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaef53b8be129fa00b953bb0f160413b80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Infinity &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga0c3a3aa80c4823700946bfbcbf0e15a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga22864fea6db8d1ca553b327194d0b9aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaedd63616a647a5c54dd3fc4d8061010b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeEpsilon&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gad1147bca7c8d61c5705dd67a7bb37b72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NegativeAccuracy&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga19f217c7d16c2691b15c61bd5aef9cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga84f7eea431aca4b1b3741d765cfe300e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaf0cbca3f85e459a6b20902cb55daad67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epsilon &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaab2ec2c16b016e3ba86a076cee12001d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Accuracy &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gad24cbd848d0cfe4c28db2f49817182da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T blaze::round </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the given input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value to be rounded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rounded value.</dd></dl>
<p>This function rounds the given input value. In case the first digit after the comma is smaller than five the value is rounded down. Otherwise it is rounded up. Note that this function only works for integral and floating point types. The attempt to use the function for any other type will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga7fa1fa59c0750d7100d4186258c9494f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T blaze::sign </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The signed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the value is greater than or equal to zero, -1 if the value is smaller than zero.</dd></dl>
<p>The sign function only works for signed built-in data types. The attempt to use unsigned data types or user-defined class types will result in a compile time error. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:40 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
