<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Type traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Type traits<div class="ingroups"><a class="el" href="../../d4/d3a/group__util.html">Utility module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d90/structblaze_1_1HasSize.html">blaze::HasSize&lt; T, Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of a type at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> is exactly <em>Size</em> bytes large, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d90/structblaze_1_1HasSize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html">blaze::Has1Byte&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly one byte. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has one byte, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d94/structblaze_1_1Has1Byte.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html">blaze::Has2Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly two bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has two bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d49/structblaze_1_1Has2Bytes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html">blaze::Has4Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d99/structblaze_1_1Has4Bytes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html">blaze::Has8Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1Has8Bytes.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html">blaze::HaveSameSize&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of two types at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> an object of type <em>T1</em> has the same size as an object of type <em>T2</em>, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d76/classblaze_1_1HaveSameSize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html">blaze::IsArithmetic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for arithmetic data types.This type trait tests whether or not the given template parameter is a (possibly cv-qualified) arithmetic (integral or floating point) data type. In case the type is an arithmetic type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dc/daf/structblaze_1_1IsArithmetic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html">blaze::IsBaseOf&lt; Base, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relationship between the two types <em>Base</em> and <em>Derived</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>Derived</em> is a type derived from <em>Base</em> or the same type as <em>Base</em> the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d07/classblaze_1_1IsBaseOf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html">blaze::IsBoolean&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for boolean types.This type trait tests whether or not the given template parameter is of boolean type. In case the type is a boolean (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d48/structblaze_1_1IsBoolean.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">blaze::IsBuiltin&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for built-in data types.This type trait tests whether or not the given template parameter is a built-in/fundamental data type. In case the type is a built-in type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d1c/structblaze_1_1IsBuiltin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html">blaze::IsCharacter&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for character types.This type trait tests whether or not the given template parameter is a character type (i.e., either char, signed char, unsigned char, or wchar_t, possibly cv-qualified). In case the type is a character type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d32/structblaze_1_1IsCharacter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d97/structblaze_1_1IsClass.html">blaze::IsClass&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> type trait tests whether or not the given template parameter is a (possibly cv-qualified) class type. In case the given data type is a class type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dd/d97/structblaze_1_1IsClass.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">blaze::IsComplex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for complex types.This type trait tests whether or not the given template parameter is a complex data type. In case the type is a complex data type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/da9/structblaze_1_1IsComplex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html">blaze::IsConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for constant data types.The <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> type trait tests whether or not the given template parameter is a (top level) const-qualified data type. In case the given data type is const-qualified, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d5f/structblaze_1_1IsConst.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html">blaze::IsConvertible&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time pointer relationship constraint.This type traits tests whether the first given template argument can be converted to the second template argument via copy construction. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the first argument can be converted to the second argument, the <em>value</em> member enumeration is set to 1, the nested type definition <em>type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d98/structblaze_1_1IsConvertible.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d60/structblaze_1_1IsDouble.html">blaze::IsDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for double precision floating point types.This type trait tests whether or not the given template parameter is of double type. In case the type is double (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d60/structblaze_1_1IsDouble.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d07/structblaze_1_1IsFloat.html">blaze::IsFloat&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision floating point types.This type trait tests whether or not the given template parameter is of float type. In case the type is float (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d07/structblaze_1_1IsFloat.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html">blaze::IsFloatingPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for floating point data types.This type trait tests whether or not the given template parameter is a floating point data type (ignoring the cv-qualifiers). In case the type is a floating point data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html">blaze::IsInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integer types.This type trait tests whether or not the given template parameter is an integer type (i.e., either (signed) int or unsigned int, possibly cv-qualified). In case the type is an integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d5e/structblaze_1_1IsInteger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">blaze::IsIntegral&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integral data types.This type trait tests whether or not the given template parameter is an integral data type. In case the type is an integral data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d73/structblaze_1_1IsIntegral.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d40/structblaze_1_1IsLong.html">blaze::IsLong&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for long integer types.This type trait tests whether or not the given template parameter is a long integer type (i.e., either (signed) long or unsigned long, possibly cv-qualified). In case the type is a long integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d40/structblaze_1_1IsLong.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html">blaze::IsLongDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for extended precision floating point types.This type trait tests whether or not the given template parameter is of long double type. In case the type is long double (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d34/structblaze_1_1IsLongDouble.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">blaze::IsNumeric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric types.This type trait tests whether or not the given template parameter is a numeric data type. Blaze considers all integral (except <em>bool</em>), floating point, and complex data types as numeric data types. In case the type is a numeric type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/dea/structblaze_1_1IsNumeric.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db8/structblaze_1_1IsObject.html">blaze::IsObject&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is an object type. All types are considered object types except references, <em>void</em>, and function types. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>T</em> is an object type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/db8/structblaze_1_1IsObject.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db0/structblaze_1_1IsPod.html">blaze::IsPod&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for pod data types.This type trait tests whether or not the given template parameter is a POD (Plain Old Data) or not. In case the type is a POD, the <em>value</em> member enumeration is set o 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/db0/structblaze_1_1IsPod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html">blaze::IsPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a pointer type (including function pointers, but excluding pointers to members) or not. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a pointer type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d0f/structblaze_1_1IsPointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dad/structblaze_1_1IsReference.html">blaze::IsReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is a reference type (including references to functions). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a reference type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/dad/structblaze_1_1IsReference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html">blaze::IsStrictlySame&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are not ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type, then the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1IsStrictlySame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d89/structblaze_1_1IsSame.html">blaze::IsSame&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type (ignoring the cv-qualifiers), then the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d89/structblaze_1_1IsSame.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d59/structblaze_1_1IsShort.html">blaze::IsShort&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for short integer types.This type trait tests whether or not the given template parameter is a short integer type (i.e., either (signed) short or unsigned short, possibly cv-qualified). In case the type is a short integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d59/structblaze_1_1IsShort.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/def/structblaze_1_1IsSigned.html">blaze::IsSigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for signed data types.This type trait tests whether or not the given template parameter is a signed integral data type. In case the type is a signed (possibly cv-qualified) data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/def/structblaze_1_1IsSigned.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html">blaze::IsUnsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unsigned data types.This type trait tests whether or not the given template parameter is an unsigned, integral data type. In case the type is an unsigned (possibly cv-qualified) data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d8c/structblaze_1_1IsUnsigned.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html">blaze::IsVectorizable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vectorizable types.Depending on the available instruction set (SSE, SSE2, AVX, MIC, ...), this type trait tests whether or not the given template parameter is a vectorizable type, i.e. a type for which intrinsic vector operations and optimizations can be used. Currently, only signed/unsigned short, signed/unsigned int, signed/unsigned long, float, and double are considered to be vectorizable types. In case the type is vectorizable, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsVectorizable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html">blaze::IsVoid&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <em>void</em> data type.This type trait tests whether or not the given template parameter is of type <em>void</em> (ignoring the cv-qualifiers). In case the type is of type <em>void</em>, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d6b/structblaze_1_1IsVoid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html">blaze::IsVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for volatile data types.The <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> type trait tests whether or not the given template parameter is a (top level) volatile-qualified data type. In case the given data type is volatile, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/db9/structblaze_1_1IsVolatile.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">blaze::RemoveConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of const-qualifiers.The <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait removes all top level 'const' qualifiers from the given type <em>T</em>.  <a href="../../d9/d25/structblaze_1_1RemoveConst.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">blaze::RemoveCV&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level cv-qualifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes all top level cv-qualifiers from the given type <em>T</em>.  <a href="../../d0/d1c/structblaze_1_1RemoveCV.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">blaze::RemovePointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of pointer modifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes any pointer modifiers from the given type <em>T</em>.  <a href="../../df/d04/structblaze_1_1RemovePointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">blaze::RemoveReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of reference modifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes any reference modifiers from the given type <em>T</em>.  <a href="../../d5/df4/structblaze_1_1RemoveReference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">blaze::RemoveVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of volatile-qualifiers.The <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait removes all top level 'volatile' qualifiers from the given type <em>T</em>.  <a href="../../d9/de6/structblaze_1_1RemoveVolatile.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:41 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
