<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Dense Vectors</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Dense Vectors<div class="ingroups"><a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:dd/da3/group__dynamic__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html">DynamicVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d95/group__static__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html">StaticVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d95/group__dense__vector__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d95/group__dense__vector__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; VT, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for N-dimensional dense vectors.The <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html" title="Base class for N-dimensional dense vectors.The DenseVector class is a base class for all arbitrarily ...">DenseVector</a> class is a base class for all arbitrarily sized (N-dimensional) dense vectors. It provides an abstraction from the actual type of the dense vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d1/db2/structblaze_1_1DenseVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, DMatDVecMultExpr&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga772dd5fcf447845bc8fcc3ac8cf1ad86">blaze::operator*</a> (const DenseMatrix&lt; T1, false &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="#ga772dd5fcf447845bc8fcc3ac8cf1ad86"></a><br/></td></tr>
<tr class="separator:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012e8376b6a90ae026e49788155babf2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga012e8376b6a90ae026e49788155babf2"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, MultExprTrait&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga012e8376b6a90ae026e49788155babf2">blaze::operator*</a> (const DenseMatrix&lt; T1, SO &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga012e8376b6a90ae026e49788155babf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>).  <a href="#ga012e8376b6a90ae026e49788155babf2"></a><br/></td></tr>
<tr class="separator:ga012e8376b6a90ae026e49788155babf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae207ab7da28fcdb71b662e4714dcf066"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae207ab7da28fcdb71b662e4714dcf066"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, DMatSVecMultExpr&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae207ab7da28fcdb71b662e4714dcf066">blaze::operator*</a> (const DenseMatrix&lt; T1, false &gt; &amp;mat, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae207ab7da28fcdb71b662e4714dcf066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="#gae207ab7da28fcdb71b662e4714dcf066"></a><br/></td></tr>
<tr class="separator:gae207ab7da28fcdb71b662e4714dcf066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73bd8f2e202abf61042ada0dd4306931"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga73bd8f2e202abf61042ada0dd4306931"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, MultExprTrait&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga73bd8f2e202abf61042ada0dd4306931">blaze::operator*</a> (const DenseMatrix&lt; T1, SO &gt; &amp;mat, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga73bd8f2e202abf61042ada0dd4306931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>).  <a href="#ga73bd8f2e202abf61042ada0dd4306931"></a><br/></td></tr>
<tr class="separator:ga73bd8f2e202abf61042ada0dd4306931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memTemplItemLeft" align="right" valign="top">const DVecAbsExpr&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0cc328e0a8995b75b93180c8dfbd2757">blaze::abs</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the absolute values of each single element of <em>dv</em>.  <a href="#ga0cc328e0a8995b75b93180c8dfbd2757"></a><br/></td></tr>
<tr class="separator:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacade1745b146d7c63876fdd2bd755ce6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gacade1745b146d7c63876fdd2bd755ce6"><td class="memTemplItemLeft" align="right" valign="top">const DVecDVecAddExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacade1745b146d7c63876fdd2bd755ce6">blaze::operator+</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacade1745b146d7c63876fdd2bd755ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>).  <a href="#gacade1745b146d7c63876fdd2bd755ce6"></a><br/></td></tr>
<tr class="separator:gacade1745b146d7c63876fdd2bd755ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa687a75e64beca784394faf86435249c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa687a75e64beca784394faf86435249c"><td class="memTemplItemLeft" align="right" valign="top">const DVecDVecCrossExpr&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa687a75e64beca784394faf86435249c">blaze::operator%</a> (const DenseVector&lt; T1, false &gt; &amp;lhs, const DenseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa687a75e64beca784394faf86435249c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>).  <a href="#gaa687a75e64beca784394faf86435249c"></a><br/></td></tr>
<tr class="separator:gaa687a75e64beca784394faf86435249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a0127d216ecef466edad068782d9e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaf6a0127d216ecef466edad068782d9e4"><td class="memTemplItemLeft" align="right" valign="top">const DVecDVecMultExpr&lt; T1, T2, <br class="typebreak"/>
TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf6a0127d216ecef466edad068782d9e4">blaze::operator*</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf6a0127d216ecef466edad068782d9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>).  <a href="#gaf6a0127d216ecef466edad068782d9e4"></a><br/></td></tr>
<tr class="separator:gaf6a0127d216ecef466edad068782d9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memTemplItemLeft" align="right" valign="top">const DVecDVecSubExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd0d441ba5993e9b6df62c534cec34c9">blaze::operator-</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafd0d441ba5993e9b6df62c534cec34c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>).  <a href="#gafd0d441ba5993e9b6df62c534cec34c9"></a><br/></td></tr>
<tr class="separator:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memTemplItemLeft" align="right" valign="top">const DVecEvalExpr&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab9e162d0ea6b3e4493b9666c6730d690">blaze::eval</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gab9e162d0ea6b3e4493b9666c6730d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense vector expression <em>dv</em>.  <a href="#gab9e162d0ea6b3e4493b9666c6730d690"></a><br/></td></tr>
<tr class="separator:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522af93898ec5c11cfeab2045caf9875"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga522af93898ec5c11cfeab2045caf9875"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T2 &gt;<br class="typebreak"/>
, typename <br class="typebreak"/>
DVecScalarDivExprHelper&lt; T1, <br class="typebreak"/>
T2, TF &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga522af93898ec5c11cfeab2045caf9875">blaze::operator/</a> (const DenseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga522af93898ec5c11cfeab2045caf9875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a dense vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_101.png"/>).  <a href="#ga522af93898ec5c11cfeab2045caf9875"></a><br/></td></tr>
<tr class="separator:ga522af93898ec5c11cfeab2045caf9875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memTemplItemLeft" align="right" valign="top">const DVecScalarMultExpr&lt; VT, <br class="typebreak"/>
typename BaseElementType&lt; VT &gt;<br class="typebreak"/>
::Type, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga74b6a05f757de44c4daf52b23538cfaf">blaze::operator-</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga74b6a05f757de44c4daf52b23538cfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_102.png"/>).  <a href="#ga74b6a05f757de44c4daf52b23538cfaf"></a><br/></td></tr>
<tr class="separator:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T2 &gt;<br class="typebreak"/>
, typename MultExprTrait&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4a5cc3fa262a06eeba8ab4f0d4c3777e">blaze::operator*</a> (const DenseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_46.png"/>).  <a href="#ga4a5cc3fa262a06eeba8ab4f0d4c3777e"></a><br/></td></tr>
<tr class="separator:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T1 &gt;<br class="typebreak"/>
, typename MultExprTrait&lt; T1, <br class="typebreak"/>
T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac6096b0a74a5fbf88317a167bc29fa61">blaze::operator*</a> (T1 scalar, const DenseVector&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gac6096b0a74a5fbf88317a167bc29fa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_103.png"/>).  <a href="#gac6096b0a74a5fbf88317a167bc29fa61"></a><br/></td></tr>
<tr class="separator:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecAddExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac46fecdd6785f66d7521f88db40dd1b9">blaze::operator+</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac46fecdd6785f66d7521f88db40dd1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>).  <a href="#gac46fecdd6785f66d7521f88db40dd1b9"></a><br/></td></tr>
<tr class="separator:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362d09a6d64deafb689d21a6f7559c78"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga362d09a6d64deafb689d21a6f7559c78"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecAddExpr&lt; T2, T1, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga362d09a6d64deafb689d21a6f7559c78">blaze::operator+</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga362d09a6d64deafb689d21a6f7559c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>).  <a href="#ga362d09a6d64deafb689d21a6f7559c78"></a><br/></td></tr>
<tr class="separator:ga362d09a6d64deafb689d21a6f7559c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecCrossExpr&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaff63460a43ecf99ed5dc7c51cd505f04">blaze::operator%</a> (const DenseVector&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>).  <a href="#gaff63460a43ecf99ed5dc7c51cd505f04"></a><br/></td></tr>
<tr class="separator:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecSubExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4d9d2740625e6b7d83d77e0284ae21e4">blaze::operator-</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>).  <a href="#ga4d9d2740625e6b7d83d77e0284ae21e4"></a><br/></td></tr>
<tr class="separator:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393d4b96ce4e176295d336a195dd05af"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga393d4b96ce4e176295d336a195dd05af"><td class="memTemplItemLeft" align="right" valign="top">const DVecTransExpr&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga393d4b96ce4e176295d336a195dd05af">blaze::trans</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga393d4b96ce4e176295d336a195dd05af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense vector.  <a href="#ga393d4b96ce4e176295d336a195dd05af"></a><br/></td></tr>
<tr class="separator:ga393d4b96ce4e176295d336a195dd05af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../dd/d15/classSMatDVecMultExpr.html">SMatDVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa2e3b97cb2cb32f3037b4cb0b82d30bb">blaze::operator*</a> (const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="#gaa2e3b97cb2cb32f3037b4cb0b82d30bb"></a><br/></td></tr>
<tr class="separator:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e6513f0b783fd27d9c1977f2efbfc0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga15e6513f0b783fd27d9c1977f2efbfc0"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, MultExprTrait&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga15e6513f0b783fd27d9c1977f2efbfc0">blaze::operator*</a> (const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga15e6513f0b783fd27d9c1977f2efbfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>).  <a href="#ga15e6513f0b783fd27d9c1977f2efbfc0"></a><br/></td></tr>
<tr class="separator:ga15e6513f0b783fd27d9c1977f2efbfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26f9406627cf1059b01755eb635e1f2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae26f9406627cf1059b01755eb635e1f2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d27/classSVecDVecCrossExpr.html">SVecDVecCrossExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae26f9406627cf1059b01755eb635e1f2">blaze::operator%</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const DenseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae26f9406627cf1059b01755eb635e1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>).  <a href="#gae26f9406627cf1059b01755eb635e1f2"></a><br/></td></tr>
<tr class="separator:gae26f9406627cf1059b01755eb635e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e490c7a24853b803499ba9e3becaa50"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga5e490c7a24853b803499ba9e3becaa50"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d48/classSVecDVecSubExpr.html">SVecDVecSubExpr</a>&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5e490c7a24853b803499ba9e3becaa50">blaze::operator-</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5e490c7a24853b803499ba9e3becaa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>).  <a href="#ga5e490c7a24853b803499ba9e3becaa50"></a><br/></td></tr>
<tr class="separator:ga5e490c7a24853b803499ba9e3becaa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d4c/classSVecSVecCrossExpr.html">SVecSVecCrossExpr</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga29a3e2901fb6e319d4792001d250b9b0">blaze::operator%</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga29a3e2901fb6e319d4792001d250b9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>).  <a href="#ga29a3e2901fb6e319d4792001d250b9b0"></a><br/></td></tr>
<tr class="separator:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d0/d02/classTDMatDVecMultExpr.html">TDMatDVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae70d2b23499b4e8bee9ca6ef02ec0c91">blaze::operator*</a> (const DenseMatrix&lt; T1, true &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="#gae70d2b23499b4e8bee9ca6ef02ec0c91"></a><br/></td></tr>
<tr class="separator:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d6/dcb/classTDMatSVecMultExpr.html">TDMatSVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0c99693a856adeaec5e4a50baf3d72d7">blaze::operator*</a> (const DenseMatrix&lt; T1, true &gt; &amp;mat, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="#ga0c99693a856adeaec5e4a50baf3d72d7"></a><br/></td></tr>
<tr class="separator:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T2 &gt;<br class="typebreak"/>
, <a class="el" href="../../d1/dfa/classTDVecDMatMultExpr.html">TDVecDMatMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga545f87ad5a7df86714ebf79fa949ac9a">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;vec, const DenseMatrix&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>).  <a href="#ga545f87ad5a7df86714ebf79fa949ac9a"></a><br/></td></tr>
<tr class="separator:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada61a5175e8bee0111464a947259e7be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gada61a5175e8bee0111464a947259e7be"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T2 &gt;<br class="typebreak"/>
, MultExprTrait&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gada61a5175e8bee0111464a947259e7be">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;vec, const DenseMatrix&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gada61a5175e8bee0111464a947259e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>).  <a href="#gada61a5175e8bee0111464a947259e7be"></a><br/></td></tr>
<tr class="separator:gada61a5175e8bee0111464a947259e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabffb97c0a6209458be80e0a1248aad83"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gabffb97c0a6209458be80e0a1248aad83"><td class="memTemplItemLeft" align="right" valign="top">DisableIf<br class="typebreak"/>
&lt; TDVecDVecMultExprHelper&lt; T1, <br class="typebreak"/>
T2 &gt;, const typename MultTrait<br class="typebreak"/>
&lt; typename T1::ElementType, <br class="typebreak"/>
typename T2::ElementType &gt;<br class="typebreak"/>
::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabffb97c0a6209458be80e0a1248aad83">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;lhs, const DenseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabffb97c0a6209458be80e0a1248aad83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).  <a href="#gabffb97c0a6209458be80e0a1248aad83"></a><br/></td></tr>
<tr class="separator:gabffb97c0a6209458be80e0a1248aad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f074f8895555f6ffba3904b7f0db905"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga9f074f8895555f6ffba3904b7f0db905"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T2 &gt;<br class="typebreak"/>
, MultExprTrait&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga9f074f8895555f6ffba3904b7f0db905">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;vec, const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga9f074f8895555f6ffba3904b7f0db905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>).  <a href="#ga9f074f8895555f6ffba3904b7f0db905"></a><br/></td></tr>
<tr class="separator:ga9f074f8895555f6ffba3904b7f0db905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade884e87c42ffd73fab8b47c28437b6d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gade884e87c42ffd73fab8b47c28437b6d"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T1 &gt;<br class="typebreak"/>
, <a class="el" href="../../d9/d18/classTSMatDVecMultExpr.html">TSMatDVecMultExpr</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gade884e87c42ffd73fab8b47c28437b6d">blaze::operator*</a> (const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gade884e87c42ffd73fab8b47c28437b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>).  <a href="#gade884e87c42ffd73fab8b47c28437b6d"></a><br/></td></tr>
<tr class="separator:gade884e87c42ffd73fab8b47c28437b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5974dacb6ef941fef3fc7f4eaba3ada4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga5974dacb6ef941fef3fc7f4eaba3ada4"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf<br class="typebreak"/>
&lt; IsMatMatMultExpr&lt; T2 &gt;<br class="typebreak"/>
, MultExprTrait&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::Type::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5974dacb6ef941fef3fc7f4eaba3ada4">blaze::operator*</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;vec, const DenseMatrix&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga5974dacb6ef941fef3fc7f4eaba3ada4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>).  <a href="#ga5974dacb6ef941fef3fc7f4eaba3ada4"></a><br/></td></tr>
<tr class="separator:ga5974dacb6ef941fef3fc7f4eaba3ada4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga2aba8ea15c113036a6394b083f1df30c"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga2aba8ea15c113036a6394b083f1df30c"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga2aba8ea15c113036a6394b083f1df30c">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::assign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/df7/classTDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga2aba8ea15c113036a6394b083f1df30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector.  <a href="#ga2aba8ea15c113036a6394b083f1df30c"></a><br/></td></tr>
<tr class="separator:ga2aba8ea15c113036a6394b083f1df30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6eead65aff5e0a2523eb364e8ec6038"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gad6eead65aff5e0a2523eb364e8ec6038"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad6eead65aff5e0a2523eb364e8ec6038">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::assign</a> (<a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/df7/classTDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gad6eead65aff5e0a2523eb364e8ec6038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector.  <a href="#gad6eead65aff5e0a2523eb364e8ec6038"></a><br/></td></tr>
<tr class="separator:gad6eead65aff5e0a2523eb364e8ec6038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c05663dd2c32a18e765e9c810c717c"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gac8c05663dd2c32a18e765e9c810c717c"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac8c05663dd2c32a18e765e9c810c717c">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::addAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/df7/classTDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gac8c05663dd2c32a18e765e9c810c717c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector.  <a href="#gac8c05663dd2c32a18e765e9c810c717c"></a><br/></td></tr>
<tr class="separator:gac8c05663dd2c32a18e765e9c810c717c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b97a817205a7666e3a591ae4b327e0b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga4b97a817205a7666e3a591ae4b327e0b"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4b97a817205a7666e3a591ae4b327e0b">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::subAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/df7/classTDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ga4b97a817205a7666e3a591ae4b327e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector.  <a href="#ga4b97a817205a7666e3a591ae4b327e0b"></a><br/></td></tr>
<tr class="separator:ga4b97a817205a7666e3a591ae4b327e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d196d9ef990086dd810b1faefa572f"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gac6d196d9ef990086dd810b1faefa572f"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac6d196d9ef990086dd810b1faefa572f">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::multAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const <a class="el" href="../../d7/df7/classTDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:gac6d196d9ef990086dd810b1faefa572f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector.  <a href="#gac6d196d9ef990086dd810b1faefa572f"></a><br/></td></tr>
<tr class="separator:gac6d196d9ef990086dd810b1faefa572f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseVector operators</h2></td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7718438f21d78c1c5cd61e11b620f3ac">blaze::operator==</a> (const DenseVector&lt; T1, TF1 &gt; &amp;lhs, const DenseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense vectors.  <a href="#ga7718438f21d78c1c5cd61e11b620f3ac"></a><br/></td></tr>
<tr class="separator:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga521be975d8edae170b5f159468392be7">blaze::operator==</a> (const DenseVector&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga521be975d8edae170b5f159468392be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a sparse vector.  <a href="#ga521be975d8edae170b5f159468392be7"></a><br/></td></tr>
<tr class="separator:ga521be975d8edae170b5f159468392be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga90afa4cbe670f292f01e0a8c0989bcb4">blaze::operator==</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const DenseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse vector and a dense vector.  <a href="#ga90afa4cbe670f292f01e0a8c0989bcb4"></a><br/></td></tr>
<tr class="separator:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6253dd234e9b48e75e0ec02050b959"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gacb6253dd234e9b48e75e0ec02050b959"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; IsNumeric&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacb6253dd234e9b48e75e0ec02050b959">blaze::operator==</a> (const DenseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:gacb6253dd234e9b48e75e0ec02050b959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a scalar value.  <a href="#gacb6253dd234e9b48e75e0ec02050b959"></a><br/></td></tr>
<tr class="separator:gacb6253dd234e9b48e75e0ec02050b959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab20536da4445fc400927e431fbdf331"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaab20536da4445fc400927e431fbdf331"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; IsNumeric&lt; T1 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaab20536da4445fc400927e431fbdf331">blaze::operator==</a> (T1 scalar, const DenseVector&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gaab20536da4445fc400927e431fbdf331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense vector.  <a href="#gaab20536da4445fc400927e431fbdf331"></a><br/></td></tr>
<tr class="separator:gaab20536da4445fc400927e431fbdf331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1d006cc08bc800f749d0cffb9ddbb9a7">blaze::operator!=</a> (const DenseVector&lt; T1, TF1 &gt; &amp;lhs, const DenseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense vectors.  <a href="#ga1d006cc08bc800f749d0cffb9ddbb9a7"></a><br/></td></tr>
<tr class="separator:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">blaze::operator!=</a> (const DenseVector&lt; T1, TF1 &gt; &amp;lhs, const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a sparse vector.  <a href="#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"></a><br/></td></tr>
<tr class="separator:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabde27bb0ee7f998bef03dceca10cdce3">blaze::operator!=</a> (const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;lhs, const DenseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabde27bb0ee7f998bef03dceca10cdce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse vector and a dense vector.  <a href="#gabde27bb0ee7f998bef03dceca10cdce3"></a><br/></td></tr>
<tr class="separator:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; IsNumeric&lt; T2 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga2c595fd68d81ec3c4fd30eb74bbcee95">blaze::operator!=</a> (const DenseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a scalar value.  <a href="#ga2c595fd68d81ec3c4fd30eb74bbcee95"></a><br/></td></tr>
<tr class="separator:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; IsNumeric&lt; T1 &gt;<br class="typebreak"/>
, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd6f670282d5c2e8ee9f118f71f894a3">blaze::operator!=</a> (T1 scalar, const DenseVector&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense vector.  <a href="#gafd6f670282d5c2e8ee9f118f71f894a3"></a><br/></td></tr>
<tr class="separator:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseVector functions</h2></td></tr>
<tr class="memitem:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4da64f9a5a93b1db2af56e66ade1cd9d">blaze::min</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the dense vector.  <a href="#ga4da64f9a5a93b1db2af56e66ade1cd9d"></a><br/></td></tr>
<tr class="separator:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89281c892b6ca297f5450ed0e3948c81"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga89281c892b6ca297f5450ed0e3948c81"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga89281c892b6ca297f5450ed0e3948c81">blaze::max</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga89281c892b6ca297f5450ed0e3948c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the dense vector.  <a href="#ga89281c892b6ca297f5450ed0e3948c81"></a><br/></td></tr>
<tr class="separator:ga89281c892b6ca297f5450ed0e3948c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0cc328e0a8995b75b93180c8dfbd2757"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecAbsExpr&lt;VT,TF&gt; blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the absolute values of each single element of <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of each single element of <em>dv</em>.</dd></dl>
<p>The <em>abs</em> function calculates the absolute value of each element of the input vector <em>dv</em>. The operator returns an expression representing this operation.<br/>
 The following example demonstrates the use of the <em>abs</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863" title="Returns a matrix containing the absolute values of each single element of dm.">abs</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab9e162d0ea6b3e4493b9666c6730d690"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecEvalExpr&lt;VT,TF&gt; blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given dense vector expression <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense vector.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given dense vector expression <em>dv</em>. The operator returns an expression representing this operation.<br/>
 The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6" title="Forces the evaluation of the given dense matrix expression dm.">eval</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga89281c892b6ca297f5450ed0e3948c81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::max </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest element of the dense vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The largest dense vector element.</dd></dl>
<p>This function returns the largest element of the given dense vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a class="anchor" id="ga4da64f9a5a93b1db2af56e66ade1cd9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::min </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest element of the dense vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The smallest dense vector element.</dd></dl>
<p>This function returns the smallest element of the given dense vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a class="anchor" id="ga1d006cc08bc800f749d0cffb9ddbb9a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two dense vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense vector and a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="gabde27bb0ee7f998bef03dceca10cdce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a sparse vector and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c595fd68d81ec3c4fd30eb74bbcee95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; IsNumeric&lt; T2 &gt;, bool &gt;::Type blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense vector and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> one value of the vector is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a class="anchor" id="gafd6f670282d5c2e8ee9f118f71f894a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; IsNumeric&lt; T1 &gt;, bool &gt;::Type blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a scalar value and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> one value of the vector is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a class="anchor" id="ga29a3e2901fb6e319d4792001d250b9b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d4c/classSVecSVecCrossExpr.html">SVecSVecCrossExpr</a>&lt;T1,T2&gt; blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a( 3UL ), b( 3UL );</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a % b;</div>
</div><!-- fragment --><p>The operator returns a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class.">CrossTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaa687a75e64beca784394faf86435249c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecDVecCrossExpr&lt;T1,T2&gt; blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a( 3UL ), b( 3UL );</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a % b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class.">CrossTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gae26f9406627cf1059b01755eb635e1f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d27/classSVecDVecCrossExpr.html">SVecDVecCrossExpr</a>&lt;T1,T2&gt; blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a( 3UL );</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> b( 3UL );</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a % b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class.">CrossTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaff63460a43ecf99ed5dc7c51cd505f04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecCrossExpr&lt;T1,T2&gt; blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_97.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a( 3UL );</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> b( 3UL );</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a % b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class.">CrossTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gabffb97c0a6209458be80e0a1248aad83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; TDVecDVecMultExprHelper&lt; T1, T2 &gt;, const typename MultTrait&lt; typename T1::ElementType, typename T2::ElementType &gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>). </p>
<p>Intrinsic optimized multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_110.png"/>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line">blaze::double res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72" title="Calculation of the transpose of the given dense matrix.">trans</a>(a) * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two dense vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> a, b;</div>
<div class="line">blaze::double res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72" title="Calculation of the transpose of the given dense matrix.">trans</a>(a) * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaf6a0127d216ecef466edad068782d9e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecDVecMultExpr&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_99.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the component product of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga0c99693a856adeaec5e4a50baf3d72d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, <a class="el" href="../../d6/dcb/classTDMatSVecMultExpr.html">TDMatSVecMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseMatrix&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major dense matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices.">blaze::columnMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,columnVector&gt;</a> x;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga4a5cc3fa262a06eeba8ab4f0d4c3777e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T2&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a dense vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_46.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a dense vector and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = a * 1.25;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Both data types <em>T1::ElementType</em> and <em>T2</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a class="anchor" id="gade884e87c42ffd73fab8b47c28437b6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, <a class="el" href="../../d9/d18/classTSMatDVecMultExpr.html">TSMatDVecMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major sparse matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices.">blaze::columnMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga9f074f8895555f6ffba3904b7f0db905"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T2&gt;, MultExprTrait&lt;T1,T2&gt; &gt;::Type::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side sparse matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a dense vector and a sparse matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_109.png"/>. </p>

</div>
</div>
<a class="anchor" id="gae207ab7da28fcdb71b662e4714dcf066"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, DMatSVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseMatrix&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major dense matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double,columnVector&gt;</a> x;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaa2e3b97cb2cb32f3037b4cb0b82d30bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, <a class="el" href="../../dd/d15/classSMatDVecMultExpr.html">SMatDVecMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major sparse matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gac6096b0a74a5fbf88317a167bc29fa61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T1&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_103.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = 1.25 * a;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Both data types <em>T1</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a class="anchor" id="ga73bd8f2e202abf61042ada0dd4306931"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T1&gt;, MultExprTrait&lt;T1,T2&gt; &gt;::Type::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseMatrix&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix-matrix multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a dense matrix-matrix multiplication expression and a sparse vector. It restructures the expression <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}=A*(B*\vec{x}) $" src="../../form_92.png"/>. </p>

</div>
</div>
<a class="anchor" id="ga5974dacb6ef941fef3fc7f4eaba3ada4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T2&gt;, MultExprTrait&lt;T1,T2&gt; &gt;::Type::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseMatrix&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a sparse vector and a dense matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_109.png"/>. </p>

</div>
</div>
<a class="anchor" id="ga15e6513f0b783fd27d9c1977f2efbfc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T1&gt;, MultExprTrait&lt;T1,T2&gt; &gt;::Type::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d0b/structSparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix-matrix multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a sparse matrix-matrix multiplication expression and a dense vector. It restructures the expression <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}=A*(B*\vec{x}) $" src="../../form_92.png"/>. </p>

</div>
</div>
<a class="anchor" id="ga772dd5fcf447845bc8fcc3ac8cf1ad86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, DMatDVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseMatrix&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major dense matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga012e8376b6a90ae026e49788155babf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T1&gt;, MultExprTrait&lt;T1,T2&gt; &gt;::Type::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseMatrix&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_90.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix-matrix multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a dense matrix-matrix multiplication expression and a dense vector. It restructures the expression <img class="formulaInl" alt="$ \vec{x}=(A*B)*\vec{x} $" src="../../form_91.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}=A*(B*\vec{x}) $" src="../../form_92.png"/>. </p>

</div>
</div>
<a class="anchor" id="gae70d2b23499b4e8bee9ca6ef02ec0c91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, <a class="el" href="../../d0/d02/classTDMatDVecMultExpr.html">TDMatDVecMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseMatrix&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_89.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major dense matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices.">blaze::columnMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga545f87ad5a7df86714ebf79fa949ac9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T2&gt;, <a class="el" href="../../d1/dfa/classTDVecDMatMultExpr.html">TDVecDMatMultExpr</a>&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseMatrix&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_107.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices.">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = x * A;</div>
</div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class.">MultTrait</a> class template.<br/>
 In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gada61a5175e8bee0111464a947259e7be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T2&gt;, MultExprTrait&lt;T1,T2&gt; &gt;::Type::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseMatrix&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a dense vector and a dense matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_108.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_109.png"/>. </p>

</div>
</div>
<a class="anchor" id="gac46fecdd6785f66d7521f88db40dd1b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecAddExpr&lt;T1,T2,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, c;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a + b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class.">AddTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga362d09a6d64deafb689d21a6f7559c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecAddExpr&lt;T2,T1,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a + b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class.">AddTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gacade1745b146d7c63876fdd2bd755ce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecDVecAddExpr&lt;T1,T2,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_96.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a + b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class.">AddTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga5e490c7a24853b803499ba9e3becaa50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d48/classSVecDVecSubExpr.html">SVecDVecSubExpr</a>&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted from the sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> a;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class.">SubTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga4d9d2740625e6b7d83d77e0284ae21e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecSubExpr&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted from the dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, c;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">blaze::CompressedVector&lt;double&gt;</a> b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class.">SubTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gafd0d441ba5993e9b6df62c534cec34c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecDVecSubExpr&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_100.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class.">SubTrait</a> class template.<br/>
 In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga74b6a05f757de44c4daf52b23538cfaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecScalarMultExpr&lt;VT,typename BaseElementType&lt;VT&gt;::Type,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a dense vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_102.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the vector.</dd></dl>
<p>This operator represents the negation of a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = -a;</div>
</div><!-- fragment --><p>The operator returns an expression representing the negation of the given dense vector. </p>

</div>
</div>
<a class="anchor" id="ga522af93898ec5c11cfeab2045caf9875"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T2&gt;, typename DVecScalarDivExprHelper&lt;T1,T2,TF&gt;::Type &gt;::Type blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the divison of a dense vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_101.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the division of a dense vector by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = a / 0.24;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Both data types <em>T1::ElementType</em> and <em>T2</em> have to be supported by the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class.">DivTrait</a> class template. Note that this operator only works for scalar values of built-in data type.</p>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="ga7718438f21d78c1c5cd61e11b620f3ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two dense vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga521be975d8edae170b5f159468392be7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense vector and a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90afa4cbe670f292f01e0a8c0989bcb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dae/structSparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a sparse vector and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb6253dd234e9b48e75e0ec02050b959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; IsNumeric&lt; T2 &gt;, bool &gt;::Type blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense vector and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the vector are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> all values of the vector are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a class="anchor" id="gaab20536da4445fc400927e431fbdf331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; IsNumeric&lt; T1 &gt;, bool &gt;::Type blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a scalar value and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the vector are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> all values of the vector are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a class="anchor" id="ga393d4b96ce4e176295d336a195dd05af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecTransExpr&lt;VT,!TF&gt; blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const DenseVector&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the dense vector.</dd></dl>
<p>This function returns an expression representing the transpose of the given dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors.">blaze::columnVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors.">blaze::rowVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,columnVector&gt;</a> a;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector&lt;double,rowVector&gt;</a>    b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga76200b1dad6b7f87831941fa6eaa0b72" title="Calculation of the transpose of the given dense matrix.">trans</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Friends</h2>
<a class="anchor" id="gac8c05663dd2c32a18e765e9c810c717c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, typename MT&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this operator can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="ga2aba8ea15c113036a6394b083f1df30c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, typename MT&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this operator can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="gad6eead65aff5e0a2523eb364e8ec6038"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, typename MT&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- transpose sparse matrix multiplication expression to a sparse vector. Due to the explicit application of the SFINAE principle, this operator can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="gac6d196d9ef990086dd810b1faefa572f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, typename MT&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this operator can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="ga4b97a817205a7666e3a591ae4b327e0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, typename MT&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this operator can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:40 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
