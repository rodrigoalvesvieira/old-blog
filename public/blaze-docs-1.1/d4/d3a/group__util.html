<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Utility module</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utility module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:db/dca/group__assert"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dca/group__assert.html">Assertions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d68/group__constraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d68/group__constraints.html">Compile time constraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/dff/group__logging"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/group__logging.html">Logging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d87/group__mpl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d87/group__mpl.html">Meta-Programming Language</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d10/group__random"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d10/group__random.html">Random number generation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/daf/group__singleton"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/daf/group__singleton.html">Singleton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/db9/group__threads"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db9/group__threads.html">Thread parallelization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d0d/group__timing"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0d/group__timing.html">Time measurement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/df3/group__typelist"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df3/group__typelist.html">Type lists</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d5a/group__type__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d5a/group__type__traits.html">Type traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d16/group__value__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d16/group__value__traits.html">Value traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dfd/structblaze_1_1AlignmentTrait.html">blaze::AlignmentTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the required alignment of the given data type.The <a class="el" href="../../db/dfd/structblaze_1_1AlignmentTrait.html" title="Evaluation of the required alignment of the given data type.The AlignmentTrait class template evaluat...">AlignmentTrait</a> class template evaluates the required alignment for the given data type. For instance, for fundamental data types that can be vectorized via SSE or AVX instructions, the proper alignment is 16 or 32 bytes, respectively. For all other data types, a multiple of the alignment chosen by the compiler is returned. The evaluated alignment can be queried via the nested <em>value</em> member.  <a href="../../db/dfd/structblaze_1_1AlignmentTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html">blaze::DisableIfTrue&lt; Condition, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is Not An Error (SFINAE) class.The <a class="el" href="../../df/df2/structblaze_1_1DisableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIfTrue class template is an auxiliary ...">DisableIfTrue</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is Not An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../df/df2/structblaze_1_1DisableIfTrue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">blaze::DisableIf&lt; Condition, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is Not An Error (SFINAE) class.The <a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The DisableIf class template is an auxiliary tool...">DisableIf</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is Not An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d6/d36/structblaze_1_1DisableIf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da5/structblaze_1_1EmptyType.html">blaze::EmptyType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty data type for utility purposes.  <a href="../../d7/da5/structblaze_1_1EmptyType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html">blaze::EnableIfTrue&lt; Condition, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is Not An Error (SFINAE) class.The <a class="el" href="../../d7/d2c/structblaze_1_1EnableIfTrue.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIfTrue class template is an auxiliary t...">EnableIfTrue</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is Not An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d7/d2c/structblaze_1_1EnableIfTrue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">blaze::EnableIf&lt; Condition, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution Failure Is Not An Error (SFINAE) class.The <a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html" title="Substitution Failure Is Not An Error (SFINAE) class.The EnableIf class template is an auxiliary tool ...">EnableIf</a> class template is an auxiliary tool for an intentional application of the Substitution Failure Is Not An Error (SFINAE) principle. It allows a function template or a class template specialization to include or exclude itself from a set of matching functions or specializations based on properties of its template arguments. For instance, it can be used to restrict the selection of a function template to specific data types. The following example illustrates this in more detail.  <a href="../../d9/d28/structblaze_1_1EnableIf.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfc/classblaze_1_1InputString.html">blaze::InputString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a string wrapper.The <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class is a wrapper class for the purpose to read input strings delimited by quotations from streams, like for instance "example input". All characters between the leading and the trailing quotation are extracted unchanged from the input stream, including whitespaces. The input string has to be in one single line. In case of input errors, the <em>std::istream::failbit</em> of the input stream is set.  <a href="../../da/dfc/classblaze_1_1InputString.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dea/structblaze_1_1Limits.html">blaze::Limits&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical limits of built-in data types.The <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">Limits</a> class provides numerical limits for the following built-in data types:  <a href="../../d9/dea/structblaze_1_1Limits.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8d/classblaze_1_1MemoryPool.html">blaze::MemoryPool&lt; Type, Blocksize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory pool for small objects.The memory pool efficiently improves the performance of dynamic memory allocations for small objects. By allocating a large block of memory that can be dynamically assigned to small objects, the memory allocation is reduced from a few hundred cycles to only a few cycles.<br/>
 The memory pool is build from memory blocks of type <a class="el" href="../../d2/d64/structblaze_1_1MemoryPool_1_1Block.html" title="Memory block within the memory bool.">Block</a>, which hold the memory for a specified number of objects. The memory of these blocks is managed as a single free list.  <a href="../../d2/d8d/classblaze_1_1MemoryPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html">blaze::NonCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-copyable class instances.The <a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html" title="Base class for non-copyable class instances.The NonCopyable class is intended to work as a base class...">NonCopyable</a> class is intended to work as a base class for non-copyable classes. Both the copy constructor and the copy assignment operator are declared private and left undefined in order to prohibit copy operations of the derived classes.<br/>
.  <a href="../../dd/dbc/classblaze_1_1NonCopyable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/classblaze_1_1NonCreatable.html">blaze::NonCreatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-creatable (static) classes.The <a class="el" href="../../d6/d8e/classblaze_1_1NonCreatable.html" title="Base class for non-creatable (static) classes.The NonCreatable class is intended to work as a base cl...">NonCreatable</a> class is intended to work as a base class for non-creatable classes, i.e. classes that cannot be instantiated and exclusively offer static functions/data. Both the standard as well as the copy constructor and the copy assignment operator are declared private and left undefinded in order to prohibit the instantiation of objects of derived classes.<br/>
.  <a href="../../d6/d8e/classblaze_1_1NonCreatable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d82/classblaze_1_1Null.html">blaze::Null</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL pointer in C++. For this, the NULL macro is replaced by an instance of the <a class="el" href="../../dd/d82/classblaze_1_1Null.html" title="Safe C++ NULL pointer implementation.This implementation offers a remedy for the use of the NULL poin...">Null</a> class, which can only be assigned and compared with pointers and pointers-to-member. Therefore the use of NULL regains the type safety it lost in C++ due to the strict C++ type system.<br/>
 The NULL pointer is used exactly as before:  <a href="../../dd/d82/classblaze_1_1Null.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da4/classblaze_1_1NullType.html">blaze::NullType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type for generic codes.The <a class="el" href="../../dd/da4/classblaze_1_1NullType.html" title="Utility type for generic codes.The NullType class represents an invalid or terminating data type for ...">NullType</a> class represents an invalid or terminating data type for generic codes. For instance, the <a class="el" href="../../df/d88/structblaze_1_1TypeList.html" title="Implementation of a type list.The TypeList class is an implementation of a type list according to the...">TypeList</a> class uses the <a class="el" href="../../dd/da4/classblaze_1_1NullType.html" title="Utility type for generic codes.The NullType class represents an invalid or terminating data type for ...">NullType</a> as terminating data type for the type list.  <a href="../../dd/da4/classblaze_1_1NullType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html">blaze::ArrayDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-delete policy class.The <a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> policy functor class applies an array delete operation to the given argument. Note that the array delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply an <a class="el" href="../../d0/d60/structblaze_1_1ArrayDelete.html" title="Array-delete policy class.The ArrayDelete policy functor class applies an array delete operation to t...">ArrayDelete</a> functor to a pointer to an array of objects of incomplete type results in a compile time error!  <a href="../../d0/d60/structblaze_1_1ArrayDelete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d70/structblaze_1_1ConstantGrowth.html">blaze::ConstantGrowth&lt; Growth &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant growth policy class.The <a class="el" href="../../d3/d70/structblaze_1_1ConstantGrowth.html" title="Constant growth policy class.The ConstantGrowth policy class implements a constant growth strategy...">ConstantGrowth</a> policy class implements a constant growth strategy. It can be customized for any purpose: the <em>Growth</em> template argument specifies the constant increase of the given size.  <a href="../../d3/d70/structblaze_1_1ConstantGrowth.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4f/structblaze_1_1LinearGrowth.html">blaze::LinearGrowth&lt; Growth &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear growth policy class.The <a class="el" href="../../df/d4f/structblaze_1_1LinearGrowth.html" title="Linear growth policy class.The LinearGrowth policy class implements a linear growth strategy...">LinearGrowth</a> policy class implements a linear growth strategy. It can be customized for any purpose: the <em>Growth</em> template argument specifies the factor of the size growth.  <a href="../../df/d4f/structblaze_1_1LinearGrowth.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc7/structblaze_1_1NoDelete.html">blaze::NoDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-delete policy class.  <a href="../../d8/dc7/structblaze_1_1NoDelete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3f/structblaze_1_1OptimalGrowth.html">blaze::OptimalGrowth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimal growth policy class.The <a class="el" href="../../d2/d3f/structblaze_1_1OptimalGrowth.html" title="Optimal growth policy class.The OptimalGrowth policy class implements the optimal growth strategy sug...">OptimalGrowth</a> policy class implements the optimal growth strategy suggested by Andrew Koenig for the std::vector class (see Andrew Koenig's column in the September 1998 issue of JOOP (Journal of Object-Oriented Programming), or the Dr. Dobb's article 'C++ Made Easier: How Vectors Grow', 2001). It applies an exponential growth strategy using a factor of 1.5 and additionally ensures that the sizes returns are always multiples of four.  <a href="../../d2/d3f/structblaze_1_1OptimalGrowth.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html">blaze::PtrDelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer-delete policy class.The <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> policy functor class applies a delete operation to the given argument. Note that the delete operation is NOT permitted for inclomplete types (i.e. declared but undefined data types). The attempt to apply a <a class="el" href="../../d9/d94/structblaze_1_1PtrDelete.html" title="Pointer-delete policy class.The PtrDelete policy functor class applies a delete operation to the give...">PtrDelete</a> functor to a pointer to an object of incomplete type results in a compile time error!  <a href="../../d9/d94/structblaze_1_1PtrDelete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html">blaze::PtrIterator&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an iterator for pointer vectors.The <a class="el" href="../../d2/d15/classblaze_1_1PtrIterator.html" title="Implementation of an iterator for pointer vectors.The PtrIterator class follows the example of the ra...">PtrIterator</a> class follows the example of the random-access iterator classes of the STL. However, the focus of this iterator implementation is the use with (polymorphic) pointers. The implementation of the Blaze library eases the use of iterators over a range of pointers and improves the semantics on these pointers.<br/>
.  <a href="../../d2/d15/classblaze_1_1PtrIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">blaze::PtrVector&lt; T, D, G &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a vector for (polymorphic) pointers.  <a href="../../d3/ddf/classblaze_1_1PtrVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html">blaze::PtrVector&lt; T, D, G &gt;::CastIterator&lt; C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast iterator for polymorphic pointer vectors.The <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> class is part of the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> class and represent a forward iterator over all elements of type <em>C</em> contained in a range of elements of type <em>T</em>, where <em>C</em> is a type derived from <em>T</em>.  <a href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html">blaze::PtrVector&lt; T, D, G &gt;::ConstCastIterator&lt; C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast iterator for polymorphic pointer vectors.The <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> class is part of the <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html" title="Implementation of a vector for (polymorphic) pointers.">PtrVector</a> class and represent a forward iterator over all elements of type <em>C</em> contained in a range of elements of type <em>T</em>, where <em>C</em> is a type derived from <em>T</em>. The <a class="el" href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The ConstCastIterator class is part of the PtrV...">ConstCastIterator</a> is the counterpart of <a class="el" href="../../df/d5d/classblaze_1_1PtrVector_1_1CastIterator.html" title="Dynamic cast iterator for polymorphic pointer vectors.The CastIterator class is part of the PtrVector...">CastIterator</a> for constant vectors.  <a href="../../df/dcd/classblaze_1_1PtrVector_1_1ConstCastIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc1/structblaze_1_1SelectType.html">blaze::SelectType&lt; Select, T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type selection.The <a class="el" href="../../da/dc1/structblaze_1_1SelectType.html" title="Compile time type selection.The SelectType class template selects one of the two given types T1 and T...">SelectType</a> class template selects one of the two given types <em>T1</em> and <em>T2</em> depending on the <em>Select</em> template argument. In case the <em>Select</em> compile time constant expression evaluates to <em>true</em>, the member type definition <em>Type</em> is set to <em>T1</em>. In case <em>Select</em> evaluates to <em>false</em>, <em>Type</em> is set to <em>T2</em>.  <a href="../../da/dc1/structblaze_1_1SelectType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d81/structblaze_1_1SizeTrait.html">blaze::SizeTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d6/d81/structblaze_1_1SizeTrait.html" title="Base template for the SizeTrait class.The SizeTrait class template evaluates the larger of the two gi...">SizeTrait</a> class.The <a class="el" href="../../d6/d81/structblaze_1_1SizeTrait.html" title="Base template for the SizeTrait class.The SizeTrait class template evaluates the larger of the two gi...">SizeTrait</a> class template evaluates the larger of the two given data types by use of the sizeof operator. <a class="el" href="../../d6/d81/structblaze_1_1SizeTrait.html" title="Base template for the SizeTrait class.The SizeTrait class template evaluates the larger of the two gi...">SizeTrait</a> defines the data types <em>Large</em> for the larger of the two given data types and <em>Small</em> for the smaller data type. In case both data types have the same size, the first given data type <em>T1</em> is chosen as the large and <em>T2</em> as the small data type.  <a href="../../d6/d81/structblaze_1_1SizeTrait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html">blaze::SystemClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">System clock of the Blaze library.The <a class="el" href="../../dd/dc7/classblaze_1_1SystemClock.html" title="System clock of the Blaze library.The SystemClock class represents the system clock of the Blaze libr...">SystemClock</a> class represents the system clock of the Blaze library. The system clock is the central timing functionality that can be used to query for the start time of the process, the current timestamp and the elapsed time since the start of the process. The following example demonstrates how the single system clock instance is acquired via the <a class="el" href="../../d4/d3a/group__util.html#ga0547f7041f58ea87ba920e520236bd12" title="Returns a handle to the Blaze system clock.">theSystemClock()</a> functcion and how the system clock can be used:  <a href="../../dd/dc7/classblaze_1_1SystemClock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d54/classblaze_1_1UnsignedValue.html">blaze::UnsignedValue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a wrapper for built-in unsigned integral values.This class wraps a value of built-in unsigned integral type in order to be able to extract non-negative unsigned integral values from an input stream.  <a href="../../da/d54/classblaze_1_1UnsignedValue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d1e/classblaze_1_1complex.html">blaze::complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex data type of the Blaze library.  <a href="../../d3/d1e/classblaze_1_1complex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">blaze::size_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type of the Blaze library.  <a href="../../d9/dcd/classblaze_1_1size__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8c/classblaze_1_1ptrdiff__t.html">blaze::ptrdiff_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer difference type of the Blaze library.  <a href="../../d2/d8c/classblaze_1_1ptrdiff__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3b/classblaze_1_1int8__t.html">blaze::int8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integer type of the Blaze library.  <a href="../../d6/d3b/classblaze_1_1int8__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da1/classblaze_1_1uint8__t.html">blaze::uint8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned integer type of the Blaze library.  <a href="../../da/da1/classblaze_1_1uint8__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d66/classblaze_1_1int16__t.html">blaze::int16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integer type of the Blaze library.  <a href="../../d9/d66/classblaze_1_1int16__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3a/classblaze_1_1uint16__t.html">blaze::uint16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned integer type of the Blaze library.  <a href="../../de/d3a/classblaze_1_1uint16__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d2d/classblaze_1_1int32__t.html">blaze::int32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integer type of the Blaze library.  <a href="../../de/d2d/classblaze_1_1int32__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dba/classblaze_1_1uint32__t.html">blaze::uint32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integer type of the Blaze library.  <a href="../../d6/dba/classblaze_1_1uint32__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc7/classblaze_1_1int64__t.html">blaze::int64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer type of the Blaze library.  <a href="../../d8/dc7/classblaze_1_1int64__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d68/classblaze_1_1uint64__t.html">blaze::uint64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned integer type of the Blaze library.  <a href="../../d5/d68/classblaze_1_1uint64__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga717f03c9a8efb450fbe93bb091715d41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga717f03c9a8efb450fbe93bb091715d41"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga717f03c9a8efb450fbe93bb091715d41">blaze::byte</a></td></tr>
<tr class="memdesc:ga717f03c9a8efb450fbe93bb091715d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte data type of the Blaze library.The <em>byte</em> data type is guaranteed to be an integral data type of size 1. <br/></td></tr>
<tr class="separator:ga717f03c9a8efb450fbe93bb091715d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51501d11e1575bb19857805e953374b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga51501d11e1575bb19857805e953374b0"></a>
typedef boost::false_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga51501d11e1575bb19857805e953374b0">blaze::FalseType</a></td></tr>
<tr class="memdesc:ga51501d11e1575bb19857805e953374b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type/value traits base class.The FalseType class is used as base class for type traits and value traits that evaluate to <em>false</em>. <br/></td></tr>
<tr class="separator:ga51501d11e1575bb19857805e953374b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f70ec9de722c70928b8b85cb3613a9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f70ec9de722c70928b8b85cb3613a9d"></a>
typedef boost::shared_ptr<br class="typebreak"/>
&lt; SystemClock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga5f70ec9de722c70928b8b85cb3613a9d">blaze::SystemClockID</a></td></tr>
<tr class="memdesc:ga5f70ec9de722c70928b8b85cb3613a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for the system clock of the Blaze library. <br/></td></tr>
<tr class="separator:ga5f70ec9de722c70928b8b85cb3613a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242cb995877991e8eb1ef9e5b7c19313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga242cb995877991e8eb1ef9e5b7c19313"></a>
typedef boost::shared_ptr<br class="typebreak"/>
&lt; const SystemClock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga242cb995877991e8eb1ef9e5b7c19313">blaze::ConstSystemClockID</a></td></tr>
<tr class="memdesc:ga242cb995877991e8eb1ef9e5b7c19313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for the system clock of the Blaze library. <br/></td></tr>
<tr class="separator:ga242cb995877991e8eb1ef9e5b7c19313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8c782eb16b2134ae70864788baaed1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa8c782eb16b2134ae70864788baaed1"></a>
typedef boost::true_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaaa8c782eb16b2134ae70864788baaed1">blaze::TrueType</a></td></tr>
<tr class="memdesc:gaaa8c782eb16b2134ae70864788baaed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits base class.The TrueType class is used as base class for type traits and value traits that evaluate to <em>true</em>. <br/></td></tr>
<tr class="separator:gaaa8c782eb16b2134ae70864788baaed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3059b61931f29e6cdb0175b7e96108"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba3059b61931f29e6cdb0175b7e96108"></a>
typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaba3059b61931f29e6cdb0175b7e96108">blaze::large_t</a></td></tr>
<tr class="memdesc:gaba3059b61931f29e6cdb0175b7e96108"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest available signed integer data type. <br/></td></tr>
<tr class="separator:gaba3059b61931f29e6cdb0175b7e96108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ce6bfe70ea9dc573085dbd1089bfe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga68ce6bfe70ea9dc573085dbd1089bfe1"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga68ce6bfe70ea9dc573085dbd1089bfe1">blaze::ularge_t</a></td></tr>
<tr class="memdesc:ga68ce6bfe70ea9dc573085dbd1089bfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest available unsigned integer data type. <br/></td></tr>
<tr class="separator:ga68ce6bfe70ea9dc573085dbd1089bfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f0fa27c14041df892fbaf250ed3bda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga22f0fa27c14041df892fbaf250ed3bda"></a>
typedef ularge_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga22f0fa27c14041df892fbaf250ed3bda">blaze::id_t</a></td></tr>
<tr class="memdesc:ga22f0fa27c14041df892fbaf250ed3bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer data type for integral IDs. <br/></td></tr>
<tr class="separator:ga22f0fa27c14041df892fbaf250ed3bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int N&gt; </td></tr>
<tr class="memitem:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4">blaze::dimensionof</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static evaluation of array dimensions.  <a href="#gaceb0ea831c8a56b9212d7a55e10ea5a4"></a><br/></td></tr>
<tr class="separator:gaceb0ea831c8a56b9212d7a55e10ea5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab24f595ee412ad6647cfb8cde602606e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab24f595ee412ad6647cfb8cde602606e"></a>
const <a class="el" href="../../dd/d82/classblaze_1_1Null.html">blaze::Null</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gab24f595ee412ad6647cfb8cde602606e">NULL</a></td></tr>
<tr class="memdesc:gab24f595ee412ad6647cfb8cde602606e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global NULL pointer.This instance of the Null class replaces the NULL macro to ensure a type-safe NULL pointer. <br/></td></tr>
<tr class="separator:gab24f595ee412ad6647cfb8cde602606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
InputString operators</h2></td></tr>
<tr class="memitem:ga942b82bb3e222d3e7651094a372cabd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga942b82bb3e222d3e7651094a372cabd6">blaze::IsFileName</a> (const InputString &amp;s)</td></tr>
<tr class="memdesc:ga942b82bb3e222d3e7651094a372cabd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for a valid file name.  <a href="#ga942b82bb3e222d3e7651094a372cabd6"></a><br/></td></tr>
<tr class="separator:ga942b82bb3e222d3e7651094a372cabd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#gaa1ba7ee1b13541bf5bef5cb2eaf66207">blaze::operator&lt;&lt;</a> (std::ostream &amp;os, const InputString &amp;str)</td></tr>
<tr class="memdesc:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class.  <a href="#gaa1ba7ee1b13541bf5bef5cb2eaf66207"></a><br/></td></tr>
<tr class="separator:gaa1ba7ee1b13541bf5bef5cb2eaf66207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga80a4395873ec4d104b68f12f5e9dc29f">blaze::operator&gt;&gt;</a> (std::istream &amp;is, InputString &amp;str)</td></tr>
<tr class="memdesc:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global input operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class.  <a href="#ga80a4395873ec4d104b68f12f5e9dc29f"></a><br/></td></tr>
<tr class="separator:ga80a4395873ec4d104b68f12f5e9dc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Pointer cast operators</h2></td></tr>
<tr class="memitem:ga297b8d4addf0242658e5b89e9204460f"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga297b8d4addf0242658e5b89e9204460f"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f">blaze::static_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga297b8d4addf0242658e5b89e9204460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast for pointer types.  <a href="#ga297b8d4addf0242658e5b89e9204460f"></a><br/></td></tr>
<tr class="separator:ga297b8d4addf0242658e5b89e9204460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5e788ec214cce869014db4e8d5366e"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga6f5e788ec214cce869014db4e8d5366e"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e">blaze::dynamic_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga6f5e788ec214cce869014db4e8d5366e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast for pointer types.  <a href="#ga6f5e788ec214cce869014db4e8d5366e"></a><br/></td></tr>
<tr class="separator:ga6f5e788ec214cce869014db4e8d5366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28219d814bac7718746d5042aef9de09"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga28219d814bac7718746d5042aef9de09"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09">blaze::const_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga28219d814bac7718746d5042aef9de09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast for pointer types.  <a href="#ga28219d814bac7718746d5042aef9de09"></a><br/></td></tr>
<tr class="separator:ga28219d814bac7718746d5042aef9de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memTemplItemLeft" align="right" valign="top">To *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4">blaze::reinterpret_pointer_cast</a> (From *ptr)</td></tr>
<tr class="memdesc:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret cast for pointer types.  <a href="#ga3e7e73afb20167f3b3dc8f1a032b98c4"></a><br/></td></tr>
<tr class="separator:ga3e7e73afb20167f3b3dc8f1a032b98c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Smart pointer cast operators</h2></td></tr>
<tr class="memitem:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga70575290b13daca96bd7bcdf1ea2ae65">blaze::static_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static cast for smart pointers.  <a href="#ga70575290b13daca96bd7bcdf1ea2ae65"></a><br/></td></tr>
<tr class="separator:ga70575290b13daca96bd7bcdf1ea2ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga29989fd5881d9e3d3204be7cc9c7c3db">blaze::dynamic_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic cast for smart pointers.  <a href="#ga29989fd5881d9e3d3204be7cc9c7c3db"></a><br/></td></tr>
<tr class="separator:ga29989fd5881d9e3d3204be7cc9c7c3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618bf0481250b859a7d953d54a31fffa"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga618bf0481250b859a7d953d54a31fffa"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga618bf0481250b859a7d953d54a31fffa">blaze::const_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga618bf0481250b859a7d953d54a31fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast for smart pointers.  <a href="#ga618bf0481250b859a7d953d54a31fffa"></a><br/></td></tr>
<tr class="separator:ga618bf0481250b859a7d953d54a31fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e5a317853deb66bcd03883873f20ee"><td class="memTemplParams" colspan="2">template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </td></tr>
<tr class="memitem:ga29e5a317853deb66bcd03883873f20ee"><td class="memTemplItemLeft" align="right" valign="top">S&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga29e5a317853deb66bcd03883873f20ee">blaze::reinterpret_pointer_cast</a> (S&lt; From &gt; ptr)</td></tr>
<tr class="memdesc:ga29e5a317853deb66bcd03883873f20ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret cast for smart pointers.  <a href="#ga29e5a317853deb66bcd03883873f20ee"></a><br/></td></tr>
<tr class="separator:ga29e5a317853deb66bcd03883873f20ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
System clock setup functions</h2></td></tr>
<tr class="memitem:ga0547f7041f58ea87ba920e520236bd12"><td class="memItemLeft" align="right" valign="top">SystemClockID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga0547f7041f58ea87ba920e520236bd12">blaze::theSystemClock</a> ()</td></tr>
<tr class="memdesc:ga0547f7041f58ea87ba920e520236bd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the Blaze system clock.  <a href="#ga0547f7041f58ea87ba920e520236bd12"></a><br/></td></tr>
<tr class="separator:ga0547f7041f58ea87ba920e520236bd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Time functions</h2></td></tr>
<tr class="memitem:ga4fb888631070076eac5ab46d3caddbd5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga4fb888631070076eac5ab46d3caddbd5">blaze::getDate</a> ()</td></tr>
<tr class="memdesc:ga4fb888631070076eac5ab46d3caddbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a formated date string in the form YYYY-MM-DD.  <a href="#ga4fb888631070076eac5ab46d3caddbd5"></a><br/></td></tr>
<tr class="separator:ga4fb888631070076eac5ab46d3caddbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3829412570c98a06a4bc95c550da95d8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga3829412570c98a06a4bc95c550da95d8">blaze::getTime</a> ()</td></tr>
<tr class="memdesc:ga3829412570c98a06a4bc95c550da95d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a formated time and date string.  <a href="#ga3829412570c98a06a4bc95c550da95d8"></a><br/></td></tr>
<tr class="separator:ga3829412570c98a06a4bc95c550da95d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d046bc597081ad84f727946f245a800"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2d046bc597081ad84f727946f245a800">blaze::getWcTime</a> ()</td></tr>
<tr class="memdesc:ga2d046bc597081ad84f727946f245a800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current wall clock time in seconds.  <a href="#ga2d046bc597081ad84f727946f245a800"></a><br/></td></tr>
<tr class="separator:ga2d046bc597081ad84f727946f245a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d3a/group__util.html#ga2ff2b8c34d2384faa6b3e97954b98e78">blaze::getCpuTime</a> ()</td></tr>
<tr class="memdesc:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current CPU time in seconds.  <a href="#ga2ff2b8c34d2384faa6b3e97954b98e78"></a><br/></td></tr>
<tr class="separator:ga2ff2b8c34d2384faa6b3e97954b98e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga28219d814bac7718746d5042aef9de09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To * blaze::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const cast for pointer types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value.</dd></dl>
<p>The const_pointer_cast function is used exactly as the built-in const_cast operator but for pointer types.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> A* a1;                          <span class="comment">// Pointer to a constant A object</span></div>
<div class="line">A* a2 = <a class="code" href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09" title="Const cast for pointer types.">const_pointer_cast</a>&lt;A&gt;( a1 );  <span class="comment">// Const cast to a pointer to a non-constant A object</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga618bf0481250b859a7d953d54a31fffa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S&lt; To &gt; blaze::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">S&lt; From &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const cast for smart pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The smart pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted smart pointer.</dd></dl>
<p>The const_pointer_cast function is used exactly as the built-in const_cast operator but for smart pointers.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> SharedPtr&lt;A&gt;        APtr;</div>
<div class="line"><span class="keyword">typedef</span> SharedPtr&lt;const A&gt;  ConstAPtr;</div>
<div class="line"></div>
<div class="line">ConstAPtr a1;                           <span class="comment">// Smart pointer to a constant A object</span></div>
<div class="line">APtr a2 = <a class="code" href="../../d4/d3a/group__util.html#ga28219d814bac7718746d5042aef9de09" title="Const cast for pointer types.">const_pointer_cast</a>&lt;A&gt;( a1 );  <span class="comment">// Const cast to a smart pointer to a non-constant A object</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaceb0ea831c8a56b9212d7a55e10ea5a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t blaze::dimensionof </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static evaluation of array dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Reference to a static array of type T and size N. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dimension of the static array.</dd></dl>
<p>The dimensionof function is a safe way to evaluate the size of an array. The function only works for array arguments and fails for pointers and user-defined class types.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>              ai[ 42 ];</div>
<div class="line"><span class="keywordtype">int</span>*             pi( ai );</div>
<div class="line">std::vector&lt;int&gt; vi( 42 );</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4" title="Static evaluation of array dimensions.">dimensionof</a>( ai );  <span class="comment">// Returns the size of the integer array (42)</span></div>
<div class="line"><a class="code" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4" title="Static evaluation of array dimensions.">dimensionof</a>( pi );  <span class="comment">// Fails to compile!</span></div>
<div class="line"><a class="code" href="../../d4/d3a/group__util.html#gaceb0ea831c8a56b9212d7a55e10ea5a4" title="Static evaluation of array dimensions.">dimensionof</a>( vi );  <span class="comment">// Fails to compile!</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6f5e788ec214cce869014db4e8d5366e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To * blaze::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast for pointer types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value.</dd></dl>
<p>The dynamic_pointer_cast function is used exactly as the built-in dynamic_cast operator but for pointer types. As in case with the built-in dynamic_cast 0 is returned if the runtime type conversion doesn't succeed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { ... };</div>
<div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B { ... };</div>
<div class="line"></div>
<div class="line">B* b = ...;                           <span class="comment">// Base pointer</span></div>
<div class="line">D* d = <a class="code" href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e" title="Dynamic cast for pointer types.">dynamic_pointer_cast</a>&lt;D&gt;( b );  <span class="comment">// Dynamic down-cast</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga29989fd5881d9e3d3204be7cc9c7c3db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S&lt; To &gt; blaze::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">S&lt; From &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic cast for smart pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The smart pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted smart pointer.</dd></dl>
<p>The dynamic_pointer_cast function is used exactly as the built-in dynamic_cast operator but for smart pointers. As in case with the built-in dynamic_cast 0 is returned if the runtime type conversion doesn't succeed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { ... };</div>
<div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B { ... };</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> SharedPtr&lt;B&gt; BPtr;</div>
<div class="line"><span class="keyword">typedef</span> SharedPtr&lt;D&gt; DPtr;</div>
<div class="line"></div>
<div class="line">BPtr b = ...;                           <span class="comment">// Base smart pointer</span></div>
<div class="line">DPtr d = <a class="code" href="../../d4/d3a/group__util.html#ga6f5e788ec214cce869014db4e8d5366e" title="Dynamic cast for pointer types.">dynamic_pointer_cast</a>&lt;D&gt;( b );  <span class="comment">// Dynamic down-cast</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga2ff2b8c34d2384faa6b3e97954b98e78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double blaze::getCpuTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current CPU time in seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>The current CPU time in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fb888631070076eac5ab46d3caddbd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string blaze::getDate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating a formated date string in the form YYYY-MM-DD. </p>
<dl class="section return"><dt>Returns</dt><dd>Formated date string </dd></dl>

</div>
</div>
<a class="anchor" id="ga3829412570c98a06a4bc95c550da95d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string blaze::getTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating a formated time and date string. </p>
<dl class="section return"><dt>Returns</dt><dd>Formated time and date string in the format WEEKDAY DAY.MONTH YEAR, HOUR:MINUTES </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d046bc597081ad84f727946f245a800"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double blaze::getWcTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current wall clock time in seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>The current wall clock time in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="ga942b82bb3e222d3e7651094a372cabd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::IsFileName </td>
          <td>(</td>
          <td class="paramtype">const InputString &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for a valid file name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The file name string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the string is a file name, <em>false</em> if it is not.</dd></dl>
<p>In order to be a file name, the first character can only be an alphanumerical character, '.', '/' or '_'. </p>

</div>
</div>
<a class="anchor" id="gaa1ba7ee1b13541bf5bef5cb2eaf66207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; blaze::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputString &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global output operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Reference to the output stream. </td></tr>
    <tr><td class="paramname">str</td><td>Reference to a string object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80a4395873ec4d104b68f12f5e9dc29f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; blaze::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputString &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global input operator for the <a class="el" href="../../da/dfc/classblaze_1_1InputString.html" title="Implementation of a string wrapper.The InputString class is a wrapper class for the purpose to read i...">InputString</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Reference to the input stream. </td></tr>
    <tr><td class="paramname">str</td><td>Reference to a string object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream.</dd></dl>
<p>The input operator guarantees that the string object is not changed in the case of an input error. </p>

</div>
</div>
<a class="anchor" id="ga3e7e73afb20167f3b3dc8f1a032b98c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To * blaze::reinterpret_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterpret cast for pointer types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value.</dd></dl>
<p>The reinterpret_pointer_cast function is used exactly as the built-in reinterpret_cast operator but for pointer types.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A { ... };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* raw = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[ <span class="keyword">sizeof</span>(A)*10 ];  <span class="comment">// Allocation of raw memory</span></div>
<div class="line">A* a = <a class="code" href="../../d4/d3a/group__util.html#ga3e7e73afb20167f3b3dc8f1a032b98c4" title="Reinterpret cast for pointer types.">reinterpret_pointer_cast</a>&lt;A&gt;( raw );               <span class="comment">// Reinterpretation cast</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga29e5a317853deb66bcd03883873f20ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S&lt; To &gt; blaze::reinterpret_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">S&lt; From &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterpret cast for smart pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The smart pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted smart pointer.</dd></dl>
<p>The reinterpret_pointer_cast function is used exactly as the built-in reinterpret_cast operator but for smart pointers. </p>

</div>
</div>
<a class="anchor" id="ga297b8d4addf0242658e5b89e9204460f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To * blaze::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static cast for pointer types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted value.</dd></dl>
<p>The static_pointer_cast function is used exactly as the built-in static_cast operator but for pointer types.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { ... };</div>
<div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B { ... };</div>
<div class="line"></div>
<div class="line">B* b = <span class="keyword">new</span> D();                      <span class="comment">// Base pointer to a derived class object</span></div>
<div class="line">D* d = <a class="code" href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f" title="Static cast for pointer types.">static_pointer_cast</a>&lt;D&gt;( b );  <span class="comment">// Static down-cast</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga70575290b13daca96bd7bcdf1ea2ae65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , template&lt; typename &gt; class S, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S&lt; To &gt; blaze::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">S&lt; From &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static cast for smart pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The smart pointer to be cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The casted smart pointer.</dd></dl>
<p>The static_pointer_cast function is used exactly as the built-in static_cast operator but for smart pointers.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>B { ... };</div>
<div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B { ... };</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> SharedPtr&lt;B&gt; BPtr;</div>
<div class="line"><span class="keyword">typedef</span> SharedPtr&lt;D&gt; DPtr;</div>
<div class="line"></div>
<div class="line">BPtr b = BPtr( <span class="keyword">new</span> D() );              <span class="comment">// Base smart pointer to a derived class object</span></div>
<div class="line">DPtr d = <a class="code" href="../../d4/d3a/group__util.html#ga297b8d4addf0242658e5b89e9204460f" title="Static cast for pointer types.">static_pointer_cast</a>&lt;D&gt;( b );  <span class="comment">// Static down-cast</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga0547f7041f58ea87ba920e520236bd12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SystemClockID blaze::theSystemClock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the Blaze system clock. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the active system clock. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 20 2013 08:14:41 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
