---
layout: post_no_comments
title: Avoid The Legacy Trap
---

<span class="drops">T</span>ech companies often have a really hard time maintaining legacy code, and this is for a reason.

Legacy code frequently is something you have now that was developed years ago by someone who is probably out of the company today. It also often contain solutions that may be - by now - overpast. Maybe a technique used for solving a problem is not so useful anymore.

Additionaly, programmers like to be in the edge of technology <a href="#foot-link-1">[1]</a>. And it will be hard to hire someone to maintain your 3-years-old project because that person is more likely to want to master today's technology <a href="#foot-link-2">[2]</a>.

One way to avoid falling into the legacy trap is by **always** updating your code. If your project runs on top of a Web Framework <a href="#foot-link-3">[3]</a>, consider updating the framework version everytime a new stable version of it appears.

Of course this has a cost. Updating software that you consider "finished" <a href="#foot-link-4">[4]</a> will take time, things will broke. But I think it's an investiment, not a waste. It's certainly cheaper to spend on updates than to have trouble studying oudated technology. It's pretty hard to find a Rails 2.3 book, for example. And even harder to not to get bored by it (when you know how better the technology is today).

You should know that the learning curve for old stuff is usually much bigger than the one for current stuff. Try learning Basic and Ruby simultaneously and see which one you'll grasp first <a href="#foot-link-5">[5]</a> <a href="#foot-link-6">[6]</a>.

If you're going to stick with a project for a big deal of time, maybe you should consider making it easier to maitain, and software updates helps you do that. Make it easy to get along with the code over time.

Generally, obsolete technology is something really hard to deal with. Avoid getting it obsolete.

<p class="foot-link" id="foot-link-1">[1]: At least those you should consider hiring.</p>

<p class="foot-link" id="foot-link-2">[2]: This might be specially important for Web Development, in which changes - by comparison - happens more often than in Desktop programming.</p>

<p class="foot-link" id="foot-link-3">[3]: Or tomorrow's technology, if she is that good a hacker.</p>

<p class="foot-link" id="foot-link-4">[4]: In Software, this is often a mistake to think that a project is "finished". A better way to deal with Software (and it applies to technology, in general) is to think of it as a on-going, live thing, incrementally evolving over time.</p>

<p class="foot-link" id="foot-link-5">[5]: To avoid throwing a fallacy here, I used Basic and Ruby as examples because both, for their time, seemed to be simpler than the other languages available. It'd be an evil argument using Fortran and Ruby, for example. Fortran is harder than Ruby invariably and timelessly.</p>

<p class="foot-link" id="foot-link-6">[6]: Another reason why learning Basic now would be harder than Ruby is simplified by one word: resources. Information resources for technologies decreases over time. By now you can find a handful of Ruby books on the shelves but it won't be like this once Ruby gets obsolete. And the pattern repeats for seminars, courses, community, etc.</p>